<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valpaint</title>
    <link href="https://fonts.cdnfonts.com/css/valorant" rel="stylesheet" media="print" onload="this.media='all'">
    <!-- 스크립트 최적화 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer></script>
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>

    <!-- Supabase 클라이언트 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- reCAPTCHA v2 추가 -->
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>
    <style>
        :root {
            --main-bg: #0f1923;
            --secondary-bg: #1a242d;
            --accent-color: #ff4655;
            --accent-hover: #ff6b76;
            --text-color: #ece8e1;
            --text-muted: #8b978f;
            --border-color: #1f2326;
            --btn-bg: #232c34;
            --btn-hover: #2b3842;
            --cell-active: #ff4655;
            --cell-empty: #1a242d;
            --cell-border: #2d3844;
            --canvas-bg: #0f1923;
            --modal-bg: rgba(15, 25, 35, 0.9);
            --valorant-font: 'VALORANT', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Tahoma', sans-serif;
            color: var(--text-color);
        }
        
        .valorant-text {
            font-family: var(--valorant-font);
            letter-spacing: 1px;
        }

        body {
            background-color: var(--main-bg);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 25%, rgba(255, 70, 85, 0.03) 0%, transparent 25%),
                radial-gradient(circle at 70% 75%, rgba(255, 70, 85, 0.03) 0%, transparent 25%);
            z-index: -1;
        }

        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--secondary-bg);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .logo {
            font-family: var(--valorant-font);
            font-size: 2rem;
            color: var(--accent-color);
            text-shadow: 0 0 5px rgba(255, 70, 85, 0.5);
            cursor: pointer;
            text-decoration: none;
        }

        .toolbar {
            padding: 0.75rem 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 15px;
        }

        .tool-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .btn {
            padding: 0.5rem 1rem;
            background-color: var(--btn-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            min-width: 40px;
            text-align: center;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background-color: var(--btn-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn-accent {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            font-family: var(--valorant-font);
        }

        .btn-accent:hover {
            background-color: var(--accent-hover);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .user-profile {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: var(--secondary-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .user-profile:hover {
            background-color: var(--btn-hover);
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }

        .btn:active::after {
            animation: ripple 0.6s ease-out;
        }

        @keyframes ripple {
            0% {
                opacity: 1;
                transform: scale(0, 0) translate(-50%, -50%);
            }
            100% {
                opacity: 0;
                transform: scale(20, 20) translate(-50%, -50%);
            }
        }

        .btn-group {
            display: flex;
        }

        .btn-group .btn {
            border-radius: 0;
            border-right: none;
        }

        .btn-group .btn:first-child {
            border-top-left-radius: 2px;
            border-bottom-left-radius: 2px;
        }

        .btn-group .btn:last-child {
            border-top-right-radius: 2px;
            border-bottom-right-radius: 2px;
            border-right: 1px solid var(--border-color);
        }

        .btn-group .btn.active {
            background-color: var(--accent-color);
            color: #fff;
        }

        .btn-round {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .btn-icon {
            display: flex;
            align-items: center;
        }

        .btn-icon svg {
            margin-right: 5px;
            width: 16px;
            height: 16px;
        }

        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 1rem;
            background-color: var(--main-bg);
        }

        .canvas-container {
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            background-color: var(--canvas-bg);
            max-width: 100%;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: box-shadow 0.3s ease;
        }
        
        .canvas-container:hover {
            box-shadow: 0 0 30px rgba(255, 70, 85, 0.1);
        }

        .drawing-canvas {
            display: grid;
            background-color: var(--canvas-bg);
            margin: 0 auto;
        }

        .emoji-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid var(--cell-border);
            background-color: var(--cell-empty);
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.2s;
            user-select: none;
        }

        .emoji-cell:hover {
            background-color: rgba(45, 56, 68, 0.6);
            transform: scale(1.05);
            z-index: 1;
        }

        .emoji-cell.active {
            background-color: var(--cell-active);
            color: white;
            transform: scale(1);
            animation: cellActivate 0.3s ease;
        }
        
        @keyframes cellActivate {
            0% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .emoji-cell.transparent {
            background-color: transparent;
            border-color: rgba(45, 56, 68, 0.3);
        }
        
        .emoji-cell.active.transparent {
            background-color: var(--cell-active);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            z-index: 100;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .modal.show {
            opacity: 1;
            display: flex;
        }

        .modal-content {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 1.5rem;
            width: 480px;
            max-width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .modal-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .modal-close {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1.5rem;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: var(--accent-color);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--btn-bg);
            color: var(--text-color);
            border-radius: 2px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .form-control:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 70, 85, 0.3); /* 그림자 효과 강화 */
        }
        .btn:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }
        .form-range {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            background: var(--main-bg);
            border-radius: 5px;
            outline: none;
        }

        .form-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .form-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            background-color: var(--main-bg);
        }

        .file-item {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-item:hover {
            background-color: var(--btn-bg);
        }

        .file-item.selected {
            background-color: var(--btn-hover);
        }

        .file-item-actions {
            display: flex;
            gap: 5px;
        }

        .file-preview {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--main-bg);
            overflow: hidden;
            font-family: monospace;
            max-height: 150px;
            margin-bottom: 1rem;
        }

        /* 온라인 갤러리 페이지 스타일 */
        .page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg);
            z-index: 100;
            overflow-y: auto;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .page.active {
            display: block;
            opacity: 1;
        }

        .page-header {
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--secondary-bg);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .page-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .page-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            font-size: 1.5rem;
        }

        .back-button {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .back-button:hover {
            color: var(--accent-color);
        }

        .gallery-layout {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .gallery-item {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .gallery-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .gallery-preview {
            height: 200px;
            background-color: var(--main-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            padding: 10px;
            overflow: hidden;
        }

        .gallery-info {
            padding: 15px;
        }

        .gallery-title {
            font-weight: bold;
            margin-bottom: 8px;
            word-break: break-all;
            font-size: 1.1rem;
        }

        .gallery-creator {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .gallery-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 10px;
        }
        
        .gallery-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }
        
        .gallery-tag {
            background-color: var(--btn-bg);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
        }
        
        .gallery-favorite {
            cursor: pointer;
            transition: color 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .gallery-favorite:hover {
            color: var(--accent-color);
        }
        
        .gallery-favorite.active {
            color: var(--accent-color);
        }

        /* 작품 상세 페이지 */
        .artwork-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .artwork-title {
            font-family: var(--valorant-font);
            font-size: 1.8rem;
            color: var(--accent-color);
        }

        .artwork-preview {
            padding: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .artwork-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .artwork-section {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
        }

        .artwork-section-title {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-family: var(--valorant-font);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .artwork-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .share-form {
            margin-bottom: 20px;
        }

        .share-option {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .share-option input[type="radio"] {
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            .header, .page-header {
                padding: 0.5rem 1rem;
            }

            .toolbar {
                padding: 0.5rem;
                overflow-x: auto;
                justify-content: flex-start;
            }

            .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
                min-width: 30px;
            }

            .btn-icon svg {
                margin-right: 2px;
                width: 14px;
                height: 14px;
            }

            .tool-group {
                margin-right: 6px;
                gap: 4px;
            }

            .tool-label {
                display: none;
            }

            .gallery-layout {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            }
            
            .gallery-preview {
                height: 120px;
            }
            
            .user-profile {
                padding: 4px 8px;
            }
            
            .user-profile span {
                max-width: 80px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .main-content {
                padding: 0.5rem;
            }
            
            .emoji-cell {
                font-size: 1.2rem;
            }
            
            .canvas-container {
                max-width: 95%;
                max-height: 90%;
            }
            
            .modal-content {
                padding: 1rem;
                width: 95%;
                max-height: 80vh;
            }
            
            .btn-round {
                width: 28px;
                height: 28px;
            }

            .artwork-details {
                grid-template-columns: 1fr;
            }
        }

        /* 더 작은 화면 (모바일 작은 화면) */
        @media (max-width: 480px) {
            .gallery-layout {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
                gap: 10px;
            }
            
            .toolbar {
                flex-wrap: nowrap;
                overflow-x: auto;
                justify-content: flex-start;
                padding: 0.4rem;
                gap: 5px;
            }
            
            .btn-icon span {
                display: none;
            }
            
            .btn-icon svg {
                margin-right: 0;
            }
            
            .btn {
                padding: 0.3rem;
                min-width: 44px;
            }
            .auth-container {
            max-width: 100%;
            padding: 20px 15px;
            }
            .tool-group {
                margin-right: 3px;
                gap: 3px;
            }
            
            .logo {
                font-size: 1.5rem;
            }
            
            .header, .page-header {
                padding: 0.4rem 0.8rem;
            }
        }

        .shortcut {
            display: inline-block;
            background-color: var(--secondary-bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
            margin-left: 5px;
        }

        .brush-cursor {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            border: 2px solid var(--accent-color);
            transform: translate(-50%, -50%);
            z-index: 1000;
            transition: width 0.2s, height 0.2s;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 70, 85, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .d-flex {
            display: flex;
        }

        .align-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .g-10 {
            gap: 10px;
        }

        .mb-10 {
            margin-bottom: 10px;
        }

        .text-center {
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: var(--secondary-bg);
            color: var(--text-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--border-color);
            word-wrap: break-word;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 4px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            color: white;
            font-family: var(--valorant-font);
            letter-spacing: 1px;
            animation: toastIn 0.3s, toastOut 0.3s 2.7s forwards;
            max-width: 350px;
            transform-origin: right bottom;
            position: relative;
            overflow: hidden;
            background-color: rgba(15, 25, 35, 0.95);
            border-left: 4px solid #1e90ff;
        }
        
        .toast::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 4px;
        }

        .toast.success {
            border-left-color: #00c853;
        }
        
        .toast.success::before {
            background: #00c853;
        }

        .toast.error {
            border-left-color: #ff4655;
        }
        
        .toast.error::before {
            background: #ff4655;
        }

        .toast.info {
            border-left-color: #1e90ff;
        }
        
        .toast.info::before {
            background: #1e90ff;
        }

        @keyframes toastIn {
            from { 
                opacity: 0; 
                transform: translateX(20px) scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0) scale(1); 
            }
        }

        @keyframes toastOut {
            from { 
                opacity: 1; 
                transform: translateX(0) scale(1); 
            }
            to { 
                opacity: 0; 
                transform: translateX(20px) scale(0.8); 
            }
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--main-bg);
            transition: .4s;
            border-radius: 24px;
            border: 1px solid var(--border-color);
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --main-bg: #0f1923;
                --secondary-bg: #1a242d;
                --text-color: #ece8e1;
                /* 기존 다크 테마와 동일 */
            }
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 3px;
            background-color: var(--text-muted);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: white;
        }
        
        .favorite-btn {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .favorite-btn:hover {
            transform: scale(1.1);
            color: var(--accent-color);
        }
        
        .favorite-btn.active {
            color: var(--accent-color);
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .empty-state svg {
            margin-bottom: 15px;
            opacity: 0.7;
        }
        
        .empty-state-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .empty-state-text {
            font-size: 0.9rem;
            max-width: 300px;
            margin: 0 auto;
        }

        /* 개선된 토스트 메시지 스타일 */
        .toast {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            margin-bottom: 12px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: white;
            font-family: var(--valorant-font);
            letter-spacing: 1px;
            animation: toastIn 0.4s, toastOut 0.4s 3.6s forwards;
            max-width: 350px;
            transform-origin: right bottom;
            position: relative;
            overflow: hidden;
            background-color: rgba(15, 25, 35, 0.98);
        }

        .toast-icon {
            margin-right: 12px;
        }

        .toast-content {
            flex: 1;
        }

        /* 파일 저장/로드 개선 */
        .format-selector {
            display: flex;
            margin-bottom: 10px;
            gap: 10px;
        }

        .format-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--btn-bg);
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            background-color: var(--btn-hover);
        }

        .format-option.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        
        /* 경고 메시지 스타일 */
        .warning-box {
            background-color: rgba(255, 70, 85, 0.1);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 12px 16px;
            margin: 15px 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .warning-box svg {
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .warning-title {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        
        .checkbox-wrapper {
            margin-top: 10px;
            display: flex;
            align-items: center;
        }
        
        .checkbox-wrapper input {
            margin-right: 8px;
        }
        
        /* CAPTCHA 컨테이너 */
        .captcha-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* 사용자 메뉴 드롭다운 */
        .user-dropdown {
            position: relative;
        }
        
        .user-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            width: 200px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 50;
            display: none;
            overflow: hidden;
        }
        
        .user-dropdown-menu.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-dropdown-item {
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .user-dropdown-item:hover {
            background-color: var(--btn-hover);
        }
        
        .user-dropdown-item svg {
            width: 16px;
            height: 16px;
        }
        
        .user-dropdown-divider {
            height: 1px;
            background-color: var(--border-color);
            margin: 5px 0;
        }
        
        .delete-account-btn {
            color: var(--accent-color);
        }
        
        /* 캡차 버튼 커스텀 스타일 */
        .custom-captcha {
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }

        /* 탭 내비게이션 */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-bottom: none;
            margin-right: 5px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            transition: all 0.2s;
            font-family: var(--valorant-font);
        }
        
        .tab:hover {
            background-color: var(--btn-hover);
        }

        .tab.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        /* 검색 바 */
        .search-container {
            position: relative;
            max-width: 300px;
            margin-bottom: 20px;
        }

        .search-container svg {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .search-input {
            padding: 10px 10px 10px 35px;
            width: 100%;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            color: var(--text-color);
            border-radius: 4px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(255, 70, 85, 0.2);
        }

        /* 필터 드롭다운 */
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-button:hover {
            background-color: var(--btn-hover);
        }

        .filter-menu {
            position: absolute;
            top: 100%;
            right: 0;
            min-width: 180px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: none;
        }

        .filter-menu.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        .filter-item {
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .filter-item:hover {
            background-color: var(--btn-hover);
        }

        .filter-item.active {
            color: var(--accent-color);
        }

        /* 페이지네이션 */
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            gap: 5px;
        }

        .pagination-item {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination-item:hover {
            background-color: var(--btn-hover);
        }

        .pagination-item.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        /* 로그인/회원가입 스타일 */
        .auth-container {
            max-width: 400px;
            margin: 40px auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .auth-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            font-family: var(--valorant-font);
            transition: all 0.2s;
        }

        .auth-tab.active {
            color: var(--accent-color);
            border-bottom: 2px solid var(--accent-color);
        }

        .auth-form {
            margin-bottom: 20px;
        }

        .auth-form-footer {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .guest-button {
            margin-top: 10px;
            text-align: center;
        }

        /* 비회원 모드 배너 */
        .guest-mode-banner {
            background-color: rgba(255, 70, 85, 0.2);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: var(--valorant-font);
        }

        .guest-mode-text {
            font-size: 0.9rem;
        }

        /* 작품 상세 페이지 예쁜 스타일 */
        .artwork-container {
            max-width: 1000px;
            margin: 20px auto;
            background-color: var(--secondary-bg);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
        }

        .artwork-image {
            min-height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--main-bg);
            padding: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .artwork-meta {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .artwork-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        .artwork-info-section {
            background-color: var(--main-bg);
            border-radius: 4px;
            padding: 15px;
        }

        .artwork-info-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .artwork-info-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .artwork-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px;
        }

        .artwork-action {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <h1 class="valorant-text" style="color: var(--accent-color); font-size: 3rem; margin-bottom: 20px;">VALPAINT</h1>
            <div class="spinner" style="width: 50px; height: 50px; margin-bottom: 20px;"></div>
            <p>로딩 중...</p>
        </div>
    </div>

    <!-- 인증 모달 (로그인/회원가입) -->
    <!-- 인증 모달 (로그인만 제공) -->
    <div id="auth-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT에 오신 것을 환영합니다!</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <!-- 로그인 폼 -->
                <form id="login-form" class="auth-form">
                    <div class="form-group">
                        <label class="form-label" for="loginUsername">작가명</label>
                        <input type="text" class="form-control" id="loginUsername" placeholder="작가명을 입력하세요" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">비밀번호</label>
                        <input type="password" class="form-control" id="loginPassword" placeholder="비밀번호를 입력하세요" autocomplete="current-password" required>
                    </div>
                    <button type="submit" class="btn btn-accent" style="width: 100%;">로그인</button>
                </form>
                
                <div class="warning-box" style="margin-top: 20px;">
                    <div class="warning-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        <span>회원가입 안내</span>
                    </div>
                    <p>계정이 없으신가요? VALPAINT는 보안 강화를 위해 디스코드 봇을 통한 회원가입만 지원합니다.</p>
                    <p style="margin-top: 10px;">회원가입, 비밀번호 변경, 계정 삭제는 디스코드 서버에서 진행해주세요.</p>
                    <a href="https://discord.gg/zRyQf8qtv3" class="btn btn-accent" style="width: 100%; margin-top: 15px;" target="_blank">디스코드 서버 참여하기</a>
                </div>
                
                <div class="guest-button">
                    <button id="guest-mode-btn" class="btn">비회원으로 계속하기</button>
                </div>
            </div>
        </div>
    </div>
    <div class="container">
        <!-- 헤더 -->
        <header class="header">
            <a href="#" class="logo valorant-text">VALPAINT</a>
            <div class="d-flex align-center g-10">
                <!-- 비회원 모드 배너 -->
                <div id="guest-mode-banner" class="guest-mode-banner" style="display: none;">
                    <div class="guest-mode-text">비회원 모드 - 갤러리와 공유 기능이 제한됩니다</div>
                    <button id="guest-login-btn" class="btn btn-accent">로그인</button>
                </div>
                
                <div class="user-dropdown">
                    <div class="user-profile" id="userProfileBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                        <span id="userDisplayName">작가명</span>
                    </div>
                    <div class="user-dropdown-menu" id="userDropdownMenu">
                        <div class="user-dropdown-item" id="userSettingsBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                            <span>계정 설정</span>
                        </div>
                        <div class="user-dropdown-divider"></div>
                        <div class="user-dropdown-item delete-account-btn" id="deleteAccountBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                            <span>계정 삭제</span>
                        </div>
                    </div>
                </div>
                <button id="galleryBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                        <polyline points="9 22 9 12 15 12 15 22"></polyline>
                    </svg>
                    <span class="valorant-text">갤러리</span>
                </button>
                <button id="settingsBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    <span class="valorant-text">설정</span>
                </button>
                <button id="helpBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    <span class="valorant-text">도움말</span>
                </button>
            </div>
        </header>

        <!-- 도구바 -->
        <div class="toolbar">
            <div class="tool-group">
                <span class="tool-label">도구:</span>
                <button id="drawEraseBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                        <path d="M2 2l7.586 7.586"></path>
                        <circle cx="11" cy="11" r="2"></circle>
                    </svg>
                    <span class="valorant-text">그리기</span>
                    <span class="tooltip-text">단축키: Q</span>
                </button>
                <button id="clearBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="10" x2="16" y2="10"></line>
                        <line x1="8" y1="14" x2="16" y2="14"></line>
                    </svg>
                    <span class="valorant-text">지우기</span>
                    <span class="tooltip-text">단축키: Delete</span>
                </button>
            </div>

            <div class="tool-group" id="brushSizeGroup">
                <span class="tool-label">브러시:</span>
                <button id="brushSizeDownBtn" class="btn btn-round tooltip">
                    -
                    <span class="tooltip-text">단축키: -</span>
                </button>
                <span id="brushSizeDisplay" class="tool-label">1</span>
                <button id="brushSizeUpBtn" class="btn btn-round tooltip">
                    +
                    <span class="tooltip-text">단축키: +</span>
                </button>
            </div>

            <div class="tool-group">
                <button id="saveBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    <span class="valorant-text">저장</span>
                    <span class="tooltip-text">단축키: Ctrl+S</span>
                </button>
                <button id="loadBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span class="valorant-text">불러오기</span>
                    <span class="tooltip-text">단축키: Ctrl+O</span>
                </button>
                <button id="exportImportBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 17l5-5-5-5"></path>
                        <path d="M8 7l-5 5 5 5"></path>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    <span class="valorant-text">내보내기/가져오기</span>
                    <span class="tooltip-text">단축키: Ctrl+E</span>
                </button>
                <button id="copyBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span class="valorant-text">복사</span>
                    <span class="tooltip-text">단축키: Ctrl+C</span>
                </button>
                <button id="shareBtn" class="btn btn-icon btn-accent">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                    <span class="valorant-text">온라인 공유</span>
                </button>
            </div>
        </div>

        <!-- 메인 콘텐츠 영역 -->
        <div class="main-content">
            <div class="canvas-container">
                <div id="drawingCanvas" class="drawing-canvas"></div>
            </div>
        </div>
    </div>

    <!-- 계정 설정 모달 -->
    <div id="userSettingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">계정 설정</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="account-settings-form">
                    <div class="form-group">
                        <label class="form-label">작가명</label>
                        <input type="text" class="form-control" id="accountUsername" placeholder="작가명 입력" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">현재 비밀번호</label>
                        <input type="password" class="form-control" id="accountCurrentPassword" placeholder="현재 비밀번호 입력" autocomplete="current-password" required>

                    </div>
                    <div class="form-group">
                        <label class="form-label">새 비밀번호 (선택사항)</label>
                        <input type="password" class="form-control" id="accountNewPassword" placeholder="변경을 원하시면 입력하세요" autocomplete="new-password">

                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="accountCancelBtn" class="btn">취소</button>
                <button id="accountSaveBtn" class="btn btn-accent">저장</button>
            </div>
        </div>
    </div>

    <!-- 계정 삭제 모달 -->
    <div id="deleteAccountModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">계정 삭제</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="warning-box">
                    <div class="warning-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        <span>주의: 이 작업은 되돌릴 수 없습니다</span>
                    </div>
                    <p>계정을 삭제하면 다음 항목이 영구적으로 삭제됩니다:</p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li>모든 온라인 공유 작품</li>
                        <li>로컬 저장 데이터 (즐겨찾기, 설정 등)</li>
                        <li>계정 정보</li>
                    </ul>
                </div>
                
                <form id="delete-account-form" style="margin-top: 20px;">
                    <div class="form-group">
                        <label class="form-label">비밀번호 확인</label>
                        <input type="password" class="form-control" id="deleteConfirmPassword" placeholder="계정 삭제를 위해 비밀번호를 입력하세요" autocomplete="current-password" required>

                    </div>
                    
                    <div class="checkbox-wrapper" style="margin-top: 15px;">
                        <input type="checkbox" id="deleteConfirmCheck" required>
                        <label for="deleteConfirmCheck">모든 내용을 영구적으로 삭제하는 것을 이해하고 동의합니다</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="deleteCancelBtn" class="btn">취소</button>
                <button id="deleteConfirmBtn" class="btn btn-accent" style="background-color: var(--accent-color); color: white; opacity: 0.5;" disabled>계정 삭제</button>
            </div>
        </div>
    </div>

    <!-- 설정 모달 -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT 설정</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="app-settings-form">
                    <div class="form-group">
                        <label class="form-label">셀 크기</label>
                        <input type="range" class="form-range" id="cellSizeRange" min="20" max="100" value="40">
                        <div class="d-flex justify-between">
                            <span>작게</span>
                            <span id="cellSizeValue">40px</span>
                            <span>크게</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">브러시 크기 (성능 최적화: 작은 값 권장)</label>
                        <input type="range" class="form-range" id="brushSizeRange" min="1" max="3" value="1">
                        <div class="d-flex justify-between">
                            <span>1</span>
                            <span id="brushSizeValue">1</span>
                            <span>3</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="d-flex align-center justify-between">
                            <label class="form-label">이모지 모드 배경</label>
                            <label class="switch">
                                <input type="checkbox" id="bgModeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="d-flex justify-between">
                            <span>사각형</span>
                            <span>투명</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="d-flex align-center justify-between">
                            <label class="form-label">커스텀 이모지</label>
                            <label class="switch">
                                <input type="checkbox" id="customModeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div id="customEmojiSettings" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">색칠된 이모지</label>
                            <input type="text" class="form-control" id="filledEmojiInput" maxlength="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">색칠 안 된 이모지</label>
                            <input type="text" class="form-control" id="emptyEmojiInput" maxlength="1">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="settingsCancelBtn" class="btn"><span class="valorant-text">취소</span></button>
                <button id="settingsSaveBtn" class="btn btn-accent"><span class="valorant-text">저장</span></button>
            </div>
        </div>
    </div>

    <!-- 파일 관리 모달 -->
    <div id="fileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="fileModalTitle">파일 저장</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="file-form">
                    <div id="saveFormGroup" class="form-group">
                        <label class="form-label">파일 이름</label>
                        <input type="text" class="form-control" id="fileNameInput" placeholder="파일 이름 입력">
                    </div>
                </form>
                <div id="fileListGroup">
                    <label class="form-label">파일 목록</label>
                    <div class="file-list" id="fileList"></div>
                    <div class="file-preview" id="filePreview"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="fileModalCancelBtn" class="btn">취소</button>
                <button id="fileDeleteBtn" class="btn" style="display: none;">삭제</button>
                <button id="fileExportBtn" class="btn" style="display: none;">내보내기</button>
                <button id="fileActionBtn" class="btn btn-accent">저장</button>
            </div>
        </div>
    </div>
    
    <!-- 파일 내보내기/가져오기 모달 -->
    <div id="exportImportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text" id="exportImportTitle">파일 내보내기/가져오기</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="action-buttons" style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button id="exportBtn" class="btn btn-accent" style="flex: 1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <span class="valorant-text">내보내기</span>
                    </button>
                    <button id="importBtn" class="btn btn-accent" style="flex: 1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        <span class="valorant-text">가져오기</span>
                    </button>
                </div>
                
                <form id="import-form">
                    <div id="importFileInput" style="display: none;" class="form-group">
                        <label class="form-label">VAL 파일 선택</label>
                        <input type="file" class="form-control" id="fileInput" accept=".val">
                        <p style="margin-top: 10px; color: var(--text-muted);">* .val 확장자 파일만 지원합니다.</p>
                    </div>
                </form>
                
                <form id="export-form">
                    <div id="exportFileNameGroup" style="display: none;" class="form-group">
                        <label class="form-label">내보낼 파일 이름</label>
                        <input type="text" class="form-control" id="exportFileName" placeholder="파일 이름 입력">
                    </div>
                </form>
                
                <div id="filePreviewContainer" class="form-group" style="display: none; margin-top: 20px;">
                    <label class="form-label">미리보기</label>
                    <div id="importPreview" class="file-preview"></div>
                </div>
                
                <div id="fileAuthorInfo" class="form-group" style="margin-top: 20px;">
                    <div class="info-box" style="background-color: var(--main-bg); border: 1px solid var(--border-color); padding: 10px; border-radius: 4px;">
                        <p><strong>제작자:</strong> <span id="fileAuthorText"></span></p>
                        <p><strong>버전:</strong> <span id="fileVersionText"></span></p>
                    </div>
                </div>
                
                <div id="importConfirm" class="warning-box" style="display: none; margin-top: 15px;">
                    <div class="warning-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        <span>주의</span>
                    </div>
                    <p>이 파일을 불러오면 현재 작업중인 내용이 모두 삭제됩니다. 계속하시겠습니까?</p>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="importConfirmCheck">
                        <label for="importConfirmCheck">이해했으며 진행합니다</label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="exportImportCancelBtn" class="btn">취소</button>
                <button id="executeExportImportBtn" class="btn btn-accent" style="display: none;">실행</button>
            </div>
        </div>
    </div>

    <!-- 공유 모달 -->
    <div id="shareModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">온라인 공유</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="share-form">
                    <div class="form-group">
                        <label class="form-label">공유 제목</label>
                        <input type="text" class="form-control" id="shareTitleInput" placeholder="작품의 제목을 입력하세요" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">태그 (쉼표로 구분)</label>
                        <input type="text" class="form-control" id="shareTagsInput" placeholder="예: 풍경,동물,아트">
                    </div>
                    <div class="form-group">
                        <label class="form-label">설명 (선택사항)</label>
                        <textarea class="form-control" id="shareDescInput" rows="3" placeholder="작품에 대한 설명을 입력하세요"></textarea>
                    </div>
                    <div id="sharePreview" class="file-preview text-center">
                        <!-- 미리보기 내용 -->
                    </div>
                    
                    <!-- CAPTCHA 추가 -->
                    <div class="captcha-container">
                        <label class="form-label">보안 확인 (필수)</label>
                        <div class="custom-captcha">
                            <div id="captcha-container" class="g-recaptcha" data-sitekey="6LdwwxUrAAAAAHUGUYODxLEWGmaKKEw5VvpC87NZ"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="shareModalCancelBtn" class="btn">취소</button
                <button id="shareActionBtn" class="btn btn-accent">공유하기</button>
            </div>
        </div>
    </div>

    <!-- 도움말 모달 -->
    <div id="helpModal" class="modal">
        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT 도움말</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">VALPAINT 시작하기</h4>
                <p style="margin-bottom: 15px;">VALPAINT는 이모지를 활용한 간편한 그림판입니다. 쉽고 재미있게 픽셀 아트를 만들고 온라인으로 공유해보세요!</p>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">기본 사용법</h4>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li>캔버스의 셀을 클릭하면 그림을 그릴 수 있어요</li>
                    <li>그리기/지우기 버튼으로 모드를 전환할 수 있어요</li>
                    <li>브러시 크기를 조절하여 한 번에 여러 셀을 그릴 수 있어요</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">단축키 모음</h4>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li><strong>Q</strong>: 그리기/지우기 모드 전환</li>
                    <li><strong>+/-</strong>: 브러시 크기 조절</li>
                    <li><strong>Delete</strong>: 모든 내용 지우기</li>
                    <li><strong>Ctrl+S</strong>: 작품 저장하기</li>
                    <li><strong>Ctrl+O</strong>: 작품 불러오기</li>
                    <li><strong>Ctrl+C</strong>: 작품 복사하기</li>
                    <li><strong>Ctrl+E</strong>: 내보내기/가져오기</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">파일 저장 및 불러오기</h4>
                <p style="margin-bottom: 10px;"><strong>VAL</strong> 형식으로 작품을 저장하고 불러올 수 있습니다:</p>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li><strong>저장</strong>: 로컬 스토리지에 작품을 저장합니다</li>
                    <li><strong>불러오기</strong>: 저장된 작품을 불러옵니다</li>
                    <li><strong>내보내기</strong>: 작품을 VAL 파일로 다운로드합니다</li>
                    <li><strong>가져오기</strong>: VAL 파일을 업로드하여 가져옵니다</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">온라인 공유</h4>
                <p style="margin-bottom: 10px;">작품을 만들고 온라인으로 공유하면 다른 사람들이 볼 수 있어요!</p>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li>"온라인 공유" 버튼을 클릭하여 작품 정보를 입력하세요</li>
                    <li>공유된 작품은 "갤러리"에서 확인할 수 있어요</li>
                    <li>최대 10개까지 작품을 공유할 수 있어요</li>
                    <li>마음에 드는 작품은 즐겨찾기로 등록해보세요</li>
                    <li>온라인 공유는 CAPTCHA 인증이 필요합니다</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">설정 옵션</h4>
                <ul style="padding-left: 20px;">
                    <li><strong>셀 크기</strong>: 캔버스 셀의 크기를 조절합니다</li>
                    <li><strong>브러시 크기</strong>: 한 번에 그릴 셀의 수를 조절합니다 (성능 최적화를 위해 작은 값 권장)</li>
                    <li><strong>이모지 모드 배경</strong>: 배경을 사각형 또는 투명으로 설정합니다</li>
                    <li><strong>커스텀 이모지</strong>: 그리기에 사용할 이모지를 직접 설정합니다</li>
                </ul>
                
                <h4 style="color: var(--accent-color); margin-bottom: 10px; margin-top: 15px; font-family: var(--valorant-font);">계정 관리</h4>
                <ul style="padding-left: 20px;">
                    <li><strong>계정 설정</strong>: 작가명과 비밀번호를 변경할 수 있습니다</li>
                    <li><strong>계정 삭제</strong>: 계정과 모든 온라인 작품을 삭제합니다</li>
                    <li><strong>비회원 모드</strong>: 로그인 없이 그림을 그릴 수 있지만 온라인 갤러리와 공유 기능은 제한됩니다</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button id="shortcutsBtn" class="btn"><span class="valorant-text">단축키 보기</span></button>
                <button id="helpCloseBtn" class="btn btn-accent"><span class="valorant-text">확인</span></button>
            </div>
        </div>
    </div>

    <!-- 단축키 모달 -->
    <div id="shortcutsModal" class="modal">
        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">단축키 목록</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">기능</th>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">단축키</th>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">저장</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+S</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">불러오기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+O</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">복사</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+C</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">그리기/지우기 전환</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Q</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">브러시 크기 증가</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">+</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">브러시 크기 감소</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">-</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">전체 지우기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Delete</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">도움말</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">F1</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">설정</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">F2</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">내보내기/가져오기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+E</span></td>
                    </tr>
                </table>
            </div>
            <div class="modal-footer">
                <button id="shortcutsCloseBtn" class="btn btn-accent"><span class="valorant-text">확인</span></button>
            </div>
        </div>
    </div>

    <!-- 갤러리 페이지 -->
    <div id="galleryPage" class="page">
        <div class="page-header">
            <div class="back-button" id="galleryBackBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                <span class="valorant-text">돌아가기</span>
            </div>
            <h1 class="page-title valorant-text">VALPAINT 갤러리</h1>
            <div></div>
        </div>
        <div class="page-container">
            <div class="tabs">
                <div class="tab active" data-tab="my">내 작품</div>
                <div class="tab" data-tab="public">공개 작품</div>
                <div class="tab" data-tab="favorites">즐겨찾기</div>
            </div>
            
            <div class="d-flex justify-between align-center mb-10">
                <div class="search-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input type="text" class="search-input" id="searchInput" placeholder="검색어 입력...">
                </div>
                
                <div class="filter-dropdown">
                    <div class="filter-button" id="filterBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
                        </svg>
                        <span>필터</span>
                    </div>
                    <div class="filter-menu" id="filterMenu">
                        <div class="filter-item active" data-filter="latest">최신순</div>
                        <div class="filter-item" data-filter="oldest">오래된순</div>
                        <div class="filter-item" data-filter="popular">인기순</div>
                    </div>
                </div>
                
                <button id="refreshGalleryBtn" class="btn valorant-text">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M23 4v6h-6"></path>
                        <path d="M1 20v-6h6"></path>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                        <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
                    </svg>
                    새로고침
                </button>
            </div>
            
            <div id="galleryContent" class="gallery-layout">
                <!-- 갤러리 내용이 동적으로 로드됩니다 -->
                <div class="text-center" style="grid-column: 1 / -1;">
                    <div class="spinner"></div>
                    <p>작품을 불러오는 중...</p>
                </div>
            </div>
            
            <div class="pagination" id="galleryPagination">
                <!-- 페이지네이션은 동적으로 생성됩니다 -->
            </div>
        </div>
    </div>

    <!-- 작품 상세 페이지 -->
    <div id="artworkPage" class="page">
        <div class="page-header">
            <div class="back-button" id="artworkBackBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                <span class="valorant-text">갤러리로</span>
            </div>
            <h1 class="page-title valorant-text" id="artworkPageTitle">작품 상세</h1>
            <div></div>
        </div>
        
        <div class="artwork-container">
            <div class="artwork-image" id="artworkPreview">
                <!-- 작품 미리보기가 여기에 표시됩니다 -->
            </div>
            
            <div class="artwork-meta">
                <h2 id="artworkTitle" class="artwork-title valorant-text">작품 제목</h2>
                <p class="artwork-creator" id="artworkCreator">작가: 작가명</p>
                <div id="artworkTags" class="gallery-tags"></div>
            </div>
            
            <div class="artwork-info">
                <div class="artwork-info-section">
                    <h3 class="artwork-info-title">작품 정보</h3>
                    <div class="artwork-info-content">
                        <p><strong>업로드 일자:</strong> <span id="artworkDate">2023-01-01</span></p>
                        <p><strong>조회수:</strong> <span id="artworkViews">0</span></p>
                    </div>
                </div>
                
                <div class="artwork-info-section">
                    <h3 class="artwork-info-title">작품 설명</h3>
                    <div class="artwork-info-content" id="artworkDesc">
                        작품에 대한 설명이 여기에 표시됩니다.
                    </div>
                </div>
            </div>
            
            <div class="artwork-buttons">
                <button id="favoriteArtworkBtn" class="btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                    </svg>
                    즐겨찾기
                </button>
                <button id="downloadArtworkBtn" class="btn artwork-action">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    다운로드
                </button>
                <button id="loadArtworkBtn" class="btn btn-accent artwork-action">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    불러오기
                </button>
            </div>
        </div>
    </div>

    <!-- 토스트 알림 컨테이너 -->
    <div id="toast-container"></div>
    <div id="brushCursor" class="brush-cursor"></div>

    <!-- Valpaint JavaScript -->
    <script>
// Supabase 클라이언트 초기화 (실제 배포 시에는 환경변수나 설정 파일로 분리하는 것을 권장)
const SUPABASE_URL = 'https://xesqcwzstgkmvgokfrqx.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhlc3Fjd3pzdGdrbXZnb2tmcnF4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ0MjI0MjgsImV4cCI6MjA1OTk5ODQyOH0.W7yL0YxaQ1O_eaeRfntYQFdnmyafixKsQy_diDzxttc';
let supabase = null;

// 상수 및 환경 설정
const CONFIG = {
    APP_VERSION: '2.2.1', // 버전 업데이트
    MAX_ARTWORK_PER_USER: 10,
    DEFAULT_CELL_SIZE: 40,
    MAX_BRUSH_SIZE: 3,
    MIN_BRUSH_SIZE: 1,
    DEFAULT_GRID_ROWS: 13,
    DEFAULT_GRID_COLS: 26,
    DEBOUNCE_DELAY: 5, // ms
    TOAST_DURATION: 4000, // ms
    SECURITY: {
        HASH_SALT_PREFIX: 'valpaint-secure-',
        CRYPT_ITERATIONS: 10000, // SHA-256 iterations 증가
        SESSION_DURATION: 7 * 24 * 60 * 60 * 1000, // 1 week in ms
        ALLOWED_DOMAINS: ['localhost', '127.0.0.1', 'valpaint.art', 'www.valpaint.art'], // 허용된 도메인 목록
        JWT_SECRET: 'Vc9VxtaP3Lf7HbJ5KmNqRs8TzWyXuE2D', // JWT 토큰 서명용 비밀키 (실제로는 환경변수에서 로드해야 함)
        CSRF_TOKEN_EXPIRY: 60 * 60 * 1000, // 1 hour in ms
        RATE_LIMIT: {
            LOGIN_ATTEMPTS: 5, // 최대 로그인 시도 횟수
            LOGIN_LOCKOUT: 15 * 60 * 1000, // 15 minutes in ms
            API_REQUESTS: 100, // 시간당 최대 API 요청 수
            API_WINDOW: 60 * 60 * 1000 // 1 hour in ms
        }
    },
    STORAGE_KEYS: {
        PREFIX: 'valpaint_',
        USERNAME: 'valpaint_username',
        USER_ID: 'valpaint_user_id',
        AUTH_TOKEN: 'valpaint_auth_token',
        AUTH_EXPIRY: 'valpaint_auth_expiry',
        FAVORITES: 'valpaint_favorites',
        SETTINGS: 'valpaint_settings',
        TERMS_ACCEPTED: 'valpaint_terms_accepted',
        CSRF_TOKEN: 'valpaint_csrf_token',
        CSRF_EXPIRY: 'valpaint_csrf_expiry'
    }
};

// 설정 및 상태 관리
const settings = {
    cellSize: CONFIG.DEFAULT_CELL_SIZE,
    brushSize: 1,
    bgMode: 'rectangle',
    emojiRows: CONFIG.DEFAULT_GRID_ROWS,
    emojiCols: CONFIG.DEFAULT_GRID_COLS,
    customMode: false,
    filledEmoji: '■',
    emptyEmoji: '□',
    transparentChar: 'ㅤ',
    author: '',
    version: CONFIG.APP_VERSION
};

// 애플리케이션 상태
const appState = {
    isEraserMode: false,
    isDragging: false,
    lastCellPosition: null,
    showBrushCursor: true,
    userName: '',
    userId: '',
    lastMousePosition: { x: 0, y: 0 },
    favorites: [],
    artworkCache: {},
    debounceTimer: null,
    termsAccepted: false,
    isAuthenticated: false,
    isGuestMode: false,
    authToken: null,
    authExpiry: null,
    currentPage: 'home', // home, gallery, artwork
    currentTab: 'my', // my, public, favorites (gallery tabs)
    currentFilter: 'latest', // latest, oldest, popular
    currentArtwork: null, // 현재 보고 있는 작품 정보
    pageParams: {
        page: 1,
        pageSize: 12,
        totalPages: 1
    },
    secureDomainValidated: false, // 도메인 유효성 검사 상태
    csrfToken: null, // CSRF 토큰
    csrfExpiry: null, // CSRF 토큰 만료 시간
    rateLimits: { // 속도 제한 상태
        loginAttempts: 0,
        loginLockoutUntil: 0,
        apiRequests: 0,
        apiWindowStart: 0
    },
    security: {
        initialized: false
    }
};

// DOM 요소 참조
const elements = {
    // 기본 UI 요소
    drawingCanvas: document.getElementById('drawingCanvas'),
    userDisplayName: document.getElementById('userDisplayName'),
    
    // 버튼 및 컨트롤
    drawEraseBtn: document.getElementById('drawEraseBtn'),
    clearBtn: document.getElementById('clearBtn'),
    brushSizeDisplay: document.getElementById('brushSizeDisplay'),
    brushSizeDownBtn: document.getElementById('brushSizeDownBtn'),
    brushSizeUpBtn: document.getElementById('brushSizeUpBtn'),
    saveBtn: document.getElementById('saveBtn'),
    loadBtn: document.getElementById('loadBtn'),
    copyBtn: document.getElementById('copyBtn'),
    shareBtn: document.getElementById('shareBtn'),
    settingsBtn: document.getElementById('settingsBtn'),
    helpBtn: document.getElementById('helpBtn'),
    galleryBtn: document.getElementById('galleryBtn'),
    exportImportBtn: document.getElementById('exportImportBtn'),
    logoutBtn: document.getElementById('logoutBtn'), // 추가된 로그아웃 버튼
    
    // 브러시 커서
    brushCursor: document.getElementById('brushCursor'),
    
    // 모달 요소
    authModal: document.getElementById('auth-modal'),
    fileModal: document.getElementById('fileModal'),
    exportImportModal: document.getElementById('exportImportModal'),
    shareModal: document.getElementById('shareModal'),
    settingsModal: document.getElementById('settingsModal'),
    helpModal: document.getElementById('helpModal'),
    shortcutsModal: document.getElementById('shortcutsModal'),
    userSettingsModal: document.getElementById('userSettingsModal'),
    deleteAccountModal: document.getElementById('deleteAccountModal'),
    
    // 페이지 요소
    galleryPage: document.getElementById('galleryPage'),
    artworkPage: document.getElementById('artworkPage'),
    
    // 인증 요소
    loginForm: document.getElementById('login-form'),
    loginUsername: document.getElementById('loginUsername'),
    loginPassword: document.getElementById('loginPassword'),
    guestModeBtn: document.getElementById('guest-mode-btn'),
    guestModeBanner: document.getElementById('guest-mode-banner'),
    guestLoginBtn: document.getElementById('guest-login-btn'),
    
    // 사용자 프로필
    userProfileBtn: document.getElementById('userProfileBtn'),
    userDropdownMenu: document.getElementById('userDropdownMenu'),
    userSettingsBtn: document.getElementById('userSettingsBtn'),
    deleteAccountBtn: document.getElementById('deleteAccountBtn'),
    
    // 계정 설정 요소
    accountSettingsForm: document.getElementById('account-settings-form'),
    accountUsername: document.getElementById('accountUsername'),
    accountCurrentPassword: document.getElementById('accountCurrentPassword'),
    accountNewPassword: document.getElementById('accountNewPassword'),
    accountCancelBtn: document.getElementById('accountCancelBtn'),
    accountSaveBtn: document.getElementById('accountSaveBtn'),
    
    // 계정 삭제 요소
    deleteAccountForm: document.getElementById('delete-account-form'),
    deleteConfirmPassword: document.getElementById('deleteConfirmPassword'),
    deleteConfirmCheck: document.getElementById('deleteConfirmCheck'),
    deleteCancelBtn: document.getElementById('deleteCancelBtn'),
    deleteConfirmBtn: document.getElementById('deleteConfirmBtn'),
    deleteHiddenUsername: document.getElementById('deleteHiddenUsername'),
    
    // 파일 관리 요소
    fileForm: document.getElementById('file-form'),
    fileModalTitle: document.getElementById('fileModalTitle'),
    fileNameInput: document.getElementById('fileNameInput'),
    fileList: document.getElementById('fileList'),
    filePreview: document.getElementById('filePreview'),
    saveFormGroup: document.getElementById('saveFormGroup'),
    fileListGroup: document.getElementById('fileListGroup'),
    fileModalCancelBtn: document.getElementById('fileModalCancelBtn'),
    fileDeleteBtn: document.getElementById('fileDeleteBtn'),
    fileExportBtn: document.getElementById('fileExportBtn'),
    fileActionBtn: document.getElementById('fileActionBtn'),
    
    // 내보내기/가져오기 요소
    exportImportTitle: document.getElementById('exportImportTitle'),
    exportBtn: document.getElementById('exportBtn'),
    importBtn: document.getElementById('importBtn'),
    importFileInput: document.getElementById('importFileInput'),
    exportFileNameGroup: document.getElementById('exportFileNameGroup'),
    exportFileName: document.getElementById('exportFileName'),
    exportImportCancelBtn: document.getElementById('exportImportCancelBtn'),
    executeExportImportBtn: document.getElementById('executeExportImportBtn'),
    filePreviewContainer: document.getElementById('filePreviewContainer'),
    importPreview: document.getElementById('importPreview'),
    importConfirm: document.getElementById('importConfirm'),
    importConfirmCheck: document.getElementById('importConfirmCheck'),
    fileInput: document.getElementById('fileInput'),
    fileAuthorText: document.getElementById('fileAuthorText'),
    fileVersionText: document.getElementById('fileVersionText'),
    
    // 공유 모달 요소
    shareForm: document.getElementById('share-form'),
    shareTitleInput: document.getElementById('shareTitleInput'),
    shareTagsInput: document.getElementById('shareTagsInput'),
    shareDescInput: document.getElementById('shareDescInput'),
    sharePreview: document.getElementById('sharePreview'),
    shareModalCancelBtn: document.getElementById('shareModalCancelBtn'),
    shareActionBtn: document.getElementById('shareActionBtn'),
    
    // 설정 요소
    appSettingsForm: document.getElementById('app-settings-form'),
    cellSizeRange: document.getElementById('cellSizeRange'),
    cellSizeValue: document.getElementById('cellSizeValue'),
    brushSizeRange: document.getElementById('brushSizeRange'),
    brushSizeValue: document.getElementById('brushSizeValue'),
    bgModeSwitch: document.getElementById('bgModeSwitch'),
    customModeSwitch: document.getElementById('customModeSwitch'),
    customEmojiSettings: document.getElementById('customEmojiSettings'),
    filledEmojiInput: document.getElementById('filledEmojiInput'),
    emptyEmojiInput: document.getElementById('emptyEmojiInput'),
    settingsCancelBtn: document.getElementById('settingsCancelBtn'),
    settingsSaveBtn: document.getElementById('settingsSaveBtn'),
    
    // 도움말 및 단축키 요소
    helpCloseBtn: document.getElementById('helpCloseBtn'),
    shortcutsBtn: document.getElementById('shortcutsBtn'),
    shortcutsCloseBtn: document.getElementById('shortcutsCloseBtn'),
    
    // 갤러리 페이지 요소
    galleryBackBtn: document.getElementById('galleryBackBtn'),
    galleryTabs: document.querySelectorAll('#galleryPage .tab'),
    searchInput: document.getElementById('searchInput'),
    filterBtn: document.getElementById('filterBtn'),
    filterMenu: document.getElementById('filterMenu'),
    filterItems: document.querySelectorAll('#filterMenu .filter-item'),
    refreshGalleryBtn: document.getElementById('refreshGalleryBtn'),
    galleryContent: document.getElementById('galleryContent'),
    galleryPagination: document.getElementById('galleryPagination'),
    
    // 작품 상세 페이지 요소
    artworkBackBtn: document.getElementById('artworkBackBtn'),
    artworkPageTitle: document.getElementById('artworkPageTitle'),
    artworkTitle: document.getElementById('artworkTitle'),
    artworkCreator: document.getElementById('artworkCreator'),
    artworkPreview: document.getElementById('artworkPreview'),
    artworkDate: document.getElementById('artworkDate'),
    artworkViews: document.getElementById('artworkViews'),
    artworkTags: document.getElementById('artworkTags'),
    artworkDesc: document.getElementById('artworkDesc'),
    favoriteArtworkBtn: document.getElementById('favoriteArtworkBtn'),
    downloadArtworkBtn: document.getElementById('downloadArtworkBtn'),
    loadArtworkBtn: document.getElementById('loadArtworkBtn'),
    
    // 로딩 화면
    loadingScreen: document.getElementById('loading-screen')
};

// 캔버스 렌더러 객체 - 그림 그리기 기능 관리
const canvasRenderer = {
    canvas: null,
    gridRows: CONFIG.DEFAULT_GRID_ROWS,
    gridCols: CONFIG.DEFAULT_GRID_COLS,
    cells: [],
    cellSize: CONFIG.DEFAULT_CELL_SIZE,
    currentData: [],
    
    // 캔버스 초기화
    initCanvas() {
        this.canvas = elements.drawingCanvas;
        if (!this.canvas) {
            utils.showToast('캔버스 요소를 찾을 수 없습니다', 'error');
            return false;
        }
        
        // 그리드 생성
        this.createGrid();
        
        // 이벤트 리스너 등록
        this.setupCanvasEvents();
        
        return true;
    },
    
    // 그리드 생성
    createGrid() {
        if (!this.canvas) return;
        
        // 기존 그리드 정리
        this.canvas.innerHTML = '';
        this.cells = [];
        
        // 설정 적용
        this.gridRows = settings.emojiRows || CONFIG.DEFAULT_GRID_ROWS;
        this.gridCols = settings.emojiCols || CONFIG.DEFAULT_GRID_COLS;
        this.cellSize = settings.cellSize || CONFIG.DEFAULT_CELL_SIZE;
        
        // 그리드 스타일 설정
        this.canvas.style.gridTemplateRows = `repeat(${this.gridRows}, ${this.cellSize}px)`;
        this.canvas.style.gridTemplateColumns = `repeat(${this.gridCols}, ${this.cellSize}px)`;
        
        // 초기 데이터 배열 생성
        this.currentData = Array(this.gridRows).fill(0).map(() => Array(this.gridCols).fill(0));
        
        // 셀 생성
        for (let row = 0; row < this.gridRows; row++) {
            for (let col = 0; col < this.gridCols; col++) {
                const cell = document.createElement('div');
                cell.className = 'emoji-cell';
                
                // 배경 모드 설정
                if (settings.bgMode === 'transparent') {
                    cell.classList.add('transparent');
                }
                
                // 커스텀 모드 이모지 설정
                if (settings.customMode) {
                    cell.textContent = settings.emptyEmoji || '□';
                } else {
                    cell.textContent = '□';
                }
                
                // 데이터 속성 설정
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                // 셀 클릭 이벤트
                cell.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // 드래그 시작 시 선택 방지
                    this.handleCellEvent(row, col);
                    appState.isDragging = true;
                    appState.lastCellPosition = { row, col };
                });
                
                // 마우스 진입 이벤트 (드래그 중일 때)
                cell.addEventListener('mouseenter', () => {
                    if (appState.isDragging) {
                        // 이전에 방문한 셀과 같은 셀인지 확인
                        if (appState.lastCellPosition && 
                            (appState.lastCellPosition.row !== row || 
                             appState.lastCellPosition.col !== col)) {
                            this.handleCellEvent(row, col);
                            appState.lastCellPosition = { row, col };
                        }
                    }
                });
                
                // 터치 이벤트 (모바일 지원)
                cell.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleCellEvent(row, col);
                    appState.isDragging = true;
                    appState.lastCellPosition = { row, col };
                }, { passive: false });
                
                cell.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (appState.isDragging) {
                        const touch = e.touches[0];
                        const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                        
                        if (elementUnderTouch && elementUnderTouch.classList.contains('emoji-cell')) {
                            const touchRow = parseInt(elementUnderTouch.dataset.row);
                            const touchCol = parseInt(elementUnderTouch.dataset.col);
                            
                            if (appState.lastCellPosition && 
                                (appState.lastCellPosition.row !== touchRow || 
                                 appState.lastCellPosition.col !== touchCol)) {
                                this.handleCellEvent(touchRow, touchCol);
                                appState.lastCellPosition = { row: touchRow, col: touchCol };
                            }
                        }
                    }
                }, { passive: false });
                
                // 강화된 접근성
                cell.setAttribute('role', 'button');
                cell.setAttribute('aria-label', `그리드 셀 ${row+1}행 ${col+1}열`);
                cell.setAttribute('tabindex', '0');
                
                // 키보드 접근성 이벤트
                cell.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.handleCellEvent(row, col);
                    }
                });
                
                this.canvas.appendChild(cell);
                this.cells.push(cell);
            }
        }
        
        // XSS 방지를 위한 innerHTML 정리
        this.sanitizeCanvas();
    },
    
    // 캔버스 이벤트 설정
    setupCanvasEvents() {
        // 마우스 업 이벤트 (드래그 종료)
        document.addEventListener('mouseup', () => {
            appState.isDragging = false;
            appState.lastCellPosition = null;
        });
        
        // 터치 종료 이벤트
        document.addEventListener('touchend', () => {
            appState.isDragging = false;
            appState.lastCellPosition = null;
        });
        
        // 캔버스 영역 벗어날 때 드래그 종료
        this.canvas.addEventListener('mouseleave', () => {
            appState.isDragging = false;
            appState.lastCellPosition = null;
        });
        
        // 브러시 커서 위치 업데이트
        document.addEventListener('mousemove', (e) => {
            if (appState.showBrushCursor && elements.brushCursor) {
                const x = e.clientX;
                const y = e.clientY;
                
                appState.lastMousePosition = { x, y };
                this.updateBrushCursor(x, y);
            }
        });
    },
    
    // 브러시 크기에 따른 이벤트 처리
    handleCellEvent(row, col) {
        const brushSize = settings.brushSize || 1;
        
        // 브러시 크기에 따라 주변 셀도 함께 처리
        for (let r = -Math.floor(brushSize / 2); r <= Math.floor(brushSize / 2); r++) {
            for (let c = -Math.floor(brushSize / 2); c <= Math.floor(brushSize / 2); c++) {
                const targetRow = row + r;
                const targetCol = col + c;
                
                // 유효한 범위 확인
                if (targetRow >= 0 && targetRow < this.gridRows && 
                    targetCol >= 0 && targetCol < this.gridCols) {
                    this.toggleCell(targetRow, targetCol);
                }
            }
        }
    },
    
    // 셀 상태 토글
    toggleCell(row, col) {
        const index = row * this.gridCols + col;
        const cell = this.cells[index];
        
        if (!cell) return;
        
        // 현재 상태 가져오기
        const isActive = cell.classList.contains('active');
        
        // 지우개 모드면 항상 비활성화, 그리기 모드면 항상 활성화
        const newState = appState.isEraserMode ? false : !isActive;
        
        // 상태 업데이트
        if (newState) {
            cell.classList.add('active');
            
            if (settings.customMode) {
                cell.textContent = settings.filledEmoji || '■';
            } else {
                cell.textContent = '■';
            }
            
            this.currentData[row][col] = 1;
        } else {
            cell.classList.remove('active');
            
            if (settings.customMode) {
                cell.textContent = settings.emptyEmoji || '□';
            } else {
                cell.textContent = '□';
            }
            
            this.currentData[row][col] = 0;
        }
    },
    
    // 브러시 커서 업데이트
    updateBrushCursor(x, y) {
        if (!elements.brushCursor) return;
        
        const brushSize = settings.brushSize || 1;
        const cursorSize = this.cellSize * brushSize;
        
        elements.brushCursor.style.width = `${cursorSize}px`;
        elements.brushCursor.style.height = `${cursorSize}px`;
        elements.brushCursor.style.left = `${x}px`;
        elements.brushCursor.style.top = `${y}px`;
    },
    
    // 모든 셀 지우기
    clearCanvas() {
        if (!this.cells.length) return;
        
        this.cells.forEach(cell => {
            cell.classList.remove('active');
            
            if (settings.customMode) {
                cell.textContent = settings.emptyEmoji || '□';
            } else {
                cell.textContent = '□';
            }
        });
        
        // 데이터 초기화
        this.currentData = Array(this.gridRows).fill(0).map(() => Array(this.gridCols).fill(0));
        
        utils.showToast('모든 셀이 지워졌습니다', 'info');
    },
    
    // 보드 데이터 불러오기
    loadBoardData(data) {
        if (!data || !data.board || !Array.isArray(data.board)) {
            utils.showToast('유효하지 않은 데이터 형식입니다', 'error');
            return false;
        }
        
        // 보드 크기 확인 및 조정
        const rows = data.board.length;
        const cols = rows > 0 ? data.board[0].length : 0;
        
        if (rows !== this.gridRows || cols !== this.gridCols) {
            // 그리드 크기가 다른 경우, 설정 업데이트
            settings.emojiRows = rows;
            settings.emojiCols = cols;
            this.gridRows = rows;
            this.gridCols = cols;
            
            // 그리드 재생성
            this.createGrid();
        }
        
        // 데이터 로드
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (row < this.gridRows && col < this.gridCols) {
                    const cellValue = data.board[row][col];
                    const index = row * this.gridCols + col;
                    const cell = this.cells[index];
                    
                    if (cell) {
                        if (cellValue === 1) {
                            cell.classList.add('active');
                            
                            if (settings.customMode) {
                                cell.textContent = settings.filledEmoji || '■';
                            } else {
                                cell.textContent = '■';
                            }
                        } else {
                            cell.classList.remove('active');
                            
                            if (settings.customMode) {
                                cell.textContent = settings.emptyEmoji || '□';
                            } else {
                                cell.textContent = '□';
                            }
                        }
                        
                        this.currentData[row][col] = cellValue;
                    }
                }
            }
        }
        
        return true;
    },
    
    // 현재 보드 데이터 가져오기
    getBoardData() {
        return {
            board: this.currentData,
            meta: {
                rows: this.gridRows,
                cols: this.gridCols,
                cellSize: this.cellSize,
                bgMode: settings.bgMode,
                customMode: settings.customMode,
                filledEmoji: settings.filledEmoji,
                emptyEmoji: settings.emptyEmoji
            }
        };
    },
    
    // ASCii 아트로 변환하기
    getBoardAsAscii() {
        let ascii = '';
        
        for (let row = 0; row < this.gridRows; row++) {
            let line = '';
            for (let col = 0; col < this.gridCols; col++) {
                if (this.currentData[row][col] === 1) {
                    line += settings.customMode ? settings.filledEmoji : '■';
                } else {
                    line += settings.customMode ? settings.emptyEmoji : '□';
                }
            }
            ascii += line + '\n';
        }
        
        return ascii;
    },
    
    // XSS 방지를 위한 캔버스 정리
    sanitizeCanvas() {
        this.cells.forEach(cell => {
            // 텍스트 콘텐츠만 허용하고 HTML 태그 방지
            const sanitizedText = cell.textContent;
            cell.textContent = sanitizedText;
        });
    },
    
    // 작품 미리보기 생성
    createPreview(containerId, data) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        
        container.innerHTML = '';
        
        if (!data || !data.board || !Array.isArray(data.board)) {
            container.textContent = '미리보기를 생성할 수 없습니다';
            return null;
        }
        
        const previewGrid = document.createElement('div');
        previewGrid.className = 'drawing-canvas';
        previewGrid.style.gridTemplateRows = `repeat(${data.board.length}, 15px)`;
        previewGrid.style.gridTemplateColumns = `repeat(${data.board[0].length}, 15px)`;
        
        for (let row = 0; row < data.board.length; row++) {
            for (let col = 0; col < data.board[0].length; col++) {
                const cell = document.createElement('div');
                cell.className = 'emoji-cell';
                
                if (data.meta && data.meta.bgMode === 'transparent') {
                    cell.classList.add('transparent');
                }
                
                if (data.board[row][col] === 1) {
                    cell.classList.add('active');
                    
                    if (data.meta && data.meta.customMode) {
                        cell.textContent = data.meta.filledEmoji || '■';
                    } else {
                        cell.textContent = '■';
                    }
                } else {
                    if (data.meta && data.meta.customMode) {
                        cell.textContent = data.meta.emptyEmoji || '□';
                    } else {
                        cell.textContent = '□';
                    }
                }
                
                previewGrid.appendChild(cell);
            }
        }
        
        // 미리보기 정리
        utils.sanitizeElement(previewGrid);
        
        container.appendChild(previewGrid);
        return previewGrid;
    }
};

// 유틸리티 함수 모음
const utils = {
    // DOM 요소 확인
    validateElement: function(element, name) {
        if (!element) {
            console.error(`요소 "${name}"을(를) 찾을 수 없습니다.`);
            return false;
        }
        return true;
    },
    
    // 모달 표시/숨기기
    showModal: function(modal) {
        if (!this.validateElement(modal, 'modal')) return;
        
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.classList.add('show');
        }, 10);
    },
    
    hideModal: function(modal) {
        if (!this.validateElement(modal, 'modal')) return;
        
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    },
    
    // 토스트 알림 표시 
    showToast: function(message, type = 'info', duration = CONFIG.TOAST_DURATION) {
        if (!message) return;
        
        // HTML 이스케이프
        message = this.escapeHtml(message);
        
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.position = 'fixed';
            toastContainer.style.top = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '9999';
            toastContainer.style.display = 'flex';
            toastContainer.style.flexDirection = 'column';
            toastContainer.style.gap = '10px';
            document.body.appendChild(toastContainer);
        }
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.style.display = 'flex';
        toast.style.alignItems = 'center';
        toast.style.padding = '12px 16px';
        toast.style.background = 'var(--secondary-bg)';
        toast.style.borderLeft = `4px solid ${type === 'error' ? 'var(--accent-color)' : type === 'success' ? '#00c853' : type === 'warning' ? '#ffc107' : '#1e90ff'}`;
        toast.style.borderRadius = '4px';
        toast.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
        toast.style.transform = 'translateX(100%)';
        toast.style.opacity = '0';
        toast.style.transition = 'all 0.3s ease';
        
        // 아이콘 추가
        let iconSvg = '';
        switch(type) {
            case 'success':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#00c853" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`;
                break;
            case 'error':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ff4655" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
                break;
            case 'warning':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ffc107" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`;
                break;
            case 'info':
            default:
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#1e90ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`;
                break;
        }
        
        const iconWrapper = document.createElement('div');
        iconWrapper.className = 'toast-icon';
        iconWrapper.style.marginRight = '12px';
        iconWrapper.innerHTML = this.sanitizeHtml(iconSvg);
        
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'toast-content';
        contentWrapper.textContent = message;
        contentWrapper.style.flex = '1';
        contentWrapper.style.fontSize = '14px';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close';
        closeBtn.textContent = '×';
        closeBtn.style.background = 'none';
        closeBtn.style.border = 'none';
        closeBtn.style.color = 'var(--text-muted)';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.marginLeft = '8px';
        closeBtn.style.padding = '0 4px';
        
        toast.appendChild(iconWrapper);
        toast.appendChild(contentWrapper);
        toast.appendChild(closeBtn);
        
        // 접근성 향상
        toast.setAttribute('role', 'alert');
        toast.setAttribute('aria-live', 'assertive');
        
        // 닫기 버튼 이벤트
        closeBtn.addEventListener('click', () => {
            toast.style.transform = 'translateX(100%)';
            toast.style.opacity = '0';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        });
        
        toastContainer.appendChild(toast);
        
        // 애니메이션 적용 (추가 후 약간 딜레이)
        setTimeout(() => {
            toast.style.transform = 'translateX(0)';
            toast.style.opacity = '1';
        }, 10);
        
        // 자동 닫힘
        const toastTimeout = setTimeout(() => {
            if (toast.parentNode) {
                toast.style.transform = 'translateX(100%)';
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }, duration);
        
        // 마우스 오버 시 자동 닫힘 일시 중지
        toast.addEventListener('mouseenter', () => {
            clearTimeout(toastTimeout);
        });
        
        // 마우스 아웃 시 자동 닫힘 재개
        toast.addEventListener('mouseleave', () => {
            const newTimeout = setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    toast.style.opacity = '0';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }, duration / 2);
            
            toast.dataset.timeout = newTimeout;
        });
    },
    
    // HTML 이스케이프
    escapeHtml: function(unsafe) {
        if (typeof unsafe !== 'string') {
            return unsafe;
        }
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    },
    
    // HTML 문자열 샌드박스 처리 (허용된 태그만 통과)
    sanitizeHtml: function(html) {
        if (typeof html !== 'string') {
            return '';
        }
        
        // 허용된 HTML 태그 및 속성 지정
        const allowedTags = {
            'svg': ['xmlns', 'width', 'height', 'viewBox', 'fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'],
            'path': ['d', 'fill'],
            'circle': ['cx', 'cy', 'r', 'fill'],
            'line': ['x1', 'y1', 'x2', 'y2'],
            'polyline': ['points'],
            'a': ['href', 'target', 'rel'],
            'span': ['class', 'style'],
            'div': ['class', 'style'],
            'p': ['class', 'style'],
            'br': []
        };
        
        // 간단한 HTML 파서
        const temp = document.createElement('div');
        temp.innerHTML = html;
        
        // 재귀적으로 노드 정리
        function sanitizeNode(node) {
            if (node.nodeType === 3) { // 텍스트 노드
                return;
            }
            
            if (node.nodeType === 1) { // 요소 노드
                const tagName = node.tagName.toLowerCase();
                
                // 허용되지 않은 태그 제거
                if (!allowedTags[tagName]) {
                    node.parentNode.removeChild(node);
                    return;
                }
                
                // 허용된 속성만 유지
                const allowedAttrs = allowedTags[tagName];
                const attributes = [...node.attributes];
                attributes.forEach(attr => {
                    if (!allowedAttrs.includes(attr.name)) {
                        node.removeAttribute(attr.name);
                    }
                    
                    // href 속성 검사 (JavaScript 코드 방지)
                    if (attr.name === 'href' && attr.value.toLowerCase().startsWith('javascript:')) {
                        node.removeAttribute(attr.name);
                    }
                });
                
                // 자식 노드도 정리
                [...node.childNodes].forEach(sanitizeNode);
            }
        }
        
        // 모든 노드 정리
        [...temp.childNodes].forEach(sanitizeNode);
        
        return temp.innerHTML;
    },
    
    // 요소 내용 정리 (XSS 방지)
    sanitizeElement: function(element) {
        if (!element || !element.innerHTML) {
            return;
        }
        
        element.innerHTML = this.sanitizeHtml(element.innerHTML);
    },
    
    // 디바운스 함수
    debounce: function(func, wait) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    },
    
    // 날짜 형식화
    formatDate: function(dateString) {
        if (!dateString) return '날짜 없음';
        
        try {
            const date = new Date(dateString);
            return date.toLocaleString('ko-KR', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (error) {
            console.error('날짜 형식화 오류:', error);
            return dateString;
        }
    },
    
    // 도메인 검증
    validateDomain: function() {
        // 개발 환경에서는 무시
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            appState.secureDomainValidated = true;
            return true;
        }
        
        // 허용된 도메인 목록 확인
        const isValidDomain = CONFIG.SECURITY.ALLOWED_DOMAINS.includes(window.location.hostname);
        
        if (!isValidDomain) {
            // 유효하지 않은 도메인에서 실행 방지
            document.body.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; height: 100vh; flex-direction: column; background-color: #0f1923; color: #ece8e1; font-family: Arial, sans-serif;">
                    <div style="background-color: #1a242d; padding: 2rem; border-radius: 8px; text-align: center; max-width: 500px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);">
                        <h1 style="color: #ff4655; margin-bottom: 1rem;">보안 경고</h1>
                        <p style="margin-bottom: 1rem;">이 애플리케이션은 신뢰할 수 있는 도메인에서만 실행할 수 있습니다.</p>
                        <p>공식 사이트로 이동하세요: <a href="https://valpaint.art" style="color: #ff4655; text-decoration: none;">https://valpaint.art</a></p>
                    </div>
                </div>
            `;
            console.error('보안 경고: 허용되지 않은 도메인에서 실행 시도');
            return false;
        }
        
        // 프로토콜 검증 (HTTPS 강제)
        if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
            // HTTPS로 리디렉션
            window.location.href = 'https://' + window.location.hostname + window.location.pathname + window.location.search;
            return false;
        }
        
        appState.secureDomainValidated = true;
        return true;
    },
    
    // 브라우저 보안 기능 설정
    setupBrowserSecurity: function() {
        // Content Security Policy 헤더 시뮬레이션 (실제로는 서버에서 설정해야 함)
        const meta = document.createElement('meta');
        meta.httpEquiv = 'Content-Security-Policy';
        meta.content = "default-src 'self'; script-src 'self' https://cdn.jsdelivr.net https://www.google.com https://www.gstatic.com; style-src 'self' 'unsafe-inline' https://fonts.cdnfonts.com; font-src 'self' https://fonts.cdnfonts.com; img-src 'self' data:; connect-src 'self' https://xesqcwzstgkmvgokfrqx.supabase.co; frame-src 'self' https://www.google.com;";
        document.head.appendChild(meta);
        
        // X-Frame-Options 헤더 시뮬레이션 (iframe 내 로드 방지)
        const frameOptions = document.createElement('meta');
        frameOptions.httpEquiv = 'X-Frame-Options';
        frameOptions.content = 'DENY';
        document.head.appendChild(frameOptions);
        
        // X-XSS-Protection 헤더 시뮬레이션
        const xssProtection = document.createElement('meta');
        xssProtection.httpEquiv = 'X-XSS-Protection';
        xssProtection.content = '1; mode=block';
        document.head.appendChild(xssProtection);
        
        // Referrer Policy 설정
        const referrerPolicy = document.createElement('meta');
        referrerPolicy.name = 'referrer';
        referrerPolicy.content = 'strict-origin-when-cross-origin';
        document.head.appendChild(referrerPolicy);
        
        // SameSite 쿠키 속성 시뮬레이션
        document.cookie = 'SameSite=Strict; Secure';
    },
    
    // JWT 토큰 생성 (클라이언트 측 시뮬레이션용, 실제로는 서버에서 생성해야 함)
    generateJWTToken: function(userId, username) {
        try {
            // JWT 헤더 (Base64URL 인코딩)
            const header = {
                alg: 'HS256',
                typ: 'JWT'
            };
            
            // 현재 시간 (초 단위)
            const now = Math.floor(Date.now() / 1000);
            
            // JWT 페이로드 (Base64URL 인코딩)
            const payload = {
                sub: userId,
                name: username,
                iat: now,
                exp: now + (7 * 24 * 60 * 60) // 7일 후 만료
            };
            
            // Base64URL 인코딩 함수
            function base64UrlEncode(obj) {
                return btoa(JSON.stringify(obj))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }
            
            // 헤더와 페이로드 인코딩
            const encodedHeader = base64UrlEncode(header);
            const encodedPayload = base64UrlEncode(payload);
            
            // 시뮬레이션된 서명 (실제로는 서버에서 생성해야 함)
            const signatureInput = `${encodedHeader}.${encodedPayload}`;
            const signature = this.simulateHMACSHA256(signatureInput, CONFIG.SECURITY.JWT_SECRET);
            
            // JWT 토큰 조합
            const token = `${encodedHeader}.${encodedPayload}.${signature}`;
            
            return token;
        } catch (error) {
            console.error('JWT 토큰 생성 오류:', error);
            return null;
        }
    },
    
    // SHA-256 해시 시뮬레이션 (Web Crypto API가 있다면 사용)
    async simulateHMACSHA256(data, key) {
        try {
            // Web Crypto API 지원 확인
            if (window.crypto && window.crypto.subtle) {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(key);
                const cryptoKey = await window.crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );
                
                const signature = await window.crypto.subtle.sign(
                    'HMAC',
                    cryptoKey,
                    encoder.encode(data)
                );
                
                // ArrayBuffer를 Base64URL로 변환
                return btoa(String.fromCharCode(...new Uint8Array(signature)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            } else {
                // 간단한 해시 폴백 (실제 환경에서는 사용하지 말 것)
                let hash = '';
                const combined = data + key;
                
                for (let i = 0; i < combined.length; i++) {
                    hash += ((combined.charCodeAt(i) ^ 0x7F) * 7 % 256).toString(16).padStart(2, '0');
                }
                
                // 비밀번호 해시와 구분하기 위해 추가 처리
                return btoa(hash)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');
            }
        } catch (error) {
            console.error('HMAC 시뮬레이션 오류:', error);
            
            // 최후의 폴백 (실제 환경에서는 사용하지 말 것)
            let hash = '';
            const combined = data + key;
            
            for (let i = 0; i < 32; i++) {
                hash += ((combined.charCodeAt(i % combined.length) ^ 0x7F) * 11 % 256).toString(16).padStart(2, '0');
            }
            
            return hash;
        }
    },
    
    // CSRF 토큰 생성
    generateCSRFToken: function() {
        try {
            const array = new Uint8Array(32); // 256 비트 보안
            crypto.getRandomValues(array);
            const token = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
            
            // 토큰 저장
            const expiry = Date.now() + CONFIG.SECURITY.CSRF_TOKEN_EXPIRY;
            localStorage.setItem(CONFIG.STORAGE_KEYS.CSRF_TOKEN, token);
            localStorage.setItem(CONFIG.STORAGE_KEYS.CSRF_EXPIRY, expiry.toString());
            
            appState.csrfToken = token;
            appState.csrfExpiry = expiry;
            
            return token;
        } catch (error) {
            console.error('CSRF 토큰 생성 오류:', error);
            
            // 폴백 방식 (덜 안전)
            const token = Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
            const expiry = Date.now() + CONFIG.SECURITY.CSRF_TOKEN_EXPIRY;
            
            localStorage.setItem(CONFIG.STORAGE_KEYS.CSRF_TOKEN, token);
            localStorage.setItem(CONFIG.STORAGE_KEYS.CSRF_EXPIRY, expiry.toString());
            
            appState.csrfToken = token;
            appState.csrfExpiry = expiry;
            
            return token;
        }
    },
    
    // CSRF 토큰 검증
    validateCSRFToken: function(token) {
        if (!token) return false;
        
        const storedToken = localStorage.getItem(CONFIG.STORAGE_KEYS.CSRF_TOKEN);
        const expiry = parseInt(localStorage.getItem(CONFIG.STORAGE_KEYS.CSRF_EXPIRY) || '0');
        
        if (!storedToken || expiry < Date.now()) {
            return false;
        }
        
        return token === storedToken;
    },
    
    // 현재 세션이 유효한지 확인
    isSessionValid: function() {
        const session = this.storage.getSessionData();
        return !!session && session.expiry > Date.now();
    },
    
    // 속도 제한 검사
    checkRateLimit: function(type) {
        try {
            const now = Date.now();
            
            switch (type) {
                case 'login':
                    // 로그인 시도 제한
                    if (appState.rateLimits.loginLockoutUntil > now) {
                        // 계정 잠금 기간 중
                        const remainingMinutes = Math.ceil((appState.rateLimits.loginLockoutUntil - now) / 60000);
                        return {
                            allowed: false,
                            message: `너무 많은 로그인 시도가 있었습니다. ${remainingMinutes}분 후에 다시 시도해주세요.`
                        };
                    }
                    
                    // 로그인 시도 횟수 증가
                    appState.rateLimits.loginAttempts++;
                    
                    // 제한 초과 확인
                    if (appState.rateLimits.loginAttempts > CONFIG.SECURITY.RATE_LIMIT.LOGIN_ATTEMPTS) {
                        // 계정 잠금 설정
                        appState.rateLimits.loginLockoutUntil = now + CONFIG.SECURITY.RATE_LIMIT.LOGIN_LOCKOUT;
                        appState.rateLimits.loginAttempts = 0;
                        
                        return {
                            allowed: false,
                            message: `너무 많은 로그인 시도가 있었습니다. 15분 후에 다시 시도해주세요.`
                        };
                    }
                    
                    return { allowed: true };
                    
                case 'api':
                    // API 요청 제한 확인
                    if (appState.rateLimits.apiWindowStart === 0 || 
                        (now - appState.rateLimits.apiWindowStart) > CONFIG.SECURITY.RATE_LIMIT.API_WINDOW) {
                        // 새 창 시작
                        appState.rateLimits.apiWindowStart = now;
                        appState.rateLimits.apiRequests = 1;
                        return { allowed: true };
                    }
                    
                    // 기존 창 내 요청 증가
                    appState.rateLimits.apiRequests++;
                    
                    // 제한 초과 확인
                    if (appState.rateLimits.apiRequests > CONFIG.SECURITY.RATE_LIMIT.API_REQUESTS) {
                        return {
                            allowed: false,
                            message: '너무 많은 요청이 있었습니다. 잠시 후 다시 시도해주세요.'
                        };
                    }
                    
                    return { allowed: true };
                    
                default:
                    return { allowed: true };
            }
        } catch (error) {
            console.error('속도 제한 검사 오류:', error);
            return { allowed: true }; // 오류 발생 시 차단하지 않음
        }
    },
    
    // 로컬 스토리지 유틸리티
    storage: {
        // 키 생성 헬퍼
        getKey: function(key) {
            return CONFIG.STORAGE_KEYS.PREFIX + key;
        },
        
        // 파일 저장
        saveFile: function(fileName, data) {
            try {
                if (!fileName || !data) {
                    return false;
                }
                
                // 파일 이름 검증
                const sanitizedFileName = utils.sanitizeFileName(fileName);
                if (!sanitizedFileName) {
                    utils.showToast('유효하지 않은 파일 이름입니다', 'error');
                    return false;
                }
                
                // 저장 전 데이터 검증
                if (typeof data !== 'object') {
                    utils.showToast('유효하지 않은 데이터 형식입니다', 'error');
                    return false;
                }
                
                // 데이터 추가 정보
                data.lastModified = new Date().toISOString();
                data.version = CONFIG.APP_VERSION;
                
                // VAL 확장자 확인
                const finalFileName = sanitizedFileName.endsWith('.val') ? 
                    sanitizedFileName : sanitizedFileName + '.val';
                
                localStorage.setItem(this.getKey(finalFileName), JSON.stringify(data));
                return true;
            } catch (error) {
                console.error('파일 저장 오류:', error);
                utils.showToast('파일 저장 중 오류가 발생했습니다', 'error');
                return false;
            }
        },
        
        // 파일 불러오기
        loadFile: function(fileName) {
            try {
                if (!fileName) {
                    return null;
                }
                
                const data = localStorage.getItem(this.getKey(fileName));
                if (!data) {
                    return null;
                }
                
                // JSON 파싱 및 유효성 검사
                try {
                    const parsedData = JSON.parse(data);
                    
                    // 기본 구조 유효성 검사
                    if (!parsedData || typeof parsedData !== 'object') {
                        throw new Error('유효하지 않은 데이터 형식');
                    }
                    
                    return parsedData;
                } catch (parseError) {
                    console.error('파일 파싱 오류:', parseError);
                    utils.showToast('파일 형식이 올바르지 않습니다', 'error');
                    return null;
                }
            } catch (error) {
                console.error('파일 로드 오류:', error);
                utils.showToast('파일 로드 중 오류가 발생했습니다', 'error');
                return null;
            }
        },
        
        // 파일 삭제
        deleteFile: function(fileName) {
            try {
                if (!fileName) {
                    return false;
                }
                
                localStorage.removeItem(this.getKey(fileName));
                return true;
            } catch (error) {
                console.error('파일 삭제 오류:', error);
                utils.showToast('파일 삭제 중 오류가 발생했습니다', 'error');
                return false;
            }
        },
        
        // 파일 목록 가져오기
        getFileList: function() {
            const files = [];
            try {
                const prefix = CONFIG.STORAGE_KEYS.PREFIX;
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(prefix) && key.endsWith('.val')) {
                        files.push(key.substring(prefix.length));
                    }
                }
                
                // 최신 파일 순으로 정렬
                files.sort((a, b) => {
                    const aData = this.loadFile(a);
                    const bData = this.loadFile(b);
                    
                    if (!aData || !aData.lastModified) return 1;
                    if (!bData || !bData.lastModified) return -1;
                    
                    return new Date(bData.lastModified) - new Date(aData.lastModified);
                });
                
                return files;
            } catch (error) {
                console.error('파일 목록 오류:', error);
                return [];
            }
        },
        
        // 설정 저장
        saveSettings: function(settings) {
            try {
                if (!settings || typeof settings !== 'object') {
                    return false;
                }
                
                localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
                return true;
            } catch (error) {
                console.error('설정 저장 오류:', error);
                return false;
            }
        },
        
        // 설정 불러오기
        loadSettings: function() {
            try {
                const data = localStorage.getItem(CONFIG.STORAGE_KEYS.SETTINGS);
                if (!data) {
                    return null;
                }
                
                // JSON 파싱 및 유효성 검사
                try {
                    const parsedSettings = JSON.parse(data);
                    
                    // 설정 유효성 검사
                    if (!parsedSettings || typeof parsedSettings !== 'object') {
                        throw new Error('유효하지 않은 설정 형식');
                    }
                    
                    return parsedSettings;
                } catch (parseError) {
                    console.error('설정 파싱 오류:', parseError);
                    return null;
                }
            } catch (error) {
                console.error('설정 로드 오류:', error);
                return null;
            }
        },
        
        // 모든 데이터 삭제
        clearAll: function() {
            try {
                // valpaint_ 로 시작하는 모든 항목 삭제
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CONFIG.STORAGE_KEYS.PREFIX)) {
                        keysToRemove.push(key);
                    }
                }
                
                keysToRemove.forEach(key => localStorage.removeItem(key));
                return true;
            } catch (error) {
                console.error('데이터 삭제 오류:', error);
                return false;
            }
        },
        
        // 세션 저장
        saveSessionData: function(token, userId, expiry) {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN, token);
                localStorage.setItem(CONFIG.STORAGE_KEYS.USER_ID, userId);
                localStorage.setItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY, expiry.toString());
                return true;
            } catch (error) {
                console.error('세션 저장 오류:', error);
                return false;
            }
        },
        
        // 세션 가져오기
        getSessionData: function() {
            try {
                const token = localStorage.getItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN);
                const userId = localStorage.getItem(CONFIG.STORAGE_KEYS.USER_ID);
                const expiry = parseInt(localStorage.getItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY) || '0');
                
                // 세션 만료 확인
                if (!token || !userId || !expiry || expiry < Date.now()) {
                    return null;
                }
                
                return { token, userId, expiry };
            } catch (error) {
                console.error('세션 가져오기 오류:', error);
                return null;
            }
        },
        
        // 세션 삭제
        clearSession: function() {
            try {
                localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN);
                localStorage.removeItem(CONFIG.STORAGE_KEYS.USER_ID);
                localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY);
                return true;
            } catch (error) {
                console.error('세션 삭제 오류:', error);
                return false;
            }
        }
    },
    
    // 파일 이름 유효성 검사 및 정제
    sanitizeFileName: function(fileName) {
        if (!fileName || typeof fileName !== 'string' || fileName.trim() === '') {
            return '';
        }
        
        // 파일 이름에서 위험한 문자 제거
        const sanitized = fileName.trim()
            .replace(/[^a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ_\-\.]/g, '')
            .substring(0, 50); // 길이 제한
        
        // 경로 주입 공격 방지
        if (sanitized.includes('..') || sanitized.includes('/') || sanitized.includes('\\')) {
            return '';
        }
        
        return sanitized;
    },
    
    // 텍스트 유효성 검사 및 정제
    sanitizeText: function(text, maxLength = 500) {
        if (!text || typeof text !== 'string') {
            return '';
        }
        
        // XSS 방지 처리
        const sanitized = text.trim()
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;')
            .substring(0, maxLength);
        
        return sanitized;
    },
    
    // 사용자 이름 유효성 검사
    validateUsername: function(username) {
        if (!username || typeof username !== 'string') {
            return { valid: false, message: '사용자 이름을 입력해주세요.' };
        }
        
        // 길이 및 문자 제한
        if (username.length < 2 || username.length > 20) {
            return { valid: false, message: '사용자 이름은 2-20자 사이여야 합니다.' };
        }
        
        // 허용되는 문자 검사
        const validUsernameRegex = /^[a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ_\-]+$/;
        if (!validUsernameRegex.test(username)) {
            return { valid: false, message: '사용자 이름에는 문자, 숫자, 한글, 밑줄 및 하이픈만 사용할 수 있습니다.' };
        }
        
        // SQL 인젝션 키워드 검사
        const sqlKeywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'ALTER', 'EXEC', 'UNION'];
        const upperUsername = username.toUpperCase();
        
        for (const keyword of sqlKeywords) {
            if (upperUsername.includes(keyword)) {
                return { valid: false, message: '사용자 이름에 허용되지 않는 키워드가 포함되어 있습니다.' };
            }
        }
        
        return { valid: true, message: '' };
    },
    
    // 비밀번호 유효성 검사
    validatePassword: function(password) {
        if (!password || typeof password !== 'string') {
            return { valid: false, message: '비밀번호를 입력해주세요.' };
        }
        
        // 길이 제한
        if (password.length < 6) {
            return { valid: false, message: '비밀번호는 최소 6자 이상이어야 합니다.' };
        }
        
        // 향상된 비밀번호 검증 (실제 환경에서 더 강화할 수 있음)
        if (!/[a-z]/.test(password) || !/[A-Z0-9!@#$%^&*(),.?":{}|<>]/.test(password)) {
            return { 
                valid: false, 
                message: '비밀번호는 최소 하나의 소문자와 대문자, 숫자 또는 특수문자를 포함해야 합니다.' 
            };
        }
        
        return { valid: true, message: '' };
    },
    
    // 객체의 깊은 복사 수행
    deepClone: function(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        
        // 날짜 객체 처리
        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }
        
        // 배열 처리
        if (Array.isArray(obj)) {
            return obj.map(item => this.deepClone(item));
        }
        
        // 객체 처리
        const clonedObj = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                clonedObj[key] = this.deepClone(obj[key]);
            }
        }
        
        return clonedObj;
    },
    
    // 앱 로그 (개발용)
    log: function(message, type = 'info') {
        const isProduction = window.location.hostname !== 'localhost' && 
                           window.location.hostname !== '127.0.0.1';
        
        // 프로덕션 환경에서는 로그 제한
        if (isProduction && type === 'debug') {
            return;
        }
        
        const timestamp = new Date().toLocaleTimeString();
        const prefix = `[Valpaint ${type.toUpperCase()}] ${timestamp}:`;
        
        switch (type) {
            case 'error':
                console.error(prefix, message);
                break;
            case 'warn':
                console.warn(prefix, message);
                break;
            case 'debug':
                console.debug(prefix, message);
                break;
            default:
                console.log(prefix, message);
        }
    },
    
    // VALORANT 폰트 적용
    applyValorantFont: function() {
        // 폰트 로드 상태 확인
        const fontCheck = () => {
            if (document.fonts && document.fonts.check) {
                return document.fonts.check('12px VALORANT');
            }
            return false;
        };
        
        // 폰트가 이미 로드되었는지 확인
        if (fontCheck()) {
            return;
        }
        
        // 폰트 스타일시트 로드
        const fontLink = document.querySelector('link[href*="valorant"]');
        if (fontLink) {
            fontLink.media = 'all';
        }
        
        // 폰트 로드 이벤트 리스너
        document.fonts.ready.then(() => {
            const valorantElements = document.querySelectorAll('.valorant-text');
            valorantElements.forEach(el => {
                el.style.opacity = '1';
            });
        });
    }
};

// API 서비스
const api = {
    // 토큰 관리
    authToken: null,
    
    // 초기화
    async init() {
        try {
            // Supabase 클라이언트 초기화
            if (!supabase) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            }
            
            // 세션 데이터 복원
            const session = utils.storage.getSessionData();
            if (session && session.token && session.userId && session.expiry > Date.now()) {
                appState.authToken = session.token;
                appState.userId = session.userId;
                appState.isAuthenticated = true;
                
                // 사용자 정보 로드
                await this.loadUserInfo();
                
                // 즐겨찾기 로드
                await this.loadFavorites();
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('API 초기화 오류:', error);
            return false;
        }
    },
    
    // 사용자 정보 로드
    async loadUserInfo() {
        try {
            if (!appState.userId || !appState.isAuthenticated) {
                return false;
            }
            
            // Supabase에서 사용자 정보 조회
            const { data, error } = await supabase
                .from('users')
                .select('username')
                .eq('id', appState.userId)
                .single();
            
            if (error) throw error;
            
            if (data && data.username) {
                appState.userName = data.username;
                
                // 로컬 스토리지 업데이트
                localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, data.username);
                
                // 설정에 작가명 저장
                settings.author = data.username;
                utils.storage.saveSettings(settings);
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('사용자 정보 로드 오류:', error);
            return false;
        }
    },
    
    // 인증 상태 확인
    isAuthenticated() {
        return appState.isAuthenticated && 
               appState.userId && 
               utils.isSessionValid();
    },
    
    // 사용자명 가져오기
    getUsername() {
        return appState.userName || localStorage.getItem(CONFIG.STORAGE_KEYS.USERNAME) || '';
    },
    
    // 사용자 ID 가져오기
    getUserId() {
        return appState.userId || localStorage.getItem(CONFIG.STORAGE_KEYS.USER_ID) || '';
    },
    
    // 비밀번호 해시 생성 (더 강력한 보안)
    async hashPassword(password) {
        if (!password) return '';
        
        // 보안 솔트 추가
        const secretSalt = CONFIG.SECURITY.HASH_SALT_PREFIX;
        const encoder = new TextEncoder();
        const data = encoder.encode(password + secretSalt);
        
        try {
            // Web Crypto API 사용해 SHA-256 해시 생성
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            
            // ArrayBuffer를 16진수 문자열로 변환
            return Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        } catch (error) {
            console.error('보안 해시 생성 오류:', error);
            
            // 폴백 해시 방식 (절대 최종 제품에서 사용하지 마세요)
            let hash = '';
            for (let i = 0; i < CONFIG.SECURITY.CRYPT_ITERATIONS; i++) { // 반복 해싱 강화
                const tempData = password + secretSalt + i;
                for (let j = 0; j < tempData.length; j++) {
                    hash += ((tempData.charCodeAt(j) ^ 0x5A) * 13 % 256).toString(16).padStart(2, '0');
                }
            }
            return hash.substring(0, 64); // 64자로 자르기
        }
    },
    
    // 사용자 로그인
    async loginUser(username, password) {
        try {
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('login');
            if (!rateLimit.allowed) {
                return { success: false, message: rateLimit.message };
            }
            
            // 입력 유효성 검사
            if (!username || !password) {
                return { success: false, message: '사용자명과 비밀번호가 필요합니다' };
            }
            
            // 사용자명 검증
            const usernameValidation = utils.validateUsername(username);
            if (!usernameValidation.valid) {
                return { success: false, message: usernameValidation.message };
            }
            
            // 비밀번호 해시 생성
            const passwordHash = await this.hashPassword(password);
            
            // CSRF 토큰 생성
            const csrfToken = utils.generateCSRFToken();
            
            // Supabase에서 사용자 조회
            const { data, error } = await supabase
                .from('users')
                .select('id, username')
                .eq('username', username)
                .eq('password_hash', passwordHash)
                .maybeSingle();
            
            if (error) throw error;
            
            if (!data) {
                // 실패한 로그인 시도 기록
                return { success: false, message: '사용자명 또는 비밀번호가 올바르지 않습니다' };
            }
            
            const userId = data.id;
            
            // 로그인 세션 생성
            const expiryTime = Date.now() + CONFIG.SECURITY.SESSION_DURATION;
            
            // JWT 토큰 생성 (클라이언트 측 시뮬레이션)
            const jwtToken = utils.generateJWTToken(userId, username);
            
            // 세션 저장
            appState.userId = userId;
            appState.userName = username;
            appState.isAuthenticated = true;
            appState.authToken = jwtToken;
            appState.authExpiry = expiryTime;
            
            // 로컬 스토리지에 저장
            utils.storage.saveSessionData(jwtToken, userId, expiryTime);
            localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, username);
            
            // 설정에 작가명 저장
            settings.author = username;
            utils.storage.saveSettings(settings);
            
            // 즐겨찾기 로드
            await this.loadFavorites();
            
            // 로그인 시도 횟수 초기화
            appState.rateLimits.loginAttempts = 0;
            
            return { success: true, userId };
        } catch (error) {
            console.error('로그인 오류:', error);
            return { 
                success: false, 
                message: error.message || '로그인 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 로그아웃
    async logout() {
        try {
            // 세션 삭제
            appState.isAuthenticated = false;
            appState.userId = '';
            appState.userName = '';
            appState.authToken = null;
            appState.favorites = [];
            
            // 로컬 스토리지에서 세션 데이터 삭제
            utils.storage.clearSession();
            
            return { success: true };
        } catch (error) {
            console.error('로그아웃 오류:', error);
            return { 
                success: false,
                message: error.message || '로그아웃 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 즐겨찾기 불러오기
    async loadFavorites() {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                appState.favorites = [];
                return [];
            }
            
            // Supabase에서 즐겨찾기 조회
            const { data, error } = await supabase
                .from('favorites')
                .select('artwork_id')
                .eq('user_id', userId);
            
            if (error) throw error;
            
            // 작품 ID 배열로 변환
            const favorites = data ? data.map(fav => fav.artwork_id) : [];
            
            // 상태 업데이트
            appState.favorites = favorites;
            
            // 로컬 스토리지 업데이트 (캐시)
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(favorites));
            
            return favorites;
        } catch (error) {
            console.error('즐겨찾기 로드 오류:', error);
            
            // 로컬 스토리지에서 가져오기 시도
            try {
                const localFavorites = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.FAVORITES) || '[]');
                appState.favorites = localFavorites;
                return localFavorites;
            } catch (e) {
                appState.favorites = [];
                return [];
            }
        }
    },
    
    // 즐겨찾기 추가
    async addFavorite(artworkId) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return Promise.reject(new Error('로그인이 필요합니다'));
            }
            
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // CSRF 토큰 검증
            if (!appState.csrfToken) {
                utils.generateCSRFToken();
            }
            
            // 이미 즐겨찾기에 있는지 확인
            if (appState.favorites.includes(artworkId)) {
                return Promise.resolve(appState.favorites);
            }
            
            // 작품 존재 여부 확인
            const { data: artwork, error: artworkError } = await supabase
                .from('artworks')
                .select('id')
                .eq('id', artworkId)
                .maybeSingle();
            
            if (artworkError) throw artworkError;
            
            if (!artwork) {
                return Promise.reject(new Error('존재하지 않는 작품입니다'));
            }
            
            // 중복 확인
            const { data: existingFavorite, error: existingError } = await supabase
                .from('favorites')
                .select('id')
                .eq('user_id', userId)
                .eq('artwork_id', artworkId)
                .maybeSingle();
            
            if (existingError) throw existingError;
            
            if (existingFavorite) {
                // 이미 즐겨찾기에 있음 - 상태 업데이트만
                if (!appState.favorites.includes(artworkId)) {
                    appState.favorites.push(artworkId);
                    localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
                }
                return Promise.resolve(appState.favorites);
            }
            
            // Supabase에 즐겨찾기 추가
            const { error } = await supabase
                .from('favorites')
                .insert([{
                    user_id: userId,
                    artwork_id: artworkId,
                    created_at: new Date().toISOString()
                }]);
            
            if (error) throw error;
            
            // 상태 업데이트
            appState.favorites.push(artworkId);
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
            
            return Promise.resolve(appState.favorites);
        } catch (error) {
            console.error('즐겨찾기 추가 오류:', error);
            return Promise.reject(error);
        }
    },
    
    // 즐겨찾기 제거
    async removeFavorite(artworkId) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return Promise.reject(new Error('로그인이 필요합니다'));
            }
            
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // CSRF 토큰 검증
            if (!appState.csrfToken) {
                utils.generateCSRFToken();
            }
            
            // 즐겨찾기에 없으면 무시
            if (!appState.favorites.includes(artworkId)) {
                return Promise.resolve(appState.favorites);
            }
            
            // Supabase에서 즐겨찾기 제거
            const { error } = await supabase
                .from('favorites')
                .delete()
                .eq('user_id', userId)
                .eq('artwork_id', artworkId);
            
            if (error) throw error;
            
            // 상태 업데이트
            appState.favorites = appState.favorites.filter(id => id !== artworkId);
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
            
            return Promise.resolve(appState.favorites);
        } catch (error) {
            console.error('즐겨찾기 제거 오류:', error);
            return Promise.reject(error);
        }
    },
    
    // CAPTCHA 검증 (서버 측에서 처리해야 하지만, 현재는 클라이언트에서 간단히 검증)
    verifyCaptcha(captchaResponse) {
        // 실제 환경에서는 서버로 토큰을 보내 검증해야 함
        return !!captchaResponse;
    },
    
    // 작품 온라인 공유
    async shareArtwork(artworkData, captchaResponse) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // CAPTCHA 검증
            if (!this.verifyCaptcha(captchaResponse)) {
                return { success: false, message: '보안 인증을 완료해주세요' };
            }
            
            // CSRF 토큰 검증
            if (!appState.csrfToken) {
                utils.generateCSRFToken();
            }
            
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('api');
            if (!rateLimit.allowed) {
                return { success: false, message: rateLimit.message };
            }
            
            // 현재 작품 수 확인
            const count = await this.getUserArtworksCount();
            if (count >= CONFIG.MAX_ARTWORK_PER_USER) {
                return { success: false, message: `최대 ${CONFIG.MAX_ARTWORK_PER_USER}개까지 작품을 공유할 수 있습니다. 기존 작품을 삭제하고 시도해주세요.` };
            }
            
            // 입력 데이터 검증
            if (!artworkData.title) {
                return { success: false, message: '작품 제목이 필요합니다' };
            }
            
            if (!artworkData.data || !artworkData.data.board) {
                return { success: false, message: '작품 데이터가 유효하지 않습니다' };
            }
            
            // XSS 방지
            const sanitizedTitle = utils.sanitizeText(artworkData.title, 100);
            const sanitizedDesc = utils.sanitizeText(artworkData.description || '', 500);
            
            // 태그 정제
            const sanitizedTags = artworkData.tags 
                ? artworkData.tags.map(tag => utils.sanitizeText(tag, 30)).filter(tag => tag.length > 0)
                : [];
            
            // 작품 데이터 준비
            const artwork = {
                title: sanitizedTitle,
                description: sanitizedDesc,
                tags: sanitizedTags,
                data: JSON.stringify(artworkData.data), // 객체를 문자열로 저장
                creator: this.getUsername(),
                creator_id: userId,
                created_at: new Date().toISOString(),
                views: 0,
                version: CONFIG.APP_VERSION
            };
            
            // Supabase에 작품 저장
            const { data, error } = await supabase
                .from('artworks')
                .insert([artwork])
                .select();
            
            if (error) throw error;
            
            if (data && data.length > 0) {
                // 캐시 업데이트
                const newArtwork = data[0];
                
                // 데이터를 객체로 변환하여 저장
                if (typeof newArtwork.data === 'string') {
                    try {
                        newArtwork.data = JSON.parse(newArtwork.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                appState.artworkCache[newArtwork.id] = newArtwork;
                
                return { success: true, artworkId: newArtwork.id };
            } else {
                return { success: false, message: '작품 저장에 실패했습니다' };
            }
        } catch (error) {
            console.error('작품 공유 오류:', error);
            return { 
                success: false, 
                message: error.message || '작품 저장 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 단일 작품 가져오기
    async getArtwork(artworkId) {
        try {
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('api');
            if (!rateLimit.allowed) {
                throw new Error(rateLimit.message);
            }
            
            // 캐시에서 작품 확인
            if (appState.artworkCache[artworkId]) {
                // 캐시된 작품 반환
                return appState.artworkCache[artworkId];
            }
            
            // Supabase에서 작품 조회
            const { data, error } = await supabase
                .from('artworks')
                .select('*')
                .eq('id', artworkId)
                .single();
            
            if (error) throw error;
            
            if (data) {
                // 문자열 데이터를 객체로 변환
                if (typeof data.data === 'string') {
                    try {
                        data.data = JSON.parse(data.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                // SQL 인젝션 및 XSS 방지
                data.title = utils.sanitizeText(data.title || '', 100);
                data.description = utils.sanitizeText(data.description || '', 500);
                
                if (Array.isArray(data.tags)) {
                    data.tags = data.tags.map(tag => utils.sanitizeText(tag, 30));
                }
                
                // 캐시에 저장
                appState.artworkCache[artworkId] = data;
                return data;
            }
            
            return null;
        } catch (error) {
            console.error('작품 가져오기 오류:', error);
            throw error;
        }
    },
    
    // 사용자 작품 가져오기
    async getUserArtworks(page = 1, pageSize = 12, sort = 'latest', search = '') {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return { data: [], count: 0 };
            }
            
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('api');
            if (!rateLimit.allowed) {
                throw new Error(rateLimit.message);
            }
            
            // 정렬 방식 설정
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' })
                .eq('creator_id', userId);
            
            // 검색어 적용
            if (search) {
                const sanitizedSearch = utils.sanitizeText(search, 100);
                query = query.or(`title.ilike.%${sanitizedSearch}%,description.ilike.%${sanitizedSearch}%`);
            }
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            // 데이터 처리
            const processedData = data ? data.map(item => {
                // 문자열 데이터를 객체로 변환
                if (typeof item.data === 'string') {
                    try {
                        item.data = JSON.parse(item.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                // XSS 방지
                item.title = utils.sanitizeText(item.title || '', 100);
                item.description = utils.sanitizeText(item.description || '', 500);
                
                if (Array.isArray(item.tags)) {
                    item.tags = item.tags.map(tag => utils.sanitizeText(tag, 30));
                }
                
                return item;
            }) : [];
            
            return { data: processedData, count: count || 0 };
        } catch (error) {
            console.error('사용자 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 사용자 작품 수 가져오기
    async getUserArtworksCount() {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return 0;
            }
            
            // Supabase에서 사용자 작품 수 조회
            const { count, error } = await supabase
                .from('artworks')
                .select('*', { count: 'exact', head: true })
                .eq('creator_id', userId);
            
            if (error) throw error;
            
            return count || 0;
        } catch (error) {
            console.error('사용자 작품 수 가져오기 오류:', error);
            return 0;
        }
    },
    
    // 공용 갤러리 작품 가져오기
    async getPublicArtworks(page = 1, pageSize = 12, sort = 'latest', search = '') {
        try {
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('api');
            if (!rateLimit.allowed) {
                throw new Error(rateLimit.message);
            }
            
            // 정렬 방식 설정
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' });
            
            // 검색어 적용
            if (search) {
                const sanitizedSearch = utils.sanitizeText(search, 100);
                query = query.or(`title.ilike.%${sanitizedSearch}%,description.ilike.%${sanitizedSearch}%,creator.ilike.%${sanitizedSearch}%`);
            }
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            // 데이터 처리
            const processedData = data ? data.map(item => {
                // 문자열 데이터를 객체로 변환
                if (typeof item.data === 'string') {
                    try {
                        item.data = JSON.parse(item.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                // XSS 방지
                item.title = utils.sanitizeText(item.title || '', 100);
                item.description = utils.sanitizeText(item.description || '', 500);
                
                if (Array.isArray(item.tags)) {
                    item.tags = item.tags.map(tag => utils.sanitizeText(tag, 30));
                }
                
                return item;
            }) : [];
            
            return { data: processedData, count: count || 0 };
        } catch (error) {
            console.error('공용 갤러리 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 즐겨찾기 작품 가져오기
    async getFavoriteArtworks(page = 1, pageSize = 12, sort = 'latest', search = '') {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return { data: [], count: 0 };
            }
            
            // 속도 제한 검사
            const rateLimit = utils.checkRateLimit('api');
            if (!rateLimit.allowed) {
                throw new Error(rateLimit.message);
            }
            
            // 즐겨찾기 작품 ID 목록 가져오기
            await this.loadFavorites();
            
            // 즐겨찾기가 없으면 빈 배열 반환
            if (!appState.favorites || appState.favorites.length === 0) {
                return { data: [], count: 0 };
            }
            
            // Supabase에서 즐겨찾기 작품 조회
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' })
                .in('id', appState.favorites);
            
            // 검색어 적용
            if (search) {
                const sanitizedSearch = utils.sanitizeText(search, 100);
                query = query.or(`title.ilike.%${sanitizedSearch}%,description.ilike.%${sanitizedSearch}%,creator.ilike.%${sanitizedSearch}%`);
            }
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            // 데이터 처리
            const processedData = data ? data.map(item => {
                // 문자열 데이터를 객체로 변환
                if (typeof item.data === 'string') {
                    try {
                        item.data = JSON.parse(item.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                // XSS 방지
                item.title = utils.sanitizeText(item.title || '', 100);
                item.description = utils.sanitizeText(item.description || '', 500);
                
                if (Array.isArray(item.tags)) {
                    item.tags = item.tags.map(tag => utils.sanitizeText(tag, 30));
                }
                
                return item;
            }) : [];
            
            return { data: processedData, count: count || 0 };
        } catch (error) {
            console.error('즐겨찾기 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 조회수 증가
    async incrementViews(artworkId) {
        try {
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // 캐시된 작품 가져오기
            const artwork = appState.artworkCache[artworkId];
            
            if (!artwork) {
                // 작품 정보 조회
                const { data, error } = await supabase
                    .from('artworks')
                    .select('*')
                    .eq('id', artworkId)
                    .single();
                
                if (error) throw error;
                if (!data) throw new Error('작품을 찾을 수 없습니다');
                
                // 조회수 증가
                const { error: updateError } = await supabase
                    .from('artworks')
                    .update({ views: (data.views || 0) + 1 })
                    .eq('id', artworkId);
                
                if (updateError) throw updateError;
                
                // 문자열 데이터를 객체로 변환
                if (typeof data.data === 'string') {
                    try {
                        data.data = JSON.parse(data.data);
                    } catch (e) {
                        console.error('작품 데이터 파싱 오류:', e);
                    }
                }
                
                // XSS 방지
                data.title = utils.sanitizeText(data.title || '', 100);
                data.description = utils.sanitizeText(data.description || '', 500);
                
                if (Array.isArray(data.tags)) {
                    data.tags = data.tags.map(tag => utils.sanitizeText(tag, 30));
                }
                
                // 캐시 업데이트
                data.views = (data.views || 0) + 1;
                appState.artworkCache[artworkId] = data;
            } else {
                // 캐시된 작품 정보가 있으면 바로 업데이트
                const { error } = await supabase
                    .from('artworks')
                    .update({ views: (artwork.views || 0) + 1 })
                    .eq('id', artworkId);
                
                if (error) throw error;
                
                // 캐시된 작품 조회수 증가
                artwork.views = (artwork.views || 0) + 1;
            }
            
            return Promise.resolve();
        } catch (error) {
            console.error('조회수 증가 오류:', error);
            return Promise.reject(error);
        }
    },
    
    // 작품 삭제
    async deleteArtwork(artworkId) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // 유효성 검사
            if (!artworkId) {
                return { success: false, message: '작품 ID가 필요합니다' };
            }
            
            // CSRF 토큰 검증
            if (!appState.csrfToken) {
                utils.generateCSRFToken();
            }
            
            // 소유권 확인
            const { data: artwork, error: checkError } = await supabase
                .from('artworks')
                .select('creator_id')
                .eq('id', artworkId)
                .single();
            
            if (checkError) throw checkError;
            
            if (!artwork) {
                return { success: false, message: '작품을 찾을 수 없습니다' };
            }
            
            if (artwork.creator_id !== userId) {
                return { success: false, message: '이 작품을 삭제할 권한이 없습니다' };
            }
            
            // 작품 삭제
            const { error } = await supabase
                .from('artworks')
                .delete()
                .eq('id', artworkId);
            
            if (error) throw error;
            
            // 관련 즐겨찾기 삭제
            await supabase
                .from('favorites')
                .delete()
                .eq('artwork_id', artworkId);
            
            // 캐시에서 삭제
            delete appState.artworkCache[artworkId];
            
            // 즐겨찾기에서도 제거
            if (appState.favorites.includes(artworkId)) {
                appState.favorites = appState.favorites.filter(id => id !== artworkId);
                localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
            }
            
            return { success: true };
        } catch (error) {
            console.error('작품 삭제 오류:', error);
            return { 
                success: false, 
                message: error.message || '작품 삭제 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 계정 비밀번호 변경
    async changePassword(currentPassword, newPassword) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            const username = this.getUsername();
            
            if (!userId || !this.isAuthenticated() || !username) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // 입력 유효성 검사
            if (!currentPassword) {
                return { success: false, message: '현재 비밀번호가 필요합니다' };
            }
            
            // 새 비밀번호 검증
            if (newPassword) {
                const passwordValidation = utils.validatePassword(newPassword);
                if (!passwordValidation.valid) {
                    return { success: false, message: passwordValidation.message };
                }
            }
            
            // 현재 비밀번호 해시 생성
            const currentPasswordHash = await this.hashPassword(currentPassword);
            
            // 사용자 확인
            const { data, error } = await supabase
                .from('users')
                .select('id')
                .eq('id', userId)
                .eq('username', username)
                .eq('password_hash', currentPasswordHash)
                .single();
            
            if (error || !data) {
                return { success: false, message: '현재 비밀번호가 일치하지 않습니다' };
            }
            
            // 비밀번호를 변경하는 경우
            if (newPassword) {
                // 새 비밀번호 해시 생성
                const newPasswordHash = await this.hashPassword(newPassword);
                
                // 비밀번호 업데이트
                const { error: updateError } = await supabase
                    .from('users')
                    .update({ 
                        password_hash: newPasswordHash,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', userId);
                
                if (updateError) throw updateError;
                
                return { success: true, message: '비밀번호가 성공적으로 변경되었습니다' };
            }
            
            return { success: true, message: '계정 정보가 확인되었습니다' };
        } catch (error) {
            console.error('비밀번호 변경 오류:', error);
            return { 
                success: false, 
                message: error.message || '비밀번호 변경 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 계정 삭제
    async deleteAccount(password) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            const username = this.getUsername();
            
            if (!userId || !this.isAuthenticated() || !username) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // 입력 유효성 검사
            if (!password) {
                return { success: false, message: '비밀번호가 필요합니다' };
            }
            
            // 비밀번호 해시 생성
            const passwordHash = await this.hashPassword(password);
            
            // 사용자 확인
            const { data, error } = await supabase
                .from('users')
                .select('id')
                .eq('id', userId)
                .eq('username', username)
                .eq('password_hash', passwordHash)
                .single();
            
            if (error || !data) {
                return { success: false, message: '비밀번호가 일치하지 않습니다' };
            }
            
            // 트랜잭션 시뮬레이션 (실제로는 서버 측에서 처리해야 함)
            // 1. 사용자의 모든 작품 조회
            const { data: artworks, error: artworksError } = await supabase
                .from('artworks')
                .select('id')
                .eq('creator_id', userId);
            
            if (artworksError) throw artworksError;
            
            // 2. 관련 즐겨찾기 모두 삭제
            if (artworks && artworks.length > 0) {
                const artworkIds = artworks.map(a => a.id);
                
                const { error: favoritesError } = await supabase
                    .from('favorites')
                    .delete()
                    .in('artwork_id', artworkIds);
                
                if (favoritesError) throw favoritesError;
                
                // 3. 작품 삭제
                const { error: deleteArtworksError } = await supabase
                    .from('artworks')
                    .delete()
                    .eq('creator_id', userId);
                
                if (deleteArtworksError) throw deleteArtworksError;
            }
            
            // 4. 사용자의 즐겨찾기 삭제
            const { error: userFavoritesError } = await supabase
                .from('favorites')
                .delete()
                .eq('user_id', userId);
            
            if (userFavoritesError) throw userFavoritesError;
            
            // 5. 사용자 계정 삭제
            const { error: deleteUserError } = await supabase
                .from('users')
                .delete()
                .eq('id', userId);
            
            if (deleteUserError) throw deleteUserError;
            
            // 로컬 스토리지 정리
            utils.storage.clearSession();
            localStorage.removeItem(CONFIG.STORAGE_KEYS.USERNAME);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.FAVORITES);
            
            // 애플리케이션 상태 초기화
            appState.isAuthenticated = false;
            appState.userId = '';
            appState.userName = '';
            appState.authToken = null;
            appState.favorites = [];
            
            return { success: true, message: '계정이 성공적으로 삭제되었습니다' };
        } catch (error) {
            console.error('계정 삭제 오류:', error);
            return { 
                success: false, 
                message: error.message || '계정 삭제 중 오류가 발생했습니다' 
            };
        }
    }
};

// UI 관리 함수
const uiManager = {
    // 모달 관리
    modalHandler: {
        // 설정 모달 표시
        showSettingsModal() {
            if (!utils.validateElement(elements.settingsModal, 'settingsModal') ||
                !utils.validateElement(elements.cellSizeRange, 'cellSizeRange') ||
                !utils.validateElement(elements.cellSizeValue, 'cellSizeValue') ||
                !utils.validateElement(elements.brushSizeRange, 'brushSizeRange') ||
                !utils.validateElement(elements.brushSizeValue, 'brushSizeValue') ||
                !utils.validateElement(elements.bgModeSwitch, 'bgModeSwitch') ||
                !utils.validateElement(elements.customModeSwitch, 'customModeSwitch') ||
                !utils.validateElement(elements.customEmojiSettings, 'customEmojiSettings') ||
                !utils.validateElement(elements.filledEmojiInput, 'filledEmojiInput') ||
                !utils.validateElement(elements.emptyEmojiInput, 'emptyEmojiInput')) {
                return;
            }
            
            // 현재 설정 값 표시
            elements.cellSizeRange.value = settings.cellSize;
            elements.cellSizeValue.textContent = `${settings.cellSize}px`;
            
            elements.brushSizeRange.value = settings.brushSize;
            elements.brushSizeValue.textContent = settings.brushSize;
            
            elements.bgModeSwitch.checked = settings.bgMode === 'transparent';
            elements.customModeSwitch.checked = settings.customMode;
            
            // 커스텀 모드 설정
            elements.customEmojiSettings.style.display = settings.customMode ? 'block' : 'none';
            elements.filledEmojiInput.value = settings.filledEmoji;
            elements.emptyEmojiInput.value = settings.emptyEmoji;
            
            // 모달 표시
            utils.showModal(elements.settingsModal);
        },
        
        // 파일 관리 모달 표시
        showFileModal(mode = 'save') {
            if (!utils.validateElement(elements.fileModal, 'fileModal') ||
                !utils.validateElement(elements.fileModalTitle, 'fileModalTitle') ||
                !utils.validateElement(elements.fileNameInput, 'fileNameInput') ||
                !utils.validateElement(elements.fileList, 'fileList') ||
                !utils.validateElement(elements.saveFormGroup, 'saveFormGroup') ||
                !utils.validateElement(elements.fileListGroup, 'fileListGroup') ||
                !utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') ||
                !utils.validateElement(elements.fileExportBtn, 'fileExportBtn') ||
                !utils.validateElement(elements.fileActionBtn, 'fileActionBtn')) {
                return;
            }
            
            // 모달 설정 초기화
            elements.fileNameInput.value = '';
            elements.filePreview.innerHTML = '';
            elements.fileList.innerHTML = '';
            elements.fileDeleteBtn.style.display = 'none';
            elements.fileExportBtn.style.display = 'none';
            
            // 모드에 따른 UI 설정
            if (mode === 'save') {
                elements.fileModalTitle.textContent = '파일 저장';
                elements.saveFormGroup.style.display = 'block';
                elements.fileListGroup.style.display = 'none';
                elements.fileActionBtn.textContent = '저장';
                elements.fileActionBtn.onclick = this.handleFileSave;
            } else if (mode === 'load') {
                elements.fileModalTitle.textContent = '파일 불러오기';
                elements.saveFormGroup.style.display = 'none';
                elements.fileListGroup.style.display = 'block';
                elements.fileActionBtn.textContent = '불러오기';
                elements.fileActionBtn.onclick = this.handleFileLoad;
                
                // 파일 목록 로드
                this.loadFileList();
            }
            
            // 모달 표시
            utils.showModal(elements.fileModal);
        },
        
        // 파일 목록 로드
        loadFileList() {
            if (!utils.validateElement(elements.fileList, 'fileList')) {
                return;
            }
            
            // 파일 목록 가져오기
            const files = utils.storage.getFileList();
            
            // 목록 초기화
            elements.fileList.innerHTML = '';
            
            if (files.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'file-item';
                emptyItem.textContent = '저장된 파일이 없습니다';
                elements.fileList.appendChild(emptyItem);
                return;
            }
            
            // 파일 목록 표시
            files.forEach(fileName => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.dataset.filename = fileName;
                
                // 파일 메타데이터
                const fileData = utils.storage.loadFile(fileName);
                const lastModified = fileData?.lastModified ? utils.formatDate(fileData.lastModified) : '날짜 없음';
                
                // 파일 이름 표시 (확장자 제거)
                const displayName = fileName.replace(/\.val$/, '');
                
                fileItem.innerHTML = `
                    <div>
                        <strong>${utils.escapeHtml(displayName)}</strong>
                        <div style="font-size: 0.8rem; color: var(--text-muted);">${lastModified}</div>
                    </div>
                    <div class="file-item-actions">
                        <button class="btn btn-round preview-btn" aria-label="미리보기">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                        </button>
                    </div>
                `;
                
                // 파일 선택 이벤트
                fileItem.addEventListener('click', (e) => {
                    // 버튼 클릭은 무시
                    if (e.target.closest('.preview-btn') || e.target.closest('.delete-btn')) {
                        return;
                    }
                    
                    // 선택 표시
                    document.querySelectorAll('.file-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    fileItem.classList.add('selected');
                    
                    // 선택된 파일 미리보기
                    this.showFilePreview(fileName);
                    
                    // 액션 버튼 활성화
                    elements.fileActionBtn.disabled = false;
                    elements.fileDeleteBtn.style.display = 'block';
                    elements.fileExportBtn.style.display = 'block';
                });
                
                // 미리보기 버튼 이벤트
                const previewBtn = fileItem.querySelector('.preview-btn');
                previewBtn.addEventListener('click', () => {
                    this.showFilePreview(fileName);
                });
                
                elements.fileList.appendChild(fileItem);
            });
        },
        
        // 파일 미리보기 표시
        showFilePreview(fileName) {
            if (!utils.validateElement(elements.filePreview, 'filePreview')) {
                return;
            }
            
            try {
                // 파일 데이터 로드
                const fileData = utils.storage.loadFile(fileName);
                
                if (!fileData || !fileData.data || !fileData.data.board) {
                    elements.filePreview.innerHTML = `<div class="text-center">미리보기를 생성할 수 없습니다</div>`;
                    return;
                }
                
                // 미리보기 생성
                elements.filePreview.innerHTML = '';
                
                // Emoji 그리드 미리보기 생성
                const previewGrid = document.createElement('div');
                previewGrid.className = 'drawing-canvas';
                previewGrid.style.gridTemplateRows = `repeat(${fileData.data.board.length}, 15px)`;
                previewGrid.style.gridTemplateColumns = `repeat(${fileData.data.board[0].length}, 15px)`;
                
                for (let row = 0; row < fileData.data.board.length; row++) {
                    for (let col = 0; col < fileData.data.board[0].length; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'emoji-cell';
                        
                        if (fileData.data.meta && fileData.data.meta.bgMode === 'transparent') {
                            cell.classList.add('transparent');
                        }
                        
                        if (fileData.data.board[row][col] === 1) {
                            cell.classList.add('active');
                            
                            if (fileData.data.meta && fileData.data.meta.customMode) {
                                cell.textContent = fileData.data.meta.filledEmoji || '■';
                            } else {
                                cell.textContent = '■';
                            }
                        } else {
                            if (fileData.data.meta && fileData.data.meta.customMode) {
                                cell.textContent = fileData.data.meta.emptyEmoji || '□';
                            } else {
                                cell.textContent = '□';
                            }
                        }
                        
                        previewGrid.appendChild(cell);
                    }
                }
                
                elements.filePreview.appendChild(previewGrid);
                
                // 메타데이터 추가
                const metadataDiv = document.createElement('div');
                metadataDiv.className = 'file-metadata';
                metadataDiv.style.marginTop = '10px';
                metadataDiv.style.fontSize = '0.8rem';
                metadataDiv.style.color = 'var(--text-muted)';
                
                const authorText = fileData.author ? `작가: ${utils.escapeHtml(fileData.author)}` : '';
                const versionText = fileData.version ? `버전: ${utils.escapeHtml(fileData.version)}` : '';
                const dateText = fileData.lastModified ? `최종 수정: ${utils.formatDate(fileData.lastModified)}` : '';
                
                metadataDiv.innerHTML = `
                    <div>${authorText}</div>
                    <div>${dateText}</div>
                    <div>${versionText}</div>
                `;
                
                elements.filePreview.appendChild(metadataDiv);
                
            } catch (error) {
                console.error('파일 미리보기 오류:', error);
                elements.filePreview.innerHTML = `<div class="text-center">미리보기를 생성할 수 없습니다</div>`;
            }
        },
        
        // 파일 저장 처리
        handleFileSave() {
            if (!utils.validateElement(elements.fileNameInput, 'fileNameInput') ||
                !utils.validateElement(elements.fileModal, 'fileModal')) {
                return;
            }
            
            const fileName = elements.fileNameInput.value.trim();
            
            if (!fileName) {
                utils.showToast('파일 이름을 입력해주세요', 'error');
                return;
            }
            
            // 파일 이름 유효성 검사
            const sanitizedFileName = utils.sanitizeFileName(fileName);
            if (!sanitizedFileName) {
                utils.showToast('유효하지 않은 파일 이름입니다', 'error');
                return;
            }
            
            // 현재 보드 데이터 가져오기
            const boardData = canvasRenderer.getBoardData();
            
            // 저장할 데이터 구성
            const saveData = {
                data: boardData,
                author: settings.author || api.getUsername() || '익명',
                version: CONFIG.APP_VERSION,
                createdAt: new Date().toISOString()
            };
            
            // 파일 저장
            const finalFileName = sanitizedFileName.endsWith('.val') ? 
                sanitizedFileName : sanitizedFileName + '.val';
                
            const success = utils.storage.saveFile(finalFileName, saveData);
            
            if (success) {
                utils.showToast(`파일이 "${finalFileName}"으로 저장되었습니다`, 'success');
                utils.hideModal(elements.fileModal);
            } else {
                utils.showToast('파일 저장에 실패했습니다', 'error');
            }
        },
        
        // 파일 불러오기 처리
        handleFileLoad() {
            // 선택된 파일 확인
            const selectedItem = document.querySelector('.file-item.selected');
            
            if (!selectedItem) {
                utils.showToast('파일을 선택해주세요', 'error');
                return;
            }
            
            const fileName = selectedItem.dataset.filename;
            
            if (!fileName) {
                utils.showToast('파일 이름을 가져올 수 없습니다', 'error');
                return;
            }
            
            // 파일 데이터 로드
            const fileData = utils.storage.loadFile(fileName);
            
            if (!fileData || !fileData.data) {
                utils.showToast('파일을 불러올 수 없습니다', 'error');
                return;
            }
            
            // 설정 업데이트
            if (fileData.data.meta) {
                if (fileData.data.meta.rows && fileData.data.meta.cols) {
                    settings.emojiRows = fileData.data.meta.rows;
                    settings.emojiCols = fileData.data.meta.cols;
                }
                
                if (fileData.data.meta.cellSize) {
                    settings.cellSize = fileData.data.meta.cellSize;
                }
                
                if (fileData.data.meta.bgMode) {
                    settings.bgMode = fileData.data.meta.bgMode;
                }
                
                if (typeof fileData.data.meta.customMode !== 'undefined') {
                    settings.customMode = fileData.data.meta.customMode;
                }
                
                if (fileData.data.meta.filledEmoji) {
                    settings.filledEmoji = fileData.data.meta.filledEmoji;
                }
                
                if (fileData.data.meta.emptyEmoji) {
                    settings.emptyEmoji = fileData.data.meta.emptyEmoji;
                }
            }
            
            // 설정 저장
            utils.storage.saveSettings(settings);
            
            // 캔버스 그리드 재생성
            canvasRenderer.createGrid();
            
            // 데이터 로드
            const success = canvasRenderer.loadBoardData(fileData.data);
            
            if (success) {
                utils.showToast(`"${fileName}" 파일을 불러왔습니다`, 'success');
                utils.hideModal(elements.fileModal);
            } else {
                utils.showToast('파일 불러오기에 실패했습니다', 'error');
            }
        },
        
        // 파일 삭제 처리
        handleFileDelete() {
            // 선택된 파일 확인
            const selectedItem = document.querySelector('.file-item.selected');
            
            if (!selectedItem) {
                utils.showToast('파일을 선택해주세요', 'error');
                return;
            }
            
            const fileName = selectedItem.dataset.filename;
            
            if (!fileName) {
                utils.showToast('파일 이름을 가져올 수 없습니다', 'error');
                return;
            }
            
            // 확인 대화상자
            if (!confirm(`"${fileName}" 파일을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
                return;
            }
            
            // 파일 삭제
            const success = utils.storage.deleteFile(fileName);
            
            if (success) {
                utils.showToast(`"${fileName}" 파일이 삭제되었습니다`, 'success');
                
                // 파일 목록 새로고침
                this.loadFileList();
                
                // 미리보기 초기화
                elements.filePreview.innerHTML = '';
                
                // 버튼 상태 업데이트
                elements.fileDeleteBtn.style.display = 'none';
                elements.fileExportBtn.style.display = 'none';
            } else {
                utils.showToast('파일 삭제에 실패했습니다', 'error');
            }
        },
        
        // 내보내기/가져오기 모달 표시
        showExportImportModal() {
            if (!utils.validateElement(elements.exportImportModal, 'exportImportModal') ||
                !utils.validateElement(elements.exportBtn, 'exportBtn') ||
                !utils.validateElement(elements.importBtn, 'importBtn') ||
                !utils.validateElement(elements.importFileInput, 'importFileInput') ||
                !utils.validateElement(elements.exportFileNameGroup, 'exportFileNameGroup') ||
                !utils.validateElement(elements.exportImportCancelBtn, 'exportImportCancelBtn') ||
                !utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn')) {
                return;
            }
            
            // 모달 초기화
            elements.importFileInput.style.display = 'none';
            elements.exportFileNameGroup.style.display = 'none';
            elements.filePreviewContainer.style.display = 'none';
            elements.importConfirm.style.display = 'none';
            elements.executeExportImportBtn.style.display = 'none';
            
            // 파일 입력 초기화
            if (elements.fileInput) {
                elements.fileInput.value = '';
            }
            
            // 작가 정보 업데이트
            elements.fileAuthorText.textContent = settings.author || api.getUsername() || '익명';
            elements.fileVersionText.textContent = CONFIG.APP_VERSION;
            
            // 모달 표시
            utils.showModal(elements.exportImportModal);
            
            // 내보내기 버튼 클릭 이벤트
            elements.exportBtn.onclick = () => {
                // UI 업데이트
                elements.exportBtn.classList.add('active');
                elements.importBtn.classList.remove('active');
                elements.importFileInput.style.display = 'none';
                elements.exportFileNameGroup.style.display = 'block';
                elements.executeExportImportBtn.style.display = 'block';
                elements.executeExportImportBtn.textContent = '내보내기';
                elements.filePreviewContainer.style.display = 'none';
                elements.importConfirm.style.display = 'none';
                
                // 파일명 기본값 설정
                if (elements.exportFileName) {
                    const defaultName = `valpaint_${new Date().toISOString().slice(0, 10).replace(/-/g, '')}`;
                    elements.exportFileName.value = defaultName;
                }
                
                // 내보내기 실행 버튼 이벤트
                elements.executeExportImportBtn.onclick = this.handleExport;
            };
            
            // 가져오기 버튼 클릭 이벤트
            elements.importBtn.onclick = () => {
                // UI 업데이트
                elements.importBtn.classList.add('active');
                elements.exportBtn.classList.remove('active');
                elements.importFileInput.style.display = 'block';
                elements.exportFileNameGroup.style.display = 'none';
                elements.executeExportImportBtn.style.display = 'block';
                elements.executeExportImportBtn.textContent = '가져오기';
                elements.executeExportImportBtn.disabled = true;
                elements.filePreviewContainer.style.display = 'none';
                elements.importConfirm.style.display = 'none';
                
                // 파일 선택 이벤트
                elements.fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    
                    if (!file) {
                        elements.executeExportImportBtn.disabled = true;
                        elements.filePreviewContainer.style.display = 'none';
                        elements.importConfirm.style.display = 'none';
                        return;
                    }
                    
                    // 파일 유효성 검사
                    if (!file.name.endsWith('.val')) {
                        utils.showToast('VAL 파일만 가져올 수 있습니다', 'error');
                        elements.fileInput.value = '';
                        elements.executeExportImportBtn.disabled = true;
                        elements.filePreviewContainer.style.display = 'none';
                        elements.importConfirm.style.display = 'none';
                        return;
                    }
                    
                    // 파일 미리보기
                    this.previewImportFile(file);
                };
                
                // 가져오기 실행 버튼 이벤트
                elements.executeExportImportBtn.onclick = this.handleImport;
            };
            
            // 기본값은 내보내기
            elements.exportBtn.click();
        },
        
        // 가져오기 파일 미리보기
        previewImportFile(file) {
            if (!file || !elements.importPreview || !elements.filePreviewContainer) {
                return;
            }
            
            // 미리보기 영역 표시
            elements.filePreviewContainer.style.display = 'block';
            elements.importPreview.innerHTML = '<div class="spinner"></div><p>파일 분석 중...</p>';
            
            // 파일 읽기
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const fileData = JSON.parse(e.target.result);
                    
                    // 데이터 유효성 검사
                    if (!fileData || !fileData.data || !fileData.data.board) {
                        throw new Error('유효하지 않은 파일 형식입니다');
                    }
                    
                    // 작가 및 버전 정보 표시
                    elements.fileAuthorText.textContent = fileData.author || '알 수 없음';
                    elements.fileVersionText.textContent = fileData.version || '알 수 없음';
                    
                    // 미리보기 생성
                    elements.importPreview.innerHTML = '';
                    
                    // Emoji 그리드 미리보기 생성
                    const rows = fileData.data.board.length;
                    const cols = fileData.data.board[0].length;
                    
                    const previewGrid = document.createElement('div');
                    previewGrid.className = 'drawing-canvas';
                    previewGrid.style.gridTemplateRows = `repeat(${rows}, 15px)`;
                    previewGrid.style.gridTemplateColumns = `repeat(${cols}, 15px)`;
                    
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const cell = document.createElement('div');
                            cell.className = 'emoji-cell';
                            
                            if (fileData.data.meta && fileData.data.meta.bgMode === 'transparent') {
                                cell.classList.add('transparent');
                            }
                            
                            if (fileData.data.board[row][col] === 1) {
                                cell.classList.add('active');
                                
                                if (fileData.data.meta && fileData.data.meta.customMode) {
                                    cell.textContent = fileData.data.meta.filledEmoji || '■';
                                } else {
                                    cell.textContent = '■';
                                }
                            } else {
                                if (fileData.data.meta && fileData.data.meta.customMode) {
                                    cell.textContent = fileData.data.meta.emptyEmoji || '□';
                                } else {
                                    cell.textContent = '□';
                                }
                            }
                            
                            previewGrid.appendChild(cell);
                        }
                    }
                    
                    elements.importPreview.appendChild(previewGrid);
                    
                    // 가져오기 확인 표시
                    elements.importConfirm.style.display = 'block';
                    elements.importConfirmCheck.checked = false;
                    elements.executeExportImportBtn.disabled = true;
                    
                    // 체크박스 이벤트
                    elements.importConfirmCheck.onchange = () => {
                        elements.executeExportImportBtn.disabled = !elements.importConfirmCheck.checked;
                    };
                    
                } catch (error) {
                    console.error('파일 미리보기 오류:', error);
                    elements.importPreview.innerHTML = '<p>파일을 미리볼 수 없습니다</p>';
                    elements.importConfirm.style.display = 'none';
                    elements.executeExportImportBtn.disabled = true;
                }
            };
            
            reader.onerror = () => {
                elements.importPreview.innerHTML = '<p>파일을 읽을 수 없습니다</p>';
                elements.importConfirm.style.display = 'none';
                elements.executeExportImportBtn.disabled = true;
            };
            
            reader.readAsText(file);
        },
        
        // 파일 내보내기 처리
        handleExport() {
            if (!elements.exportFileName) {
                utils.showToast('파일 이름을 설정할 수 없습니다', 'error');
                return;
            }
            
            const fileName = elements.exportFileName.value.trim();
            
            if (!fileName) {
                utils.showToast('파일 이름을 입력해주세요', 'error');
                return;
            }
            
            // 파일 이름 유효성 검사
            const sanitizedFileName = utils.sanitizeFileName(fileName);
            if (!sanitizedFileName) {
                utils.showToast('유효하지 않은 파일 이름입니다', 'error');
                return;
            }
            
            // 현재 보드 데이터 가져오기
            const boardData = canvasRenderer.getBoardData();
            
            // 내보낼 데이터 구성
            const exportData = {
                data: boardData,
                author: settings.author || api.getUsername() || '익명',
                version: CONFIG.APP_VERSION,
                createdAt: new Date().toISOString()
            };
            
            // JSON 데이터 생성
            const jsonData = JSON.stringify(exportData, null, 2);
            
            // 다운로드 링크 생성
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = sanitizedFileName.endsWith('.val') ? 
                sanitizedFileName : sanitizedFileName + '.val';
            
            // 다운로드 실행
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // URL 해제
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            utils.showToast('파일이 내보내기 되었습니다', 'success');
            utils.hideModal(elements.exportImportModal);
        },
        
        // 파일 가져오기 처리
        handleImport() {
            if (!elements.fileInput || !elements.importConfirmCheck) {
                utils.showToast('파일 입력 요소를 찾을 수 없습니다', 'error');
                return;
            }
            
            const file = elements.fileInput.files[0];
            
            if (!file) {
                utils.showToast('파일을 선택해주세요', 'error');
                return;
            }
            
            // 확인 체크박스 확인
            if (!elements.importConfirmCheck.checked) {
                utils.showToast('가져오기 확인을 체크해주세요', 'error');
                return;
            }
            
            // 파일 읽기
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const fileData = JSON.parse(e.target.result);
                    
                    // 데이터 유효성 검사
                    if (!fileData || !fileData.data || !fileData.data.board) {
                        throw new Error('유효하지 않은 파일 형식입니다');
                    }
                    
                    // 설정 업데이트
                    if (fileData.data.meta) {
                        if (fileData.data.meta.rows && fileData.data.meta.cols) {
                            settings.emojiRows = fileData.data.meta.rows;
                            settings.emojiCols = fileData.data.meta.cols;
                        }
                        
                        if (fileData.data.meta.cellSize) {
                            settings.cellSize = fileData.data.meta.cellSize;
                        }
                        
                        if (fileData.data.meta.bgMode) {
                            settings.bgMode = fileData.data.meta.bgMode;
                        }
                        
                        if (typeof fileData.data.meta.customMode !== 'undefined') {
                            settings.customMode = fileData.data.meta.customMode;
                        }
                        
                        if (fileData.data.meta.filledEmoji) {
                            settings.filledEmoji = fileData.data.meta.filledEmoji;
                        }
                        
                        if (fileData.data.meta.emptyEmoji) {
                            settings.emptyEmoji = fileData.data.meta.emptyEmoji;
                        }
                    }
                    
                    // 설정 저장
                    utils.storage.saveSettings(settings);
                    
                    // 캔버스 그리드 재생성
                    canvasRenderer.createGrid();
                    
                    // 데이터 로드
                    const success = canvasRenderer.loadBoardData(fileData.data);
                    
                    if (success) {
                        utils.showToast('파일을 성공적으로 가져왔습니다', 'success');
                        utils.hideModal(elements.exportImportModal);
                    } else {
                        throw new Error('파일 데이터를 캔버스에 로드할 수 없습니다');
                    }
                } catch (error) {
                    console.error('파일 가져오기 오류:', error);
                    utils.showToast('파일 가져오기에 실패했습니다: ' + error.message, 'error');
                }
            };
            
            reader.onerror = () => {
                utils.showToast('파일을 읽을 수 없습니다', 'error');
            };
            
            reader.readAsText(file);
        },
        
        // 공유 모달 표시
        showShareModal() {
            if (!utils.validateElement(elements.shareModal, 'shareModal') ||
                !utils.validateElement(elements.shareTitleInput, 'shareTitleInput') ||
                !utils.validateElement(elements.shareTagsInput, 'shareTagsInput') ||
                !utils.validateElement(elements.shareDescInput, 'shareDescInput') ||
                !utils.validateElement(elements.sharePreview, 'sharePreview')) {
                return;
            }
            
            // 비회원 모드 확인
            if (appState.isGuestMode) {
                utils.showToast('온라인 공유는 로그인이 필요합니다', 'error');
                return;
            }
            
            // 로그인 상태 확인
            if (!api.isAuthenticated()) {
                utils.showToast('로그인이 필요합니다', 'error');
                showAuthModal();
                return;
            }
            
            // 모달 초기화
            elements.shareTitleInput.value = '';
            elements.shareTagsInput.value = '';
            elements.shareDescInput.value = '';
            
            // 미리보기 생성
            elements.sharePreview.innerHTML = '';
            
            // 보드 데이터 가져오기
            const boardData = canvasRenderer.getBoardData();
            
            // 미리보기 생성
            canvasRenderer.createPreview('sharePreview', boardData);
            
            // reCAPTCHA 초기화 (필요시)
            if (window.grecaptcha && window.grecaptcha.reset) {
                try {
                    window.grecaptcha.reset();
                } catch (error) {
                    console.error('reCAPTCHA 초기화 오류:', error);
                }
            }
            
            // 모달 표시
            utils.showModal(elements.shareModal);
        },
        
        // 공유 처리
        async handleShare() {
            if (!utils.validateElement(elements.shareTitleInput, 'shareTitleInput') ||
                !utils.validateElement(elements.shareTagsInput, 'shareTagsInput') ||
                !utils.validateElement(elements.shareDescInput, 'shareDescInput')) {
                return;
            }
            
            // 로그인 상태 확인
            if (!api.isAuthenticated()) {
                utils.showToast('로그인이 필요합니다', 'error');
                utils.hideModal(elements.shareModal);
                showAuthModal();
                return;
            }
            
            const title = elements.shareTitleInput.value.trim();
            const tags = elements.shareTagsInput.value.trim()
                .split(',')
                .map(tag => tag.trim())
                .filter(tag => tag.length > 0);
            const description = elements.shareDescInput.value.trim();
            
            // 유효성 검사
            if (!title) {
                utils.showToast('제목을 입력해주세요', 'error');
                return;
            }
            
            // reCAPTCHA 검증
            let captchaResponse = '';
            
            if (window.grecaptcha) {
                captchaResponse = window.grecaptcha.getResponse();
                
                if (!captchaResponse) {
                    utils.showToast('보안 인증을 완료해주세요', 'error');
                    return;
                }
            }
            
            // 보드 데이터 가져오기
            const boardData = canvasRenderer.getBoardData();
            
            // 공유 데이터 구성
            const shareData = {
                title,
                tags,
                description,
                data: boardData
            };
            
            // 로딩 표시
            const shareBtn = elements.shareActionBtn;
            const originalBtnText = shareBtn.textContent;
            shareBtn.disabled = true;
            shareBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px; display: inline-block;"></div> 공유 중...';
            
            try {
                // 공유 요청
                const result = await api.shareArtwork(shareData, captchaResponse);
                
                if (result.success) {
                    utils.showToast('작품이 성공적으로 공유되었습니다', 'success');
                    utils.hideModal(elements.shareModal);
                } else {
                    throw new Error(result.message || '작품 공유에 실패했습니다');
                }
            } catch (error) {
                console.error('작품 공유 오류:', error);
                utils.showToast(error.message || '작품 공유 중 오류가 발생했습니다', 'error');
                
                // reCAPTCHA 초기화 (필요시)
                if (window.grecaptcha && window.grecaptcha.reset) {
                    try {
                        window.grecaptcha.reset();
                    } catch (e) {
                        console.error('reCAPTCHA 초기화 오류:', e);
                    }
                }
            } finally {
                // 버튼 상태 복원
                shareBtn.disabled = false;
                shareBtn.textContent = originalBtnText;
            }
        }
    },
    
    // 갤러리 페이지 관리
    galleryManager: {
        // 갤러리 페이지 표시
        showGalleryPage() {
            if (!utils.validateElement(elements.galleryPage, 'galleryPage')) {
                return;
            }
            
            // 현재 페이지 상태 업데이트
            appState.currentPage = 'gallery';
            
            // 갤러리 탭 설정
            this.setActiveTab(appState.currentTab);
            
            // 갤러리 콘텐츠 로드
            this.loadGalleryItems();
            
            // 페이지 표시
            elements.galleryPage.classList.add('active');
        },
        
        // 갤러리 페이지 닫기
        hideGalleryPage() {
            if (!utils.validateElement(elements.galleryPage, 'galleryPage')) {
                return;
            }
            
            // 페이지 숨기기
            elements.galleryPage.classList.remove('active');
            
            // 현재 페이지 상태 업데이트
            appState.currentPage = 'home';
        },
        
        // 활성 탭 설정
        setActiveTab(tabName) {
            if (!utils.validateElement(elements.galleryTabs, 'galleryTabs')) {
                return;
            }
            
            // 현재 탭 상태 업데이트
            appState.currentTab = tabName;
            
            // 탭 활성화 표시
            elements.galleryTabs.forEach(tab => {
                if (tab.dataset.tab === tabName) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            // 페이지 파라미터 초기화
            appState.pageParams.page = 1;
            
            // 갤러리 콘텐츠 로드
            this.loadGalleryItems();
        },
        
        // 갤러리 아이템 로드
        async loadGalleryItems() {
            if (!utils.validateElement(elements.galleryContent, 'galleryContent')) {
                return;
            }
            
            // 로딩 표시
            elements.galleryContent.innerHTML = `
                <div class="text-center" style="grid-column: 1 / -1; padding: 40px 0;">
                    <div class="spinner"></div>
                    <p>작품을 불러오는 중...</p>
                </div>
            `;
            
            try {
                const { page, pageSize } = appState.pageParams;
                const search = elements.searchInput ? elements.searchInput.value.trim() : '';
                
                let result = { data: [], count: 0 };
                
                // 현재 탭에 따라 다른 API 호출
                switch (appState.currentTab) {
                    case 'my':
                        if (!api.isAuthenticated()) {
                            elements.galleryContent.innerHTML = `
                                <div class="empty-state" style="grid-column: 1 / -1;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M12 8v4"></path>
                                        <path d="M12 16h.01"></path>
                                    </svg>
                                    <h3 class="empty-state-title">로그인이 필요합니다</h3>
                                    <p class="empty-state-text">내 작품을 보려면 로그인하세요</p>
                                    <button class="btn btn-accent mt-10" onclick="showAuthModal()">로그인</button>
                                </div>
                            `;
                            return;
                        }
                        result = await api.getUserArtworks(page, pageSize, appState.currentFilter, search);
                        break;
                    
                    case 'public':
                        result = await api.getPublicArtworks(page, pageSize, appState.currentFilter, search);
                        break;
                    
                    case 'favorites':
                        if (!api.isAuthenticated()) {
                            elements.galleryContent.innerHTML = `
                                <div class="empty-state" style="grid-column: 1 / -1;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                                    </svg>
                                    <h3 class="empty-state-title">로그인이 필요합니다</h3>
                                    <p class="empty-state-text">즐겨찾기를 보려면 로그인하세요</p>
                                    <button class="btn btn-accent mt-10" onclick="showAuthModal()">로그인</button>
                                </div>
                            `;
                            return;
                        }
                        result = await api.getFavoriteArtworks(page, pageSize, appState.currentFilter, search);
                        break;
                }
                
                // 갤러리 렌더링
                this.renderGalleryItems(result.data, result.count);
                
            } catch (error) {
                console.error('갤러리 아이템 로드 오류:', error);
                
                elements.galleryContent.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <h3 class="empty-state-title">작품을 불러올 수 없습니다</h3>
                        <p class="empty-state-text">잠시 후 다시 시도해주세요</p>
                        <button class="btn btn-accent mt-10" onclick="uiManager.galleryManager.loadGalleryItems()">새로고침</button>
                    </div>
                `;
            }
        },
        
        // 갤러리 아이템 렌더링
        renderGalleryItems(items, totalCount) {
            if (!utils.validateElement(elements.galleryContent, 'galleryContent') ||
                !utils.validateElement(elements.galleryPagination, 'galleryPagination')) {
                return;
            }
            
            // 아이템이 없는 경우
            if (!items || items.length === 0) {
                elements.galleryContent.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <h3 class="empty-state-title">작품이 없습니다</h3>
                        <p class="empty-state-text">새 작품을 만들어 공유해보세요</p>
                    </div>
                `;
                
                // 페이지네이션 숨기기
                elements.galleryPagination.innerHTML = '';
                return;
            }
            
            // 갤러리 아이템 생성
            elements.galleryContent.innerHTML = '';
            
            items.forEach(item => {
                // 미리보기 생성 함수 호출
                const galleryItem = this.createGalleryItem(item);
                elements.galleryContent.appendChild(galleryItem);
            });
            
            // 페이지네이션 생성
            this.createPagination(totalCount);
        },
        
        // 갤러리 아이템 생성
        createGalleryItem(item) {
            const galleryItem = document.createElement('div');
            galleryItem.className = 'gallery-item';
            
            // 썸네일 스타일 생성
            const previewContainer = document.createElement('div');
            previewContainer.className = 'gallery-preview';
            
            // 미리보기 생성
            if (item.data) {
                // 데이터 형식 변환
                const itemData = typeof item.data === 'string' ? 
                    JSON.parse(item.data) : item.data;
                
                // 미리보기 크기 계산
                const maxSize = Math.min(previewContainer.clientWidth, previewContainer.clientHeight) || 120;
                const cellSize = Math.max(2, Math.min(10, Math.floor(maxSize / Math.max(itemData.board.length, itemData.board[0].length))));
                
                // 이모지 그리드 미리보기 생성
                const previewGrid = document.createElement('div');
                previewGrid.className = 'drawing-canvas';
                previewGrid.style.gridTemplateRows = `repeat(${itemData.board.length}, ${cellSize}px)`;
                previewGrid.style.gridTemplateColumns = `repeat(${itemData.board[0].length}, ${cellSize}px)`;
                
                for (let row = 0; row < itemData.board.length; row++) {
                    for (let col = 0; col < itemData.board[0].length; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'emoji-cell';
                        cell.style.fontSize = `${Math.max(cellSize * 0.7, 8)}px`;
                        
                        if (itemData.meta && itemData.meta.bgMode === 'transparent') {
                            cell.classList.add('transparent');
                        }
                        
                        if (itemData.board[row][col] === 1) {
                            cell.classList.add('active');
                            
                            if (itemData.meta && itemData.meta.customMode) {
                                cell.textContent = itemData.meta.filledEmoji || '■';
                            } else {
                                cell.textContent = '■';
                            }
                        } else {
                            if (itemData.meta && itemData.meta.customMode) {
                                cell.textContent = itemData.meta.emptyEmoji || '□';
                            } else {
                                cell.textContent = '□';
                            }
                        }
                        
                        previewGrid.appendChild(cell);
                    }
                }
                
                previewContainer.appendChild(previewGrid);
            } else {
                previewContainer.innerHTML = '<p>미리보기를 생성할 수 없습니다</p>';
            }
            
            // 태그 목록 생성
            const tagsHtml = item.tags && item.tags.length > 0 ? 
                item.tags.map(tag => `<div class="gallery-tag">${utils.escapeHtml(tag)}</div>`).join('') : '';
            
            // 정보 영역 생성
            const galleryInfo = document.createElement('div');
            galleryInfo.className = 'gallery-info';
            
            // 즐겨찾기 상태 확인
            const isFavorite = appState.favorites.includes(item.id);
            
            galleryInfo.innerHTML = `
                <div class="gallery-title">${utils.escapeHtml(item.title)}</div>
                <div class="gallery-creator">작가: ${utils.escapeHtml(item.creator)}</div>
                <div class="gallery-tags">${tagsHtml}</div>
                <div class="gallery-stats">
                    <div>조회수: ${item.views || 0}</div>
                    <div class="gallery-favorite ${isFavorite ? 'active' : ''}" data-id="${item.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="${isFavorite ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                        </svg>
                        <span>${isFavorite ? '추가됨' : '즐겨찾기'}</span>
                    </div>
                </div>
            `;
            
            // 아이템 조립
            galleryItem.appendChild(previewContainer);
            galleryItem.appendChild(galleryInfo);
            
            // 아이템 클릭 이벤트
            galleryItem.addEventListener('click', (e) => {
                // 즐겨찾기 버튼 클릭은 무시
                if (e.target.closest('.gallery-favorite')) {
                    return;
                }
                
                // 작품 상세 페이지 열기
                uiManager.artworkManager.openArtworkPage(item.id);
            });
            
            // 즐겨찾기 버튼 이벤트
            const favoriteBtn = galleryInfo.querySelector('.gallery-favorite');
            if (favoriteBtn) {
                favoriteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    
                    // 로그인 확인
                    if (!api.isAuthenticated()) {
                        utils.showToast('즐겨찾기 추가는 로그인이 필요합니다', 'error');
                        return;
                    }
                    
                    const artworkId = favoriteBtn.dataset.id;
                    const isActive = favoriteBtn.classList.contains('active');
                    
                    try {
                        if (isActive) {
                            // 즐겨찾기 제거
                            await api.removeFavorite(artworkId);
                            favoriteBtn.classList.remove('active');
                            favoriteBtn.querySelector('svg').setAttribute('fill', 'none');
                            favoriteBtn.querySelector('span').textContent = '즐겨찾기';
                            utils.showToast('즐겨찾기에서 제거되었습니다', 'success');
                        } else {
                            // 즐겨찾기 추가
                            await api.addFavorite(artworkId);
                            favoriteBtn.classList.add('active');
                            favoriteBtn.querySelector('svg').setAttribute('fill', 'currentColor');
                            favoriteBtn.querySelector('span').textContent = '추가됨';
                            utils.showToast('즐겨찾기에 추가되었습니다', 'success');
                        }
                    } catch (error) {
                        console.error('즐겨찾기 오류:', error);
                        utils.showToast(error.message || '즐겨찾기 처리 중 오류가 발생했습니다', 'error');
                    }
                });
            }
            
            return galleryItem;
        },
        
        // 페이지네이션 생성
        createPagination(totalCount) {
            if (!utils.validateElement(elements.galleryPagination, 'galleryPagination')) {
                return;
            }
            
            const { page, pageSize } = appState.pageParams;
            const totalPages = Math.ceil(totalCount / pageSize);
            
            // 페이지네이션 상태 업데이트
            appState.pageParams.totalPages = totalPages;
            
            // 페이지네이션이 필요 없는 경우
            if (totalPages <= 1) {
                elements.galleryPagination.innerHTML = '';
                return;
            }
            
            // 페이지네이션 생성
            elements.galleryPagination.innerHTML = '';
            
            // 이전 페이지 버튼
            if (page > 1) {
                const prevBtn = document.createElement('div');
                prevBtn.className = 'pagination-item';
                prevBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>';
                prevBtn.addEventListener('click', () => {
                    this.goToPage(page - 1);
                });
                elements.galleryPagination.appendChild(prevBtn);
            }
            
            // 페이지 버튼 생성
            let startPage = Math.max(1, page - 2);
            let endPage = Math.min(totalPages, startPage + 4);
            
            // 시작 페이지 조정
            if (endPage - startPage < 4) {
                startPage = Math.max(1, endPage - 4);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('div');
                pageBtn.className = 'pagination-item';
                
                if (i === page) {
                    pageBtn.classList.add('active');
                }
                
                pageBtn.textContent = i;
                
                pageBtn.addEventListener('click', () => {
                    this.goToPage(i);
                });
                
                elements.galleryPagination.appendChild(pageBtn);
            }
            
            // 다음 페이지 버튼
            if (page < totalPages) {
                const nextBtn = document.createElement('div');
                nextBtn.className = 'pagination-item';
                nextBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>';
                nextBtn.addEventListener('click', () => {
                    this.goToPage(page + 1);
                });
                elements.galleryPagination.appendChild(nextBtn);
            }
        },
        
        // 페이지 이동
        goToPage(pageNumber) {
            appState.pageParams.page = pageNumber;
            this.loadGalleryItems();
            
            // 상단으로 스크롤
            elements.galleryPage.scrollTo(0, 0);
        },
        
        // 필터 적용
        applyFilter(filterName) {
            appState.currentFilter = filterName;
            appState.pageParams.page = 1;
            this.loadGalleryItems();
            
            // 필터 메뉴 갱신
            if (elements.filterItems) {
                elements.filterItems.forEach(item => {
                    if (item.dataset.filter === filterName) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            }
        },
        
        // 검색 처리
        handleSearch() {
            if (!elements.searchInput) return;
            
            appState.pageParams.page = 1;
            this.loadGalleryItems();
        }
    },
    
    // 작품 상세 페이지 관리
    artworkManager: {
        // 작품 상세 페이지 열기
        async openArtworkPage(artworkId) {
            if (!utils.validateElement(elements.artworkPage, 'artworkPage') ||
                !utils.validateElement(elements.artworkPageTitle, 'artworkPageTitle') ||
                !utils.validateElement(elements.artworkTitle, 'artworkTitle') ||
                !utils.validateElement(elements.artworkCreator, 'artworkCreator') ||
                !utils.validateElement(elements.artworkPreview, 'artworkPreview') ||
                !utils.validateElement(elements.artworkDate, 'artworkDate') ||
                !utils.validateElement(elements.artworkViews, 'artworkViews') ||
                !utils.validateElement(elements.artworkTags, 'artworkTags') ||
                !utils.validateElement(elements.artworkDesc, 'artworkDesc') ||
                !utils.validateElement(elements.favoriteArtworkBtn, 'favoriteArtworkBtn') ||
                !utils.validateElement(elements.downloadArtworkBtn, 'downloadArtworkBtn') ||
                !utils.validateElement(elements.loadArtworkBtn, 'loadArtworkBtn')) {
                return;
            }
            
            // 현재 페이지 갤러리가 아니면 갤러리 페이지 열기
            if (appState.currentPage !== 'gallery') {
                uiManager.galleryManager.showGalleryPage();
            }
            
            // 로딩 표시
            elements.artworkPreview.innerHTML = `
                <div class="text-center">
                    <div class="spinner"></div>
                    <p>작품을 불러오는 중...</p>
                </div>
            `;
            
            try {
                // URL 해시 업데이트
                window.location.hash = artworkId;
                
                // 작품 데이터 가져오기
                const artwork = await api.getArtwork(artworkId);
                
                if (!artwork) {
                    throw new Error('작품을 찾을 수 없습니다');
                }
                
                // 현재 작품 저장
                appState.currentArtwork = artwork;
                appState.currentPage = 'artwork';
                
                // 작품 정보 표시
                elements.artworkPageTitle.textContent = artwork.title;
                elements.artworkTitle.textContent = artwork.title;
                elements.artworkCreator.textContent = `작가: ${artwork.creator}`;
                elements.artworkDate.textContent = utils.formatDate(artwork.created_at);
                elements.artworkViews.textContent = artwork.views || 0;
                
                // 태그 표시
                elements.artworkTags.innerHTML = '';
                if (artwork.tags && artwork.tags.length > 0) {
                    artwork.tags.forEach(tag => {
                        const tagElement = document.createElement('div');
                        tagElement.className = 'gallery-tag';
                        tagElement.textContent = tag;
                        elements.artworkTags.appendChild(tagElement);
                    });
                }
                
                // 설명 표시
                elements.artworkDesc.textContent = artwork.description || '설명이 없습니다';
                
                // 즐겨찾기 버튼 상태 업데이트
                const isFavorite = appState.favorites.includes(artwork.id);
                
                elements.favoriteArtworkBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="${isFavorite ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                    </svg>
                    ${isFavorite ? '즐겨찾기 해제' : '즐겨찾기'}
                `;
                
                // 미리보기 생성
                this.createArtworkPreview(artwork);
                
                // 조회수 증가
                api.incrementViews(artworkId).catch(error => {
                    console.error('조회수 증가 오류:', error);
                });
                
                // 페이지 표시
                elements.artworkPage.classList.add('active');
                
                // 즐겨찾기 버튼 이벤트
                elements.favoriteArtworkBtn.onclick = () => this.handleFavoriteToggle(artwork.id);
                
                // 다운로드 버튼 이벤트
                elements.downloadArtworkBtn.onclick = () => this.handleArtworkDownload(artwork);
                
                // 불러오기 버튼 이벤트
                elements.loadArtworkBtn.onclick = () => this.handleArtworkLoad(artwork);
                
            } catch (error) {
                console.error('작품 상세 페이지 오류:', error);
                
                elements.artworkPreview.innerHTML = `
                    <div class="empty-state">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <h3 class="empty-state-title">작품을 불러올 수 없습니다</h3>
                        <p class="empty-state-text">${error.message || '오류가 발생했습니다'}</p>
                    </div>
                `;
            }
        },
        
        // 작품 미리보기 생성
        createArtworkPreview(artwork) {
            if (!artwork || !artwork.data) {
                elements.artworkPreview.innerHTML = '<p>미리보기를 생성할 수 없습니다</p>';
                return;
            }
            
            // 데이터 형식 변환
            const artworkData = typeof artwork.data === 'string' ? 
                JSON.parse(artwork.data) : artwork.data;
            
            // 미리보기 생성
            elements.artworkPreview.innerHTML = '';
            
            // Emoji 그리드 미리보기 생성
            const previewGrid = document.createElement('div');
            previewGrid.className = 'drawing-canvas';
            
            const rows = artworkData.board.length;
            const cols = artworkData.board[0].length;
            
            // 최대 크기 계산
            const maxWidth = elements.artworkPreview.clientWidth - 40;
            const maxHeight = elements.artworkPreview.clientHeight - 40;
            
            // 셀 크기 계산
                                const cellSize = Math.min(
                Math.floor(maxWidth / cols),
                Math.floor(maxHeight / rows),
                30
            );
            
            previewGrid.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;
            previewGrid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'emoji-cell';
                    
                    if (artworkData.meta && artworkData.meta.bgMode === 'transparent') {
                        cell.classList.add('transparent');
                    }
                    
                    if (artworkData.board[row][col] === 1) {
                        cell.classList.add('active');
                        
                        if (artworkData.meta && artworkData.meta.customMode) {
                            cell.textContent = artworkData.meta.filledEmoji || '■';
                        } else {
                            cell.textContent = '■';
                        }
                    } else {
                        if (artworkData.meta && artworkData.meta.customMode) {
                            cell.textContent = artworkData.meta.emptyEmoji || '□';
                        } else {
                            cell.textContent = '□';
                        }
                    }
                    
                    previewGrid.appendChild(cell);
                }
            }
            
            elements.artworkPreview.appendChild(previewGrid);
        },
        
        // 작품 상세 페이지 닫기
        closeArtworkPage() {
            if (!utils.validateElement(elements.artworkPage, 'artworkPage')) {
                return;
            }
            
            // 페이지 숨기기
            elements.artworkPage.classList.remove('active');
            
            // URL 해시 제거
            window.location.hash = '';
            
            // 현재 페이지 상태 업데이트
            appState.currentPage = 'gallery';
            appState.currentArtwork = null;
        },
        
        // 즐겨찾기 토글 처리
        async handleFavoriteToggle(artworkId) {
            // 로그인 확인
            if (!api.isAuthenticated()) {
                utils.showToast('즐겨찾기는 로그인이 필요합니다', 'error');
                return;
            }
            
            // 버튼 상태 가져오기
            const isFavorite = appState.favorites.includes(artworkId);
            
            try {
                if (isFavorite) {
                    // 즐겨찾기 제거
                    await api.removeFavorite(artworkId);
                    utils.showToast('즐겨찾기에서 제거되었습니다', 'success');
                } else {
                    // 즐겨찾기 추가
                    await api.addFavorite(artworkId);
                    utils.showToast('즐겨찾기에 추가되었습니다', 'success');
                }
                
                // 즐겨찾기 버튼 상태 업데이트
                const newIsFavorite = !isFavorite;
                
                elements.favoriteArtworkBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="${newIsFavorite ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                    </svg>
                    ${newIsFavorite ? '즐겨찾기 해제' : '즐겨찾기'}
                `;
            } catch (error) {
                console.error('즐겨찾기 오류:', error);
                utils.showToast(error.message || '즐겨찾기 처리 중 오류가 발생했습니다', 'error');
            }
        },
        
        // 작품 다운로드 처리
        handleArtworkDownload(artwork) {
            if (!artwork || !artwork.data) {
                utils.showToast('다운로드할 수 없는 형식입니다', 'error');
                return;
            }
            
            // 데이터 형식 변환
            const artworkData = typeof artwork.data === 'string' ? 
                JSON.parse(artwork.data) : artwork.data;
            
            // 다운로드 데이터 구성
            const downloadData = {
                data: artworkData,
                author: artwork.creator || '익명',
                version: artwork.version || CONFIG.APP_VERSION,
                createdAt: artwork.created_at,
                title: artwork.title
            };
            
            // JSON 데이터 생성
            const jsonData = JSON.stringify(downloadData, null, 2);
            
            // 다운로드 링크 생성
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const fileName = `${artwork.title.replace(/[^a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ_\-]/g, '_')}.val`;
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = fileName;
            
            // 다운로드 실행
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            
            // URL 해제
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
            
            utils.showToast('작품이 다운로드 되었습니다', 'success');
        },
        
        // 작품 불러오기 처리
        handleArtworkLoad(artwork) {
            if (!artwork || !artwork.data) {
                utils.showToast('불러올 수 없는 형식입니다', 'error');
                return;
            }
            
            // 데이터 형식 변환
            const artworkData = typeof artwork.data === 'string' ? 
                JSON.parse(artwork.data) : artwork.data;
            
            // 작품 정보 확인
            if (!artworkData.board) {
                utils.showToast('유효하지 않은 작품 데이터입니다', 'error');
                return;
            }
            
            // 설정 업데이트
            if (artworkData.meta) {
                if (artworkData.meta.rows && artworkData.meta.cols) {
                    settings.emojiRows = artworkData.meta.rows;
                    settings.emojiCols = artworkData.meta.cols;
                }
                
                if (artworkData.meta.cellSize) {
                    settings.cellSize = artworkData.meta.cellSize;
                }
                
                if (artworkData.meta.bgMode) {
                    settings.bgMode = artworkData.meta.bgMode;
                }
                
                if (typeof artworkData.meta.customMode !== 'undefined') {
                    settings.customMode = artworkData.meta.customMode;
                }
                
                if (artworkData.meta.filledEmoji) {
                    settings.filledEmoji = artworkData.meta.filledEmoji;
                }
                
                if (artworkData.meta.emptyEmoji) {
                    settings.emptyEmoji = artworkData.meta.emptyEmoji;
                }
            }
            
            // 설정 저장
            utils.storage.saveSettings(settings);
            
            // 확인 대화상자
            if (!confirm('현재 작업 중인 내용이 모두 삭제됩니다. 계속하시겠습니까?')) {
                return;
            }
            
            // 홈으로 이동
            this.closeArtworkPage();
            if (appState.currentPage === 'gallery') {
                uiManager.galleryManager.hideGalleryPage();
            }
            
            // 캔버스 그리드 재생성
            canvasRenderer.createGrid();
            
            // 데이터 로드
            const success = canvasRenderer.loadBoardData(artworkData);
            
            if (success) {
                utils.showToast(`"${artwork.title}" 작품을 불러왔습니다`, 'success');
            } else {
                utils.showToast('작품 불러오기에 실패했습니다', 'error');
            }
        }
    }
};

// 이벤트 핸들러 설정
function setupEventHandlers() {
    // 사용자 인터페이스 버튼 이벤트 연결
    if (utils.validateElement(elements.drawEraseBtn, 'drawEraseBtn')) {
        elements.drawEraseBtn.addEventListener('click', toggleDrawMode);
    }
    
    if (utils.validateElement(elements.clearBtn, 'clearBtn')) {
        elements.clearBtn.addEventListener('click', clearCanvas);
    }
    
    if (utils.validateElement(elements.brushSizeDownBtn, 'brushSizeDownBtn')) {
        elements.brushSizeDownBtn.addEventListener('click', decreaseBrushSize);
    }
    
    if (utils.validateElement(elements.brushSizeUpBtn, 'brushSizeUpBtn')) {
        elements.brushSizeUpBtn.addEventListener('click', increaseBrushSize);
    }
    
    if (utils.validateElement(elements.saveBtn, 'saveBtn')) {
        elements.saveBtn.addEventListener('click', () => uiManager.modalHandler.showFileModal('save'));
    }
    
    if (utils.validateElement(elements.loadBtn, 'loadBtn')) {
        elements.loadBtn.addEventListener('click', () => uiManager.modalHandler.showFileModal('load'));
    }
    
    if (utils.validateElement(elements.copyBtn, 'copyBtn')) {
        elements.copyBtn.addEventListener('click', copyCanvasToClipboard);
    }
    
    if (utils.validateElement(elements.shareBtn, 'shareBtn')) {
        elements.shareBtn.addEventListener('click', () => uiManager.modalHandler.showShareModal());
    }
    
    if (utils.validateElement(elements.settingsBtn, 'settingsBtn')) {
        elements.settingsBtn.addEventListener('click', () => uiManager.modalHandler.showSettingsModal());
    }
    
    if (utils.validateElement(elements.helpBtn, 'helpBtn')) {
        elements.helpBtn.addEventListener('click', () => utils.showModal(elements.helpModal));
    }
    
    if (utils.validateElement(elements.galleryBtn, 'galleryBtn')) {
        elements.galleryBtn.addEventListener('click', () => uiManager.galleryManager.showGalleryPage());
    }
    
    if (utils.validateElement(elements.exportImportBtn, 'exportImportBtn')) {
        elements.exportImportBtn.addEventListener('click', () => uiManager.modalHandler.showExportImportModal());
    }
    
    // 파일 모달 이벤트
    if (utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn')) {
        elements.fileDeleteBtn.addEventListener('click', () => uiManager.modalHandler.handleFileDelete());
    }
    
    if (utils.validateElement(elements.fileModalCancelBtn, 'fileModalCancelBtn')) {
        elements.fileModalCancelBtn.addEventListener('click', () => utils.hideModal(elements.fileModal));
    }
    
    // 내보내기/가져오기 모달 이벤트
    if (utils.validateElement(elements.exportImportCancelBtn, 'exportImportCancelBtn')) {
        elements.exportImportCancelBtn.addEventListener('click', () => utils.hideModal(elements.exportImportModal));
    }
    
    // 공유 모달 이벤트
    if (utils.validateElement(elements.shareForm, 'shareForm')) {
        elements.shareForm.addEventListener('submit', (e) => {
            e.preventDefault();
            uiManager.modalHandler.handleShare();
        });
    }
    
    if (utils.validateElement(elements.shareModalCancelBtn, 'shareModalCancelBtn')) {
        elements.shareModalCancelBtn.addEventListener('click', () => utils.hideModal(elements.shareModal));
    }
    
    if (utils.validateElement(elements.shareActionBtn, 'shareActionBtn')) {
        elements.shareActionBtn.addEventListener('click', () => uiManager.modalHandler.handleShare());
    }
    
    // 도움말 모달 이벤트
    if (utils.validateElement(elements.helpCloseBtn, 'helpCloseBtn')) {
        elements.helpCloseBtn.addEventListener('click', () => utils.hideModal(elements.helpModal));
    }
    
    if (utils.validateElement(elements.shortcutsBtn, 'shortcutsBtn')) {
        elements.shortcutsBtn.addEventListener('click', () => {
            utils.hideModal(elements.helpModal);
            utils.showModal(elements.shortcutsModal);
        });
    }
    
    if (utils.validateElement(elements.shortcutsCloseBtn, 'shortcutsCloseBtn')) {
        elements.shortcutsCloseBtn.addEventListener('click', () => utils.hideModal(elements.shortcutsModal));
    }
    
    // 갤러리 페이지 이벤트
    if (utils.validateElement(elements.galleryBackBtn, 'galleryBackBtn')) {
        elements.galleryBackBtn.addEventListener('click', () => uiManager.galleryManager.hideGalleryPage());
    }
    
    if (utils.validateElement(elements.galleryTabs, 'galleryTabs')) {
        elements.galleryTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                uiManager.galleryManager.setActiveTab(tabName);
            });
        });
    }
    
    if (utils.validateElement(elements.filterBtn, 'filterBtn') &&
        utils.validateElement(elements.filterMenu, 'filterMenu')) {
        elements.filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            elements.filterMenu.classList.toggle('active');
        });
        
        // 필터 메뉴 외부 클릭 감지
        document.addEventListener('click', (e) => {
            if (!elements.filterBtn.contains(e.target) && !elements.filterMenu.contains(e.target)) {
                elements.filterMenu.classList.remove('active');
            }
        });
    }
    
    if (utils.validateElement(elements.filterItems, 'filterItems')) {
        elements.filterItems.forEach(item => {
            item.addEventListener('click', () => {
                const filterName = item.dataset.filter;
                uiManager.galleryManager.applyFilter(filterName);
                elements.filterMenu.classList.remove('active');
            });
        });
    }
    
    if (utils.validateElement(elements.searchInput, 'searchInput')) {
        elements.searchInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                uiManager.galleryManager.handleSearch();
            }
        });
    }
    
    if (utils.validateElement(elements.refreshGalleryBtn, 'refreshGalleryBtn')) {
        elements.refreshGalleryBtn.addEventListener('click', () => uiManager.galleryManager.loadGalleryItems());
    }
    
    // 작품 상세 페이지 이벤트
    if (utils.validateElement(elements.artworkBackBtn, 'artworkBackBtn')) {
        elements.artworkBackBtn.addEventListener('click', () => uiManager.artworkManager.closeArtworkPage());
    }
    
    // 키보드 단축키 이벤트
    document.addEventListener('keydown', handleKeyboardShortcuts);
    
    // 창 크기 변경 이벤트
    window.addEventListener('resize', handleWindowResize);
    
    // 해시 변경 이벤트
    window.addEventListener('hashchange', handleHashChange);
}

// 그리기/지우기 모드 토글
function toggleDrawMode() {
    appState.isEraserMode = !appState.isEraserMode;
    
    if (elements.drawEraseBtn) {
        if (appState.isEraserMode) {
            elements.drawEraseBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                    <line x1="8" y1="10" x2="16" y2="10"></line>
                    <line x1="8" y1="14" x2="16" y2="14"></line>
                </svg>
                <span class="valorant-text">지우기</span>
            `;
        } else {
            elements.drawEraseBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                    <path d="M2 2l7.586 7.586"></path>
                    <circle cx="11" cy="11" r="2"></circle>
                </svg>
                <span class="valorant-text">그리기</span>
            `;
        }
    }
    
    // 토스트 메시지 표시
    utils.showToast(appState.isEraserMode ? '지우기 모드로 전환했습니다' : '그리기 모드로 전환했습니다', 'info');
}

// 브러시 크기 증가
function increaseBrushSize() {
    if (settings.brushSize < CONFIG.MAX_BRUSH_SIZE) {
        settings.brushSize++;
        updateBrushSizeDisplay();
        utils.storage.saveSettings(settings);
    }
}

// 브러시 크기 감소
function decreaseBrushSize() {
    if (settings.brushSize > CONFIG.MIN_BRUSH_SIZE) {
        settings.brushSize--;
        updateBrushSizeDisplay();
        utils.storage.saveSettings(settings);
    }
}

// 브러시 크기 표시 업데이트
function updateBrushSizeDisplay() {
    if (elements.brushSizeDisplay) {
        elements.brushSizeDisplay.textContent = settings.brushSize;
    }
    
    // 커서 크기 업데이트
    if (elements.brushCursor) {
        const lastPosition = appState.lastMousePosition;
        if (lastPosition) {
            canvasRenderer.updateBrushCursor(lastPosition.x, lastPosition.y);
        }
    }
}

// 캔버스 지우기
function clearCanvas() {
    if (confirm('모든 내용을 지우시겠습니까?')) {
        canvasRenderer.clearCanvas();
    }
}

// 캔버스 복사
function copyCanvasToClipboard() {
    // 이모지 텍스트로 변환
    const asciiArt = canvasRenderer.getBoardAsAscii();
    
    // 클립보드에 복사
    navigator.clipboard.writeText(asciiArt)
        .then(() => {
            utils.showToast('이모지 아트가 클립보드에 복사되었습니다', 'success');
        })
        .catch(err => {
            console.error('클립보드 복사 오류:', err);
            utils.showToast('클립보드 복사 중 오류가 발생했습니다', 'error');
            
            // 폴백: 텍스트 영역에 복사
            const textarea = document.createElement('textarea');
            textarea.value = asciiArt;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                document.execCommand('copy');
                utils.showToast('이모지 아트가 클립보드에 복사되었습니다', 'success');
            } catch (e) {
                utils.showToast('클립보드 복사에 실패했습니다', 'error');
                console.error('클립보드 복사 오류:', e);
            }
            
            document.body.removeChild(textarea);
        });
}

// 설정 적용
function applySettings() {
    if (!utils.validateElement(elements.settingsModal, 'settingsModal') ||
        !utils.validateElement(elements.cellSizeRange, 'cellSizeRange') ||
        !utils.validateElement(elements.brushSizeRange, 'brushSizeRange') ||
        !utils.validateElement(elements.bgModeSwitch, 'bgModeSwitch') ||
        !utils.validateElement(elements.customModeSwitch, 'customModeSwitch') ||
        !utils.validateElement(elements.filledEmojiInput, 'filledEmojiInput') ||
        !utils.validateElement(elements.emptyEmojiInput, 'emptyEmojiInput')) {
        return;
    }
    
    // 설정 값 가져오기
    const cellSize = parseInt(elements.cellSizeRange.value);
    const brushSize = parseInt(elements.brushSizeRange.value);
    const bgMode = elements.bgModeSwitch.checked ? 'transparent' : 'rectangle';
    const customMode = elements.customModeSwitch.checked;
    
    // 이모지 값 가져오기
    let filledEmoji = elements.filledEmojiInput.value;
    let emptyEmoji = elements.emptyEmojiInput.value;
    
    // 이모지 유효성 검사
    if (customMode) {
        if (!filledEmoji || filledEmoji.length === 0) {
            filledEmoji = '■';
        }
        
        if (!emptyEmoji || emptyEmoji.length === 0) {
            emptyEmoji = '□';
        }
        
        // 이모지 길이 제한
        if (filledEmoji.length > 2) {
            filledEmoji = filledEmoji.slice(0, 2);
        }
        
        if (emptyEmoji.length > 2) {
            emptyEmoji = emptyEmoji.slice(0, 2);
        }
    }
    
    // 설정 업데이트
    settings.cellSize = cellSize;
    settings.brushSize = brushSize;
    settings.bgMode = bgMode;
    settings.customMode = customMode;
    settings.filledEmoji = filledEmoji;
    settings.emptyEmoji = emptyEmoji;
    
    // 설정 저장
    utils.storage.saveSettings(settings);
    
    // 브러시 크기 표시 업데이트
    updateBrushSizeDisplay();
    
    // 캔버스 재생성
    canvasRenderer.createGrid();
    
    // 모달 닫기
    utils.hideModal(elements.settingsModal);
    
    // 토스트 메시지 표시
    utils.showToast('설정이 저장되었습니다', 'success');
}

// 키보드 단축키 처리
function handleKeyboardShortcuts(e) {
    // 모달이 열려있는 경우 단축키 처리하지 않음
    if (document.querySelector('.modal.show')) {
        return;
    }
    
    // 갤러리나 작품 상세 페이지에서는 일부 단축키만 처리
    if (appState.currentPage !== 'home') {
        if (e.key === 'Escape') {
            if (appState.currentPage === 'artwork') {
                uiManager.artworkManager.closeArtworkPage();
            } else if (appState.currentPage === 'gallery') {
                uiManager.galleryManager.hideGalleryPage();
            }
        }
        return;
    }
    
    // 단축키 처리
    switch (e.key) {
        case 'q':
        case 'Q':
            toggleDrawMode();
            break;
        
        case '+':
        case '=':
            increaseBrushSize();
            break;
        
        case '-':
        case '_':
            decreaseBrushSize();
            break;
        
        case 'Delete':
            clearCanvas();
            break;
        
        case 's':
        case 'S':
            if (e.ctrlKey) {
                e.preventDefault();
                uiManager.modalHandler.showFileModal('save');
            }
            break;
        
        case 'o':
        case 'O':
            if (e.ctrlKey) {
                e.preventDefault();
                uiManager.modalHandler.showFileModal('load');
            }
            break;
        
        case 'c':
        case 'C':
            if (e.ctrlKey) {
                e.preventDefault();
                copyCanvasToClipboard();
            }
            break;
        
        case 'e':
        case 'E':
            if (e.ctrlKey) {
                e.preventDefault();
                uiManager.modalHandler.showExportImportModal();
            }
            break;
        
        case 'F1':
            e.preventDefault();
            utils.showModal(elements.helpModal);
            break;
        
        case 'F2':
            e.preventDefault();
            uiManager.modalHandler.showSettingsModal();
            break;
    }
}

// 창 크기 변경 처리
function handleWindowResize() {
    // 브러시 커서 위치 업데이트
    if (appState.lastMousePosition) {
        canvasRenderer.updateBrushCursor(appState.lastMousePosition.x, appState.lastMousePosition.y);
    }
    
    // 현재 작품 미리보기 업데이트
    if (appState.currentPage === 'artwork' && appState.currentArtwork) {
        uiManager.artworkManager.createArtworkPreview(appState.currentArtwork);
    }
}

// URL 해시 변경 처리
function handleHashChange() {
    const hash = window.location.hash.substring(1);
    
    if (hash) {
        // 작품 ID가 있으면 작품 상세 페이지 열기
        uiManager.artworkManager.openArtworkPage(hash);
    } else if (appState.currentPage === 'artwork') {
        // 해시가 없고 현재 작품 페이지인 경우 닫기
        uiManager.artworkManager.closeArtworkPage();
    }
}

// VALORANT 폰트 적용
function applyValorantFont() {
    const fontCheck = setInterval(() => {
        try {
            if (document.fonts.check('12px VALORANT')) {
                clearInterval(fontCheck);
                
                // 폰트가 로드된 경우 처리
                const valorantElements = document.querySelectorAll('.valorant-text');
                valorantElements.forEach(el => {
                    el.style.opacity = '1';
                });
            }
        } catch (error) {
            console.error('폰트 확인 오류:', error);
            clearInterval(fontCheck);
        }
    }, 100);
    
    // 일정 시간 후 체크 중단
    setTimeout(() => {
        clearInterval(fontCheck);
    }, 5000);
}

// DOM 엘리먼트 수정 및 접근성 개선
function setupAccessibility() {
    // 비밀번호 폼 접근성 개선 - 숨겨진 사용자명 필드 추가
    const deleteAccountForm = document.getElementById('delete-account-form');
    if (deleteAccountForm) {
        // 이미 추가되었는지 확인
        if (!deleteAccountForm.querySelector('input[type="hidden"][name="username"]')) {
            const hiddenUsernameField = document.createElement('input');
            hiddenUsernameField.type = 'hidden';
            hiddenUsernameField.id = 'deleteHiddenUsername';
            hiddenUsernameField.name = 'username';
            hiddenUsernameField.value = api.getUsername() || '';
            deleteAccountForm.appendChild(hiddenUsernameField);
            elements.deleteHiddenUsername = hiddenUsernameField;
        }
    }
    
    // ARIA 속성 추가
    const passwordInputs = document.querySelectorAll('input[type="password"]');
    passwordInputs.forEach(input => {
        if (!input.getAttribute('aria-required')) {
            input.setAttribute('aria-required', 'true');
        }
        
        // 해당 입력 필드의 레이블 연결
        const labelId = input.id + 'Label';
        const labelElement = document.querySelector(`label[for="${input.id}"]`);
        if (labelElement && !labelElement.id) {
            labelElement.id = labelId;
            input.setAttribute('aria-labelledby', labelId);
        }
    });
    
    // 버튼 접근성 개선
    const buttons = document.querySelectorAll('button');
    buttons.forEach(button => {
        if (!button.getAttribute('aria-label') && !button.textContent.trim()) {
            // 내부 SVG나 아이콘만 있는 버튼에 aria-label 추가
            if (button.querySelector('svg')) {
                const title = button.getAttribute('title') || '버튼';
                button.setAttribute('aria-label', title);
            }
        }
    });
}

// 초기화 및 이벤트 핸들러 설정
async function initialize() {
    // 도메인 검증
    if (!utils.validateDomain()) {
        // 도메인 검증 실패 시 더 이상 진행하지 않음
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        return;
    }
    
    // 보안 기능 설정
    setupSecurity();
    
    // 로딩 화면 표시
    if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
        elements.loadingScreen.style.display = 'flex';
    }
    
    try {
        // Supabase 클라이언트 초기화
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // API 초기화
        await api.init();
        
        // 작가명이 설정되어 있는지 확인
        const username = api.getUsername();
        const isLoggedIn = api.isAuthenticated();
        
        if (username && isLoggedIn) {
            // 로그인 상태이면 바로 시작
            await startApp();
        } else {
            // 로그인 상태가 아니면 로그인 모달 표시
            setTimeout(() => {
                if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
                    elements.loadingScreen.style.display = 'none';
                }
                
                // 인증 모달 표시
                showAuthModal();
            }, 1000);
        }
    } catch (error) {
        console.error('초기화 오류:', error);
        
        // 로딩 화면 숨기기
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        
        utils.showToast('초기화 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.', 'error');
    }
}

// 도메인 검증
function validateDomain() {
    // 개발 환경에서는 무시
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        appState.secureDomainValidated = true;
        return true;
    }
    
    // 허용된 도메인 목록 확인
    const isValidDomain = CONFIG.SECURITY.ALLOWED_DOMAINS.includes(window.location.hostname);
    
    if (!isValidDomain) {
        // 유효하지 않은 도메인에서 실행 방지
        document.body.innerHTML = `
            <div style="display: flex; justify-content: center; align-items: center; height: 100vh; flex-direction: column; background-color: #0f1923; color: #ece8e1; font-family: Arial, sans-serif;">
                <div style="background-color: #1a242d; padding: 2rem; border-radius: 8px; text-align: center; max-width: 500px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);">
                    <h1 style="color: #ff4655; margin-bottom: 1rem;">보안 경고</h1>
                    <p style="margin-bottom: 1rem;">이 애플리케이션은 신뢰할 수 있는 도메인에서만 실행할 수 있습니다.</p>
                    <p>공식 사이트로 이동하세요: <a href="https://valpaint.art" style="color: #ff4655; text-decoration: none;">https://valpaint.art</a></p>
                </div>
            </div>
        `;
        console.error('보안 경고: 허용되지 않은 도메인에서 실행 시도');
        return false;
    }
    
    // 프로토콜 검증 (HTTPS 강제)
    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        // HTTPS로 리디렉션
        window.location.href = 'https://' + window.location.hostname + window.location.pathname + window.location.search;
        return false;
    }
    
    appState.secureDomainValidated = true;
    return true;
}

// 보안 기능 설정
function setupSecurity() {
    // 이미 초기화되었는지 확인
    if (appState.security.initialized) {
        return;
    }
    
    // 브라우저 보안 기능 설정
    utils.setupBrowserSecurity();
    
    // CSRF 토큰 생성
    utils.generateCSRFToken();
    
    // 속도 제한 초기화
    appState.rateLimits = {
        loginAttempts: 0,
        loginLockoutUntil: 0,
        apiRequests: 0,
        apiWindowStart: Date.now()
    };
    
    // 초기화 완료 표시
    appState.security.initialized = true;
}

// 사용자 계정 정보 업데이트
function updateUserAccountInfo() {
    // 삭제 계정 폼 사용자명 업데이트
    if (elements.deleteUsername) {
        elements.deleteUsername.value = api.getUsername() || '';
    }
    
    if (elements.deleteHiddenUsername) {
        elements.deleteHiddenUsername.value = api.getUsername() || '';
    }
    
    // 계정 설정 폼 사용자명 업데이트
    if (elements.accountUsername) {
        elements.accountUsername.value = api.getUsername() || '';
    }
}

// 앱 시작 함수
async function startApp() {
    try {
        // 로딩 화면 숨기기
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        
        // 사용자 이름 표시 업데이트
        if (utils.validateElement(elements.userDisplayName, 'userDisplayName')) {
            elements.userDisplayName.textContent = api.getUsername() || '비회원';
        }
        
        // 비회원 모드 배너 표시/숨기기
        if (utils.validateElement(elements.guestModeBanner, 'guestModeBanner')) {
            elements.guestModeBanner.style.display = appState.isGuestMode ? 'flex' : 'none';
        }
        
        // 저장된 설정 불러오기
        const savedSettings = utils.storage.loadSettings();
        if (savedSettings) {
            Object.assign(settings, savedSettings);
        }
        
        // 캔버스 초기화
        canvasRenderer.initCanvas();
        
        // 이벤트 핸들러 설정
        setupEventHandlers();
        
        // 접근성 개선
        setupAccessibility();
        
        // URL 해시 확인
        const hash = window.location.hash.substring(1);
        if (hash) {
            // 작품 ID가 있으면 작품 상세 페이지 열기
            uiManager.artworkManager.openArtworkPage(hash);
        }
        
        // VALORANT 폰트 적용
        applyValorantFont();
        
        // 개선된 토스트 메시지
        utils.showToast('VALPAINT가 준비되었습니다!', 'success');
        
    } catch (error) {
        console.error('앱 시작 오류:', error);
        utils.showToast('앱 시작 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.', 'error');
    }
}

// 애플리케이션 시작
document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
