<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valpaint</title>
    <link href="https://fonts.cdnfonts.com/css/valorant" rel="stylesheet" media="print" onload="this.media='all'">
    <!-- 스크립트 최적화 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer></script>
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>

    <!-- Supabase 클라이언트 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- reCAPTCHA v2 추가 -->
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>
    <style>
        :root {
            --main-bg: #0f1923;
            --secondary-bg: #1a242d;
            --accent-color: #ff4655;
            --accent-hover: #ff6b76;
            --text-color: #ece8e1;
            --text-muted: #8b978f;
            --border-color: #1f2326;
            --btn-bg: #232c34;
            --btn-hover: #2b3842;
            --cell-active: #ff4655;
            --cell-empty: #1a242d;
            --cell-border: #2d3844;
            --canvas-bg: #0f1923;
            --modal-bg: rgba(15, 25, 35, 0.9);
            --valorant-font: 'VALORANT', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Tahoma', sans-serif;
            color: var(--text-color);
        }
        
        .valorant-text {
            font-family: var(--valorant-font);
            letter-spacing: 1px;
        }

        body {
            background-color: var(--main-bg);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 25%, rgba(255, 70, 85, 0.03) 0%, transparent 25%),
                radial-gradient(circle at 70% 75%, rgba(255, 70, 85, 0.03) 0%, transparent 25%);
            z-index: -1;
        }

        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--secondary-bg);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .logo {
            font-family: var(--valorant-font);
            font-size: 2rem;
            color: var(--accent-color);
            text-shadow: 0 0 5px rgba(255, 70, 85, 0.5);
            cursor: pointer;
            text-decoration: none;
        }

        .toolbar {
            padding: 0.75rem 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 15px;
        }

        .tool-label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .btn {
            padding: 0.5rem 1rem;
            background-color: var(--btn-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            min-width: 40px;
            text-align: center;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background-color: var(--btn-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn-accent {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            font-family: var(--valorant-font);
        }

        .btn-accent:hover {
            background-color: var(--accent-hover);
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .user-profile {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: var(--secondary-bg);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .user-profile:hover {
            background-color: var(--btn-hover);
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }

        .btn:active::after {
            animation: ripple 0.6s ease-out;
        }

        @keyframes ripple {
            0% {
                opacity: 1;
                transform: scale(0, 0) translate(-50%, -50%);
            }
            100% {
                opacity: 0;
                transform: scale(20, 20) translate(-50%, -50%);
            }
        }

        .btn-group {
            display: flex;
        }

        .btn-group .btn {
            border-radius: 0;
            border-right: none;
        }

        .btn-group .btn:first-child {
            border-top-left-radius: 2px;
            border-bottom-left-radius: 2px;
        }

        .btn-group .btn:last-child {
            border-top-right-radius: 2px;
            border-bottom-right-radius: 2px;
            border-right: 1px solid var(--border-color);
        }

        .btn-group .btn.active {
            background-color: var(--accent-color);
            color: #fff;
        }

        .btn-round {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .btn-icon {
            display: flex;
            align-items: center;
        }

        .btn-icon svg {
            margin-right: 5px;
            width: 16px;
            height: 16px;
        }

        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 1rem;
            background-color: var(--main-bg);
        }

        .canvas-container {
            position: relative;
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            background-color: var(--canvas-bg);
            max-width: 100%;
            max-height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: box-shadow 0.3s ease;
        }
        
        .canvas-container:hover {
            box-shadow: 0 0 30px rgba(255, 70, 85, 0.1);
        }

        .drawing-canvas {
            display: grid;
            background-color: var(--canvas-bg);
            margin: 0 auto;
        }

        .emoji-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid var(--cell-border);
            background-color: var(--cell-empty);
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.2s;
            user-select: none;
        }

        .emoji-cell:hover {
            background-color: rgba(45, 56, 68, 0.6);
            transform: scale(1.05);
            z-index: 1;
        }

        .emoji-cell.active {
            background-color: var(--cell-active);
            color: white;
            transform: scale(1);
            animation: cellActivate 0.3s ease;
        }
        
        @keyframes cellActivate {
            0% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .emoji-cell.transparent {
            background-color: transparent;
            border-color: rgba(45, 56, 68, 0.3);
        }
        
        .emoji-cell.active.transparent {
            background-color: var(--cell-active);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            z-index: 100;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .modal.show {
            opacity: 1;
            display: flex;
        }

        .modal-content {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 1.5rem;
            width: 480px;
            max-width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        .modal-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            font-size: 1.2rem;
        }

        .modal-close {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1.5rem;
            line-height: 1;
            transition: color 0.2s;
        }
        
        .modal-close:hover {
            color: var(--accent-color);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }

        .form-control {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--btn-bg);
            color: var(--text-color);
            border-radius: 2px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        .form-control:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 70, 85, 0.3); /* 그림자 효과 강화 */
        }
        .btn:focus-visible {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }
        .form-range {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            background: var(--main-bg);
            border-radius: 5px;
            outline: none;
        }

        .form-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .form-range::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .file-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            background-color: var(--main-bg);
        }

        .file-item {
            padding: 0.5rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-item:hover {
            background-color: var(--btn-bg);
        }

        .file-item.selected {
            background-color: var(--btn-hover);
        }

        .file-item-actions {
            display: flex;
            gap: 5px;
        }

        .file-preview {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--main-bg);
            overflow: hidden;
            font-family: monospace;
            max-height: 150px;
            margin-bottom: 1rem;
        }

        /* 온라인 갤러리 페이지 스타일 */
        .page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--main-bg);
            z-index: 100;
            overflow-y: auto;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .page.active {
            display: block;
            opacity: 1;
        }

        .page-header {
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--secondary-bg);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .page-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .page-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            font-size: 1.5rem;
        }

        .back-button {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .back-button:hover {
            color: var(--accent-color);
        }

        .gallery-layout {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .gallery-item {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .gallery-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .gallery-preview {
            height: 200px;
            background-color: var(--main-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            padding: 10px;
            overflow: hidden;
        }

        .gallery-info {
            padding: 15px;
        }

        .gallery-title {
            font-weight: bold;
            margin-bottom: 8px;
            word-break: break-all;
            font-size: 1.1rem;
        }

        .gallery-creator {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .gallery-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 10px;
        }
        
        .gallery-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }
        
        .gallery-tag {
            background-color: var(--btn-bg);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
        }
        
        .gallery-favorite {
            cursor: pointer;
            transition: color 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .gallery-favorite:hover {
            color: var(--accent-color);
        }
        
        .gallery-favorite.active {
            color: var(--accent-color);
        }

        /* 작품 상세 페이지 */
        .artwork-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .artwork-title {
            font-family: var(--valorant-font);
            font-size: 1.8rem;
            color: var(--accent-color);
        }

        .artwork-preview {
            padding: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            margin-bottom: 20px;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .artwork-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .artwork-section {
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
        }

        .artwork-section-title {
            color: var(--accent-color);
            margin-bottom: 10px;
            font-family: var(--valorant-font);
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .artwork-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .share-form {
            margin-bottom: 20px;
        }

        .share-option {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .share-option input[type="radio"] {
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            .header, .page-header {
                padding: 0.5rem 1rem;
            }

            .toolbar {
                padding: 0.5rem;
                overflow-x: auto;
                justify-content: flex-start;
            }

            .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
                min-width: 30px;
            }

            .btn-icon svg {
                margin-right: 2px;
                width: 14px;
                height: 14px;
            }

            .tool-group {
                margin-right: 6px;
                gap: 4px;
            }

            .tool-label {
                display: none;
            }

            .gallery-layout {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            }
            
            .gallery-preview {
                height: 120px;
            }
            
            .user-profile {
                padding: 4px 8px;
            }
            
            .user-profile span {
                max-width: 80px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            .main-content {
                padding: 0.5rem;
            }
            
            .emoji-cell {
                font-size: 1.2rem;
            }
            
            .canvas-container {
                max-width: 95%;
                max-height: 90%;
            }
            
            .modal-content {
                padding: 1rem;
                width: 95%;
                max-height: 80vh;
            }
            
            .btn-round {
                width: 28px;
                height: 28px;
            }

            .artwork-details {
                grid-template-columns: 1fr;
            }
        }

        /* 더 작은 화면 (모바일 작은 화면) */
        @media (max-width: 480px) {
            .gallery-layout {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
                gap: 10px;
            }
            
            .toolbar {
                flex-wrap: nowrap;
                overflow-x: auto;
                justify-content: flex-start;
                padding: 0.4rem;
                gap: 5px;
            }
            
            .btn-icon span {
                display: none;
            }
            
            .btn-icon svg {
                margin-right: 0;
            }
            
            .btn {
                padding: 0.3rem;
                min-width: 44px;
            }
            .auth-container {
            max-width: 100%;
            padding: 20px 15px;
            }
            .tool-group {
                margin-right: 3px;
                gap: 3px;
            }
            
            .logo {
                font-size: 1.5rem;
            }
            
            .header, .page-header {
                padding: 0.4rem 0.8rem;
            }
        }

        .shortcut {
            display: inline-block;
            background-color: var(--secondary-bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
            margin-left: 5px;
        }

        .brush-cursor {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            border: 2px solid var(--accent-color);
            transform: translate(-50%, -50%);
            z-index: 1000;
            transition: width 0.2s, height 0.2s;
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 70, 85, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .d-flex {
            display: flex;
        }

        .align-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .g-10 {
            gap: 10px;
        }

        .mb-10 {
            margin-bottom: 10px;
        }

        .text-center {
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: var(--secondary-bg);
            color: var(--text-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--border-color);
            word-wrap: break-word;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 4px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            color: white;
            font-family: var(--valorant-font);
            letter-spacing: 1px;
            animation: toastIn 0.3s, toastOut 0.3s 2.7s forwards;
            max-width: 350px;
            transform-origin: right bottom;
            position: relative;
            overflow: hidden;
            background-color: rgba(15, 25, 35, 0.95);
            border-left: 4px solid #1e90ff;
        }
        
        .toast::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 4px;
        }

        .toast.success {
            border-left-color: #00c853;
        }
        
        .toast.success::before {
            background: #00c853;
        }

        .toast.error {
            border-left-color: #ff4655;
        }
        
        .toast.error::before {
            background: #ff4655;
        }

        .toast.info {
            border-left-color: #1e90ff;
        }
        
        .toast.info::before {
            background: #1e90ff;
        }

        @keyframes toastIn {
            from { 
                opacity: 0; 
                transform: translateX(20px) scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0) scale(1); 
            }
        }

        @keyframes toastOut {
            from { 
                opacity: 1; 
                transform: translateX(0) scale(1); 
            }
            to { 
                opacity: 0; 
                transform: translateX(20px) scale(0.8); 
            }
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--main-bg);
            transition: .4s;
            border-radius: 24px;
            border: 1px solid var(--border-color);
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --main-bg: #0f1923;
                --secondary-bg: #1a242d;
                --text-color: #ece8e1;
                /* 기존 다크 테마와 동일 */
            }
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 3px;
            background-color: var(--text-muted);
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
            background-color: white;
        }
        
        .favorite-btn {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .favorite-btn:hover {
            transform: scale(1.1);
            color: var(--accent-color);
        }
        
        .favorite-btn.active {
            color: var(--accent-color);
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .empty-state svg {
            margin-bottom: 15px;
            opacity: 0.7;
        }
        
        .empty-state-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .empty-state-text {
            font-size: 0.9rem;
            max-width: 300px;
            margin: 0 auto;
        }

        /* 개선된 토스트 메시지 스타일 */
        .toast {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            margin-bottom: 12px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: white;
            font-family: var(--valorant-font);
            letter-spacing: 1px;
            animation: toastIn 0.4s, toastOut 0.4s 3.6s forwards;
            max-width: 350px;
            transform-origin: right bottom;
            position: relative;
            overflow: hidden;
            background-color: rgba(15, 25, 35, 0.98);
        }

        .toast-icon {
            margin-right: 12px;
        }

        .toast-content {
            flex: 1;
        }

        /* 파일 저장/로드 개선 */
        .format-selector {
            display: flex;
            margin-bottom: 10px;
            gap: 10px;
        }

        .format-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--btn-bg);
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            background-color: var(--btn-hover);
        }

        .format-option.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        
        /* 경고 메시지 스타일 */
        .warning-box {
            background-color: rgba(255, 70, 85, 0.1);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 12px 16px;
            margin: 15px 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .warning-box svg {
            vertical-align: middle;
            margin-right: 8px;
        }
        
        .warning-title {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        
        .checkbox-wrapper {
            margin-top: 10px;
            display: flex;
            align-items: center;
        }
        
        .checkbox-wrapper input {
            margin-right: 8px;
        }
        
        /* CAPTCHA 컨테이너 */
        .captcha-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* 사용자 메뉴 드롭다운 */
        .user-dropdown {
            position: relative;
        }
        
        .user-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            width: 200px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 50;
            display: none;
            overflow: hidden;
        }
        
        .user-dropdown-menu.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-dropdown-item {
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .user-dropdown-item:hover {
            background-color: var(--btn-hover);
        }
        
        .user-dropdown-item svg {
            width: 16px;
            height: 16px;
        }
        
        .user-dropdown-divider {
            height: 1px;
            background-color: var(--border-color);
            margin: 5px 0;
        }
        
        .delete-account-btn {
            color: var(--accent-color);
        }
        
        /* 캡차 버튼 커스텀 스타일 */
        .custom-captcha {
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }

        /* 탭 내비게이션 */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-bottom: none;
            margin-right: 5px;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
            transition: all 0.2s;
            font-family: var(--valorant-font);
        }
        
        .tab:hover {
            background-color: var(--btn-hover);
        }

        .tab.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        /* 검색 바 */
        .search-container {
            position: relative;
            max-width: 300px;
            margin-bottom: 20px;
        }

        .search-container svg {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .search-input {
            padding: 10px 10px 10px 35px;
            width: 100%;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            color: var(--text-color);
            border-radius: 4px;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(255, 70, 85, 0.2);
        }

        /* 필터 드롭다운 */
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 8px 12px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-button:hover {
            background-color: var(--btn-hover);
        }

        .filter-menu {
            position: absolute;
            top: 100%;
            right: 0;
            min-width: 180px;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: none;
        }

        .filter-menu.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        .filter-item {
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .filter-item:hover {
            background-color: var(--btn-hover);
        }

        .filter-item.active {
            color: var(--accent-color);
        }

        /* 페이지네이션 */
        .pagination {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            gap: 5px;
        }

        .pagination-item {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination-item:hover {
            background-color: var(--btn-hover);
        }

        .pagination-item.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        /* 로그인/회원가입 스타일 */
        .auth-container {
            max-width: 400px;
            margin: 40px auto;
            background-color: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .auth-tab {
            flex: 1;
            text-align: center;
            padding: 10px;
            cursor: pointer;
            font-family: var(--valorant-font);
            transition: all 0.2s;
        }

        .auth-tab.active {
            color: var(--accent-color);
            border-bottom: 2px solid var(--accent-color);
        }

        .auth-form {
            margin-bottom: 20px;
        }

        .auth-form-footer {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .guest-button {
            margin-top: 10px;
            text-align: center;
        }

        /* 비회원 모드 배너 */
        .guest-mode-banner {
            background-color: rgba(255, 70, 85, 0.2);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: var(--valorant-font);
        }

        .guest-mode-text {
            font-size: 0.9rem;
        }

        /* 작품 상세 페이지 예쁜 스타일 */
        .artwork-container {
            max-width: 1000px;
            margin: 20px auto;
            background-color: var(--secondary-bg);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
        }

        .artwork-image {
            min-height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--main-bg);
            padding: 30px;
            border-bottom: 1px solid var(--border-color);
        }

        .artwork-meta {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .artwork-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        .artwork-info-section {
            background-color: var(--main-bg);
            border-radius: 4px;
            padding: 15px;
        }

        .artwork-info-title {
            font-family: var(--valorant-font);
            color: var(--accent-color);
            margin-bottom: 10px;
            font-size: 1rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .artwork-info-content {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .artwork-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px;
        }

        .artwork-action {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <h1 class="valorant-text" style="color: var(--accent-color); font-size: 3rem; margin-bottom: 20px;">VALPAINT</h1>
            <div class="spinner" style="width: 50px; height: 50px; margin-bottom: 20px;"></div>
            <p>로딩 중...</p>
        </div>
    </div>

    <!-- 인증 모달 (로그인/회원가입) -->
    <div id="auth-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT에 오신 것을 환영합니다!</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="auth-tabs">
                    <div class="auth-tab active" data-tab="login">로그인</div>
                    <div class="auth-tab" data-tab="register">회원가입</div>
                </div>
                
                <!-- 로그인 폼 -->
                <form id="login-form" class="auth-form">
                    <div class="form-group">
                        <label class="form-label" for="loginUsername">작가명</label>
                        <input type="text" class="form-control" id="loginUsername" placeholder="작가명을 입력하세요" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">비밀번호</label>
                        <input type="password" class="form-control" id="loginPassword" placeholder="비밀번호를 입력하세요" autocomplete="current-password" required>

                    </div>
                    <button type="submit" class="btn btn-accent" style="width: 100%;">로그인</button>
                </form>
                
                <!-- 회원가입 폼 -->
                <form id="register-form" class="auth-form" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">작가명</label>
                        <input type="text" class="form-control" id="registerUsername" placeholder="사용할 작가명을 입력하세요" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">비밀번호</label>
                        <input type="password" class="form-control" id="registerPassword" placeholder="간단한 비밀번호를 입력하세요" autocomplete="new-password" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">비밀번호 확인</label>
                        <input type="password" class="form-control" id="registerPasswordConfirm" placeholder="비밀번호를 다시 입력하세요" autocomplete="new-password" required>
                    </div>
                    
                    <!-- 경고 메시지 추가 -->
                    <div class="warning-box">
                        <div class="warning-title">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                                <line x1="12" y1="9" x2="12" y2="13"></line>
                                <line x1="12" y1="17" x2="12.01" y2="17"></line>
                            </svg>
                            <span>중요 법적 고지사항</span>
                        </div>
                        <p>이 사이트 사용으로 인한 라이엇 계정의 제재는 절대 책임지지 않습니다. 사용으로 인한 제재, 경고, 법적 조치는 모두 사용자의 책임입니다.</p>
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="acceptTerms" required>
                            <label for="acceptTerms">위 내용을 이해하고 동의합니다</label>
                        </div>
                    </div>
                    
                    <button type="submit" class="btn btn-accent" style="width: 100%;">회원가입</button>
                </form>
                
                <div class="guest-button">
                    <button id="guest-mode-btn" class="btn">비회원으로 계속하기</button>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- 헤더 -->
        <header class="header">
            <a href="#" class="logo valorant-text">VALPAINT</a>
            <div class="d-flex align-center g-10">
                <!-- 비회원 모드 배너 -->
                <div id="guest-mode-banner" class="guest-mode-banner" style="display: none;">
                    <div class="guest-mode-text">비회원 모드 - 갤러리와 공유 기능이 제한됩니다</div>
                    <button id="guest-login-btn" class="btn btn-accent">로그인</button>
                </div>
                
                <div class="user-dropdown">
                    <div class="user-profile" id="userProfileBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                        <span id="userDisplayName">작가명</span>
                    </div>
                    <div class="user-dropdown-menu" id="userDropdownMenu">
                        <div class="user-dropdown-item" id="userSettingsBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                            <span>계정 설정</span>
                        </div>
                        <div class="user-dropdown-divider"></div>
                        <div class="user-dropdown-item delete-account-btn" id="deleteAccountBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                            <span>계정 삭제</span>
                        </div>
                    </div>
                </div>
                <button id="galleryBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                        <polyline points="9 22 9 12 15 12 15 22"></polyline>
                    </svg>
                    <span class="valorant-text">갤러리</span>
                </button>
                <button id="settingsBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    <span class="valorant-text">설정</span>
                </button>
                <button id="helpBtn" class="btn btn-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    <span class="valorant-text">도움말</span>
                </button>
            </div>
        </header>

        <!-- 도구바 -->
        <div class="toolbar">
            <div class="tool-group">
                <span class="tool-label">도구:</span>
                <button id="drawEraseBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                        <path d="M2 2l7.586 7.586"></path>
                        <circle cx="11" cy="11" r="2"></circle>
                    </svg>
                    <span class="valorant-text">그리기</span>
                    <span class="tooltip-text">단축키: Q</span>
                </button>
                <button id="clearBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="8" y1="10" x2="16" y2="10"></line>
                        <line x1="8" y1="14" x2="16" y2="14"></line>
                    </svg>
                    <span class="valorant-text">지우기</span>
                    <span class="tooltip-text">단축키: Delete</span>
                </button>
            </div>

            <div class="tool-group" id="brushSizeGroup">
                <span class="tool-label">브러시:</span>
                <button id="brushSizeDownBtn" class="btn btn-round tooltip">
                    -
                    <span class="tooltip-text">단축키: -</span>
                </button>
                <span id="brushSizeDisplay" class="tool-label">1</span>
                <button id="brushSizeUpBtn" class="btn btn-round tooltip">
                    +
                    <span class="tooltip-text">단축키: +</span>
                </button>
            </div>

            <div class="tool-group">
                <button id="saveBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    <span class="valorant-text">저장</span>
                    <span class="tooltip-text">단축키: Ctrl+S</span>
                </button>
                <button id="loadBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span class="valorant-text">불러오기</span>
                    <span class="tooltip-text">단축키: Ctrl+O</span>
                </button>
                <button id="exportImportBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 17l5-5-5-5"></path>
                        <path d="M8 7l-5 5 5 5"></path>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    <span class="valorant-text">내보내기/가져오기</span>
                    <span class="tooltip-text">단축키: Ctrl+E</span>
                </button>
                <button id="copyBtn" class="btn btn-icon tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                    <span class="valorant-text">복사</span>
                    <span class="tooltip-text">단축키: Ctrl+C</span>
                </button>
                <button id="shareBtn" class="btn btn-icon btn-accent">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="18" cy="5" r="3"></circle>
                        <circle cx="6" cy="12" r="3"></circle>
                        <circle cx="18" cy="19" r="3"></circle>
                        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                    </svg>
                    <span class="valorant-text">온라인 공유</span>
                </button>
            </div>
        </div>

        <!-- 메인 콘텐츠 영역 -->
        <div class="main-content">
            <div class="canvas-container">
                <div id="drawingCanvas" class="drawing-canvas"></div>
            </div>
        </div>
    </div>

    <!-- 계정 설정 모달 -->
    <div id="userSettingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">계정 설정</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="account-settings-form">
                    <div class="form-group">
                        <label class="form-label">작가명</label>
                        <input type="text" class="form-control" id="accountUsername" placeholder="작가명 입력" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">현재 비밀번호</label>
                        <input type="password" class="form-control" id="accountCurrentPassword" placeholder="현재 비밀번호 입력" autocomplete="current-password" required>

                    </div>
                    <div class="form-group">
                        <label class="form-label">새 비밀번호 (선택사항)</label>
                        <input type="password" class="form-control" id="accountNewPassword" placeholder="변경을 원하시면 입력하세요" autocomplete="new-password">

                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="accountCancelBtn" class="btn">취소</button>
                <button id="accountSaveBtn" class="btn btn-accent">저장</button>
            </div>
        </div>
    </div>

    <!-- 계정 삭제 모달 -->
    <div id="deleteAccountModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">계정 삭제</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="warning-box">
                    <div class="warning-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        <span>주의: 이 작업은 되돌릴 수 없습니다</span>
                    </div>
                    <p>계정을 삭제하면 다음 항목이 영구적으로 삭제됩니다:</p>
                    <ul style="margin-top: 10px; margin-left: 20px;">
                        <li>모든 온라인 공유 작품</li>
                        <li>로컬 저장 데이터 (즐겨찾기, 설정 등)</li>
                        <li>계정 정보</li>
                    </ul>
                </div>
                
                <form id="delete-account-form" style="margin-top: 20px;">
                    <div class="form-group">
                        <label class="form-label">비밀번호 확인</label>
                        <input type="password" class="form-control" id="deleteConfirmPassword" placeholder="계정 삭제를 위해 비밀번호를 입력하세요" autocomplete="current-password" required>

                    </div>
                    
                    <div class="checkbox-wrapper" style="margin-top: 15px;">
                        <input type="checkbox" id="deleteConfirmCheck" required>
                        <label for="deleteConfirmCheck">모든 내용을 영구적으로 삭제하는 것을 이해하고 동의합니다</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="deleteCancelBtn" class="btn">취소</button>
                <button id="deleteConfirmBtn" class="btn btn-accent" style="background-color: var(--accent-color); color: white; opacity: 0.5;" disabled>계정 삭제</button>
            </div>
        </div>
    </div>

    <!-- 설정 모달 -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT 설정</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="app-settings-form">
                    <div class="form-group">
                        <label class="form-label">셀 크기</label>
                        <input type="range" class="form-range" id="cellSizeRange" min="20" max="100" value="40">
                        <div class="d-flex justify-between">
                            <span>작게</span>
                            <span id="cellSizeValue">40px</span>
                            <span>크게</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">브러시 크기 (성능 최적화: 작은 값 권장)</label>
                        <input type="range" class="form-range" id="brushSizeRange" min="1" max="3" value="1">
                        <div class="d-flex justify-between">
                            <span>1</span>
                            <span id="brushSizeValue">1</span>
                            <span>3</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="d-flex align-center justify-between">
                            <label class="form-label">이모지 모드 배경</label>
                            <label class="switch">
                                <input type="checkbox" id="bgModeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="d-flex justify-between">
                            <span>사각형</span>
                            <span>투명</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="d-flex align-center justify-between">
                            <label class="form-label">커스텀 이모지</label>
                            <label class="switch">
                                <input type="checkbox" id="customModeSwitch">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div id="customEmojiSettings" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">색칠된 이모지</label>
                            <input type="text" class="form-control" id="filledEmojiInput" maxlength="1">
                        </div>
                        <div class="form-group">
                            <label class="form-label">색칠 안 된 이모지</label>
                            <input type="text" class="form-control" id="emptyEmojiInput" maxlength="1">
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="settingsCancelBtn" class="btn"><span class="valorant-text">취소</span></button>
                <button id="settingsSaveBtn" class="btn btn-accent"><span class="valorant-text">저장</span></button>
            </div>
        </div>
    </div>

    <!-- 파일 관리 모달 -->
    <div id="fileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="fileModalTitle">파일 저장</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="file-form">
                    <div id="saveFormGroup" class="form-group">
                        <label class="form-label">파일 이름</label>
                        <input type="text" class="form-control" id="fileNameInput" placeholder="파일 이름 입력">
                    </div>
                </form>
                <div id="fileListGroup">
                    <label class="form-label">파일 목록</label>
                    <div class="file-list" id="fileList"></div>
                    <div class="file-preview" id="filePreview"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="fileModalCancelBtn" class="btn">취소</button>
                <button id="fileDeleteBtn" class="btn" style="display: none;">삭제</button>
                <button id="fileExportBtn" class="btn" style="display: none;">내보내기</button>
                <button id="fileActionBtn" class="btn btn-accent">저장</button>
            </div>
        </div>
    </div>
    
    <!-- 파일 내보내기/가져오기 모달 -->
    <div id="exportImportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text" id="exportImportTitle">파일 내보내기/가져오기</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="action-buttons" style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button id="exportBtn" class="btn btn-accent" style="flex: 1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <span class="valorant-text">내보내기</span>
                    </button>
                    <button id="importBtn" class="btn btn-accent" style="flex: 1;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        <span class="valorant-text">가져오기</span>
                    </button>
                </div>
                
                <form id="import-form">
                    <div id="importFileInput" style="display: none;" class="form-group">
                        <label class="form-label">VAL 파일 선택</label>
                        <input type="file" class="form-control" id="fileInput" accept=".val">
                        <p style="margin-top: 10px; color: var(--text-muted);">* .val 확장자 파일만 지원합니다.</p>
                    </div>
                </form>
                
                <form id="export-form">
                    <div id="exportFileNameGroup" style="display: none;" class="form-group">
                        <label class="form-label">내보낼 파일 이름</label>
                        <input type="text" class="form-control" id="exportFileName" placeholder="파일 이름 입력">
                    </div>
                </form>
                
                <div id="filePreviewContainer" class="form-group" style="display: none; margin-top: 20px;">
                    <label class="form-label">미리보기</label>
                    <div id="importPreview" class="file-preview"></div>
                </div>
                
                <div id="fileAuthorInfo" class="form-group" style="margin-top: 20px;">
                    <div class="info-box" style="background-color: var(--main-bg); border: 1px solid var(--border-color); padding: 10px; border-radius: 4px;">
                        <p><strong>제작자:</strong> <span id="fileAuthorText"></span></p>
                        <p><strong>버전:</strong> <span id="fileVersionText"></span></p>
                    </div>
                </div>
                
                <div id="importConfirm" class="warning-box" style="display: none; margin-top: 15px;">
                    <div class="warning-title">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--accent-color);">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                        <span>주의</span>
                    </div>
                    <p>이 파일을 불러오면 현재 작업중인 내용이 모두 삭제됩니다. 계속하시겠습니까?</p>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="importConfirmCheck">
                        <label for="importConfirmCheck">이해했으며 진행합니다</label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="exportImportCancelBtn" class="btn">취소</button>
                <button id="executeExportImportBtn" class="btn btn-accent" style="display: none;">실행</button>
            </div>
        </div>
    </div>

    <!-- 공유 모달 -->
    <div id="shareModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">온라인 공유</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <form id="share-form">
                    <div class="form-group">
                        <label class="form-label">공유 제목</label>
                        <input type="text" class="form-control" id="shareTitleInput" placeholder="작품의 제목을 입력하세요" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">태그 (쉼표로 구분)</label>
                        <input type="text" class="form-control" id="shareTagsInput" placeholder="예: 풍경,동물,아트">
                    </div>
                    <div class="form-group">
                        <label class="form-label">설명 (선택사항)</label>
                        <textarea class="form-control" id="shareDescInput" rows="3" placeholder="작품에 대한 설명을 입력하세요"></textarea>
                    </div>
                    <div id="sharePreview" class="file-preview text-center">
                        <!-- 미리보기 내용 -->
                    </div>
                    
                    <!-- CAPTCHA 추가 -->
                    <div class="captcha-container">
                        <label class="form-label">보안 확인 (필수)</label>
                        <div class="custom-captcha">
                            <div id="captcha-container" class="g-recaptcha" data-sitekey="6LdwwxUrAAAAAHUGUYODxLEWGmaKKEw5VvpC87NZ"></div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button id="shareModalCancelBtn" class="btn">취소</button
                <button id="shareActionBtn" class="btn btn-accent">공유하기</button>
            </div>
        </div>
    </div>

    <!-- 도움말 모달 -->
    <div id="helpModal" class="modal">
        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">VALPAINT 도움말</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">VALPAINT 시작하기</h4>
                <p style="margin-bottom: 15px;">VALPAINT는 이모지를 활용한 간편한 그림판입니다. 쉽고 재미있게 픽셀 아트를 만들고 온라인으로 공유해보세요!</p>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">기본 사용법</h4>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li>캔버스의 셀을 클릭하면 그림을 그릴 수 있어요</li>
                    <li>그리기/지우기 버튼으로 모드를 전환할 수 있어요</li>
                    <li>브러시 크기를 조절하여 한 번에 여러 셀을 그릴 수 있어요</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">단축키 모음</h4>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li><strong>Q</strong>: 그리기/지우기 모드 전환</li>
                    <li><strong>+/-</strong>: 브러시 크기 조절</li>
                    <li><strong>Delete</strong>: 모든 내용 지우기</li>
                    <li><strong>Ctrl+S</strong>: 작품 저장하기</li>
                    <li><strong>Ctrl+O</strong>: 작품 불러오기</li>
                    <li><strong>Ctrl+C</strong>: 작품 복사하기</li>
                    <li><strong>Ctrl+E</strong>: 내보내기/가져오기</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">파일 저장 및 불러오기</h4>
                <p style="margin-bottom: 10px;"><strong>VAL</strong> 형식으로 작품을 저장하고 불러올 수 있습니다:</p>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li><strong>저장</strong>: 로컬 스토리지에 작품을 저장합니다</li>
                    <li><strong>불러오기</strong>: 저장된 작품을 불러옵니다</li>
                    <li><strong>내보내기</strong>: 작품을 VAL 파일로 다운로드합니다</li>
                    <li><strong>가져오기</strong>: VAL 파일을 업로드하여 가져옵니다</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">온라인 공유</h4>
                <p style="margin-bottom: 10px;">작품을 만들고 온라인으로 공유하면 다른 사람들이 볼 수 있어요!</p>
                <ul style="padding-left: 20px; margin-bottom: 15px;">
                    <li>"온라인 공유" 버튼을 클릭하여 작품 정보를 입력하세요</li>
                    <li>공유된 작품은 "갤러리"에서 확인할 수 있어요</li>
                    <li>최대 10개까지 작품을 공유할 수 있어요</li>
                    <li>마음에 드는 작품은 즐겨찾기로 등록해보세요</li>
                    <li>온라인 공유는 CAPTCHA 인증이 필요합니다</li>
                </ul>

                <h4 style="color: var(--accent-color); margin-bottom: 10px; font-family: var(--valorant-font);">설정 옵션</h4>
                <ul style="padding-left: 20px;">
                    <li><strong>셀 크기</strong>: 캔버스 셀의 크기를 조절합니다</li>
                    <li><strong>브러시 크기</strong>: 한 번에 그릴 셀의 수를 조절합니다 (성능 최적화를 위해 작은 값 권장)</li>
                    <li><strong>이모지 모드 배경</strong>: 배경을 사각형 또는 투명으로 설정합니다</li>
                    <li><strong>커스텀 이모지</strong>: 그리기에 사용할 이모지를 직접 설정합니다</li>
                </ul>
                
                <h4 style="color: var(--accent-color); margin-bottom: 10px; margin-top: 15px; font-family: var(--valorant-font);">계정 관리</h4>
                <ul style="padding-left: 20px;">
                    <li><strong>계정 설정</strong>: 작가명과 비밀번호를 변경할 수 있습니다</li>
                    <li><strong>계정 삭제</strong>: 계정과 모든 온라인 작품을 삭제합니다</li>
                    <li><strong>비회원 모드</strong>: 로그인 없이 그림을 그릴 수 있지만 온라인 갤러리와 공유 기능은 제한됩니다</li>
                </ul>
            </div>
            <div class="modal-footer">
                <button id="shortcutsBtn" class="btn"><span class="valorant-text">단축키 보기</span></button>
                <button id="helpCloseBtn" class="btn btn-accent"><span class="valorant-text">확인</span></button>
            </div>
        </div>
    </div>

    <!-- 단축키 모달 -->
    <div id="shortcutsModal" class="modal">
        <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h3 class="modal-title valorant-text">단축키 목록</h3>
                <span class="modal-close">&times;</span>
            </div>
            <div class="modal-body">
                <table style="width: 100%; border-collapse: collapse;">
                    <tr>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">기능</th>
                        <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">단축키</th>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">저장</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+S</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">불러오기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+O</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">복사</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+C</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">그리기/지우기 전환</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Q</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">브러시 크기 증가</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">+</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">브러시 크기 감소</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">-</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">전체 지우기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Delete</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">도움말</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">F1</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">설정</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">F2</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">내보내기/가져오기</td>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);"><span class="shortcut">Ctrl+E</span></td>
                    </tr>
                </table>
            </div>
            <div class="modal-footer">
                <button id="shortcutsCloseBtn" class="btn btn-accent"><span class="valorant-text">확인</span></button>
            </div>
        </div>
    </div>

    <!-- 갤러리 페이지 -->
    <div id="galleryPage" class="page">
        <div class="page-header">
            <div class="back-button" id="galleryBackBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                <span class="valorant-text">돌아가기</span>
            </div>
            <h1 class="page-title valorant-text">VALPAINT 갤러리</h1>
            <div></div>
        </div>
        <div class="page-container">
            <div class="tabs">
                <div class="tab active" data-tab="my">내 작품</div>
                <div class="tab" data-tab="public">공개 작품</div>
                <div class="tab" data-tab="favorites">즐겨찾기</div>
            </div>
            
            <div class="d-flex justify-between align-center mb-10">
                <div class="search-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                    <input type="text" class="search-input" id="searchInput" placeholder="검색어 입력...">
                </div>
                
                <div class="filter-dropdown">
                    <div class="filter-button" id="filterBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
                        </svg>
                        <span>필터</span>
                    </div>
                    <div class="filter-menu" id="filterMenu">
                        <div class="filter-item active" data-filter="latest">최신순</div>
                        <div class="filter-item" data-filter="oldest">오래된순</div>
                        <div class="filter-item" data-filter="popular">인기순</div>
                    </div>
                </div>
                
                <button id="refreshGalleryBtn" class="btn valorant-text">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M23 4v6h-6"></path>
                        <path d="M1 20v-6h6"></path>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
                        <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
                    </svg>
                    새로고침
                </button>
            </div>
            
            <div id="galleryContent" class="gallery-layout">
                <!-- 갤러리 내용이 동적으로 로드됩니다 -->
                <div class="text-center" style="grid-column: 1 / -1;">
                    <div class="spinner"></div>
                    <p>작품을 불러오는 중...</p>
                </div>
            </div>
            
            <div class="pagination" id="galleryPagination">
                <!-- 페이지네이션은 동적으로 생성됩니다 -->
            </div>
        </div>
    </div>

    <!-- 작품 상세 페이지 -->
    <div id="artworkPage" class="page">
        <div class="page-header">
            <div class="back-button" id="artworkBackBtn">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                <span class="valorant-text">갤러리로</span>
            </div>
            <h1 class="page-title valorant-text" id="artworkPageTitle">작품 상세</h1>
            <div></div>
        </div>
        
        <div class="artwork-container">
            <div class="artwork-image" id="artworkPreview">
                <!-- 작품 미리보기가 여기에 표시됩니다 -->
            </div>
            
            <div class="artwork-meta">
                <h2 id="artworkTitle" class="artwork-title valorant-text">작품 제목</h2>
                <p class="artwork-creator" id="artworkCreator">작가: 작가명</p>
                <div id="artworkTags" class="gallery-tags"></div>
            </div>
            
            <div class="artwork-info">
                <div class="artwork-info-section">
                    <h3 class="artwork-info-title">작품 정보</h3>
                    <div class="artwork-info-content">
                        <p><strong>업로드 일자:</strong> <span id="artworkDate">2023-01-01</span></p>
                        <p><strong>조회수:</strong> <span id="artworkViews">0</span></p>
                    </div>
                </div>
                
                <div class="artwork-info-section">
                    <h3 class="artwork-info-title">작품 설명</h3>
                    <div class="artwork-info-content" id="artworkDesc">
                        작품에 대한 설명이 여기에 표시됩니다.
                    </div>
                </div>
            </div>
            
            <div class="artwork-buttons">
                <button id="favoriteArtworkBtn" class="btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                    </svg>
                    즐겨찾기
                </button>
                <button id="downloadArtworkBtn" class="btn artwork-action">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    다운로드
                </button>
                <button id="loadArtworkBtn" class="btn btn-accent artwork-action">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    불러오기
                </button>
            </div>
        </div>
    </div>

    <!-- 토스트 알림 컨테이너 -->
    <div id="toast-container"></div>
    <div id="brushCursor" class="brush-cursor"></div>

    <!-- Valpaint JavaScript -->
    <script>
// Supabase 클라이언트 초기화 (실제 배포 시에는 환경변수나 설정 파일로 분리하는 것을 권장)
const SUPABASE_URL = 'https://xesqcwzstgkmvgokfrqx.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inhlc3Fjd3pzdGdrbXZnb2tmcnF4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ0MjI0MjgsImV4cCI6MjA1OTk5ODQyOH0.W7yL0YxaQ1O_eaeRfntYQFdnmyafixKsQy_diDzxttc';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// 상수 및 환경 설정
const CONFIG = {
    APP_VERSION: '2.2.0',
    MAX_ARTWORK_PER_USER: 10,
    DEFAULT_CELL_SIZE: 40,
    MAX_BRUSH_SIZE: 3,
    MIN_BRUSH_SIZE: 1,
    DEFAULT_GRID_ROWS: 13,
    DEFAULT_GRID_COLS: 26,
    DEBOUNCE_DELAY: 5, // ms
    TOAST_DURATION: 4000, // ms
    SECURITY: {
        HASH_SALT_PREFIX: 'valpaint-secure-',
        CRYPT_ITERATIONS: 1000, // SHA-256 iterations for increased security
        SESSION_DURATION: 7 * 24 * 60 * 60 * 1000 // 1 week in ms
    },
    STORAGE_KEYS: {
        PREFIX: 'valpaint_',
        USERNAME: 'valpaint_username',
        USER_ID: 'valpaint_user_id',
        AUTH_TOKEN: 'valpaint_auth_token',
        AUTH_EXPIRY: 'valpaint_auth_expiry',
        FAVORITES: 'valpaint_favorites',
        SETTINGS: 'valpaint_settings',
        TERMS_ACCEPTED: 'valpaint_terms_accepted'
    }
};

// 설정 및 상태 관리
const settings = {
    cellSize: CONFIG.DEFAULT_CELL_SIZE,
    brushSize: 1,
    bgMode: 'rectangle',
    emojiRows: CONFIG.DEFAULT_GRID_ROWS,
    emojiCols: CONFIG.DEFAULT_GRID_COLS,
    customMode: false,
    filledEmoji: '■',
    emptyEmoji: '□',
    transparentChar: 'ㅤ',
    author: '',
    version: CONFIG.APP_VERSION
};

// 애플리케이션 상태
const appState = {
    isEraserMode: false,
    isDragging: false,
    lastCellPosition: null,
    showBrushCursor: true,
    userName: '',
    userId: '',
    lastMousePosition: { x: 0, y: 0 },
    favorites: [],
    artworkCache: {},
    debounceTimer: null,
    termsAccepted: false,
    isAuthenticated: false,
    isGuestMode: false,
    authToken: null,
    authExpiry: null,
    currentPage: 'home', // home, gallery, artwork
    currentTab: 'my', // my, public, favorites (gallery tabs)
    currentFilter: 'latest', // latest, oldest, popular
    currentArtwork: null, // 현재 보고 있는 작품 정보
    pageParams: {
        page: 1,
        pageSize: 12,
        totalPages: 1
    }
};

// DOM 요소 참조
const elements = {
    // 기본 UI 요소
    drawingCanvas: document.getElementById('drawingCanvas'),
    userDisplayName: document.getElementById('userDisplayName'),
    
    // 버튼 및 컨트롤
    drawEraseBtn: document.getElementById('drawEraseBtn'),
    clearBtn: document.getElementById('clearBtn'),
    brushSizeDisplay: document.getElementById('brushSizeDisplay'),
    brushSizeDownBtn: document.getElementById('brushSizeDownBtn'),
    brushSizeUpBtn: document.getElementById('brushSizeUpBtn'),
    saveBtn: document.getElementById('saveBtn'),
    loadBtn: document.getElementById('loadBtn'),
    copyBtn: document.getElementById('copyBtn'),
    shareBtn: document.getElementById('shareBtn'),
    settingsBtn: document.getElementById('settingsBtn'),
    helpBtn: document.getElementById('helpBtn'),
    galleryBtn: document.getElementById('galleryBtn'),
    exportImportBtn: document.getElementById('exportImportBtn'),
    
    // 브러시 커서
    brushCursor: document.getElementById('brushCursor'),
    
    // 모달 요소
    authModal: document.getElementById('auth-modal'),
    fileModal: document.getElementById('fileModal'),
    exportImportModal: document.getElementById('exportImportModal'),
    shareModal: document.getElementById('shareModal'),
    settingsModal: document.getElementById('settingsModal'),
    helpModal: document.getElementById('helpModal'),
    shortcutsModal: document.getElementById('shortcutsModal'),
    userSettingsModal: document.getElementById('userSettingsModal'),
    deleteAccountModal: document.getElementById('deleteAccountModal'),
    
    // 페이지 요소
    galleryPage: document.getElementById('galleryPage'),
    artworkPage: document.getElementById('artworkPage'),
    
    // 인증 요소
    loginForm: document.getElementById('login-form'),
    registerForm: document.getElementById('register-form'),
    loginUsername: document.getElementById('loginUsername'),
    loginPassword: document.getElementById('loginPassword'),
    registerUsername: document.getElementById('registerUsername'),
    registerPassword: document.getElementById('registerPassword'),
    registerPasswordConfirm: document.getElementById('registerPasswordConfirm'),
    acceptTerms: document.getElementById('acceptTerms'),
    guestModeBtn: document.getElementById('guest-mode-btn'),
    guestModeBanner: document.getElementById('guest-mode-banner'),
    guestLoginBtn: document.getElementById('guest-login-btn'),
    
    // 사용자 프로필
    userProfileBtn: document.getElementById('userProfileBtn'),
    userDropdownMenu: document.getElementById('userDropdownMenu'),
    userSettingsBtn: document.getElementById('userSettingsBtn'),
    deleteAccountBtn: document.getElementById('deleteAccountBtn'),
    
    // 계정 설정 요소
    accountSettingsForm: document.getElementById('account-settings-form'),
    accountUsername: document.getElementById('accountUsername'),
    accountCurrentPassword: document.getElementById('accountCurrentPassword'),
    accountNewPassword: document.getElementById('accountNewPassword'),
    accountSaveBtn: document.getElementById('accountSaveBtn'),
    accountCancelBtn: document.getElementById('accountCancelBtn'),
    
    // 계정 삭제 요소
    deleteAccountForm: document.getElementById('delete-account-form'),
    deleteConfirmPassword: document.getElementById('deleteConfirmPassword'),
    deleteConfirmCheck: document.getElementById('deleteConfirmCheck'),
    deleteConfirmBtn: document.getElementById('deleteConfirmBtn'),
    deleteCancelBtn: document.getElementById('deleteCancelBtn'),
    
    // 파일 관리 요소
    fileForm: document.getElementById('file-form'),
    fileModalTitle: document.getElementById('fileModalTitle'),
    fileNameInput: document.getElementById('fileNameInput'),
    fileList: document.getElementById('fileList'),
    filePreview: document.getElementById('filePreview'),
    saveFormGroup: document.getElementById('saveFormGroup'),
    fileListGroup: document.getElementById('fileListGroup'),
    fileModalCancelBtn: document.getElementById('fileModalCancelBtn'),
    fileDeleteBtn: document.getElementById('fileDeleteBtn'),
    fileExportBtn: document.getElementById('fileExportBtn'),
    fileActionBtn: document.getElementById('fileActionBtn'),
    
    // 내보내기/가져오기 요소
    exportImportTitle: document.getElementById('exportImportTitle'),
    exportBtn: document.getElementById('exportBtn'),
    importBtn: document.getElementById('importBtn'),
    importFileInput: document.getElementById('importFileInput'),
    exportFileNameGroup: document.getElementById('exportFileNameGroup'),
    exportFileName: document.getElementById('exportFileName'),
    exportImportCancelBtn: document.getElementById('exportImportCancelBtn'),
    executeExportImportBtn: document.getElementById('executeExportImportBtn'),
    filePreviewContainer: document.getElementById('filePreviewContainer'),
    importPreview: document.getElementById('importPreview'),
    importConfirm: document.getElementById('importConfirm'),
    importConfirmCheck: document.getElementById('importConfirmCheck'),
    fileInput: document.getElementById('fileInput'),
    fileAuthorText: document.getElementById('fileAuthorText'),
    fileVersionText: document.getElementById('fileVersionText'),
    
    // 공유 모달 요소
    shareForm: document.getElementById('share-form'),
    shareTitleInput: document.getElementById('shareTitleInput'),
    shareTagsInput: document.getElementById('shareTagsInput'),
    shareDescInput: document.getElementById('shareDescInput'),
    sharePreview: document.getElementById('sharePreview'),
    shareModalCancelBtn: document.getElementById('shareModalCancelBtn'),
    shareActionBtn: document.getElementById('shareActionBtn'),
    
    // 설정 요소
    appSettingsForm: document.getElementById('app-settings-form'),
    cellSizeRange: document.getElementById('cellSizeRange'),
    cellSizeValue: document.getElementById('cellSizeValue'),
    brushSizeRange: document.getElementById('brushSizeRange'),
    brushSizeValue: document.getElementById('brushSizeValue'),
    bgModeSwitch: document.getElementById('bgModeSwitch'),
    customModeSwitch: document.getElementById('customModeSwitch'),
    customEmojiSettings: document.getElementById('customEmojiSettings'),
    filledEmojiInput: document.getElementById('filledEmojiInput'),
    emptyEmojiInput: document.getElementById('emptyEmojiInput'),
    settingsCancelBtn: document.getElementById('settingsCancelBtn'),
    settingsSaveBtn: document.getElementById('settingsSaveBtn'),
    
    // 도움말 및 단축키 요소
    helpCloseBtn: document.getElementById('helpCloseBtn'),
    shortcutsBtn: document.getElementById('shortcutsBtn'),
    shortcutsCloseBtn: document.getElementById('shortcutsCloseBtn'),
    
    // 갤러리 페이지 요소
    galleryBackBtn: document.getElementById('galleryBackBtn'),
    galleryTabs: document.querySelectorAll('#galleryPage .tab'),
    searchInput: document.getElementById('searchInput'),
    filterBtn: document.getElementById('filterBtn'),
    filterMenu: document.getElementById('filterMenu'),
    filterItems: document.querySelectorAll('#filterMenu .filter-item'),
    refreshGalleryBtn: document.getElementById('refreshGalleryBtn'),
    galleryContent: document.getElementById('galleryContent'),
    galleryPagination: document.getElementById('galleryPagination'),
    
    // 작품 상세 페이지 요소
    artworkBackBtn: document.getElementById('artworkBackBtn'),
    artworkPageTitle: document.getElementById('artworkPageTitle'),
    artworkTitle: document.getElementById('artworkTitle'),
    artworkCreator: document.getElementById('artworkCreator'),
    artworkPreview: document.getElementById('artworkPreview'),
    artworkDate: document.getElementById('artworkDate'),
    artworkViews: document.getElementById('artworkViews'),
    artworkTags: document.getElementById('artworkTags'),
    artworkDesc: document.getElementById('artworkDesc'),
    favoriteArtworkBtn: document.getElementById('favoriteArtworkBtn'),
    downloadArtworkBtn: document.getElementById('downloadArtworkBtn'),
    loadArtworkBtn: document.getElementById('loadArtworkBtn'),
    
    // 로딩 화면
    loadingScreen: document.getElementById('loading-screen')
};

// 캔버스 데이터 저장
let canvasData = [];

// 유틸리티 함수 모음
const utils = {
    // DOM 요소 확인
    validateElement: function(element, name) {
        if (!element) {
            console.error(`요소 "${name}"을(를) 찾을 수 없습니다.`);
            return false;
        }
        return true;
    },
    
    // 모달 표시/숨기기
    showModal: function(modal) {
        if (!this.validateElement(modal, 'modal')) return;
        
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.classList.add('show');
        }, 10);
    },
    
    hideModal: function(modal) {
        if (!this.validateElement(modal, 'modal')) return;
        
        modal.classList.remove('show');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    },
    
    // 토스트 알림 표시 (개선된 버전)
    showToast: function(message, type = 'info', duration = CONFIG.TOAST_DURATION) {
        if (!message) return;
        
        // HTML 이스케이프
        message = this.escapeHtml(message);
        
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.position = 'fixed';
            toastContainer.style.top = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '9999';
            toastContainer.style.display = 'flex';
            toastContainer.style.flexDirection = 'column';
            toastContainer.style.gap = '10px';
            document.body.appendChild(toastContainer);
        }
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.style.display = 'flex';
        toast.style.alignItems = 'center';
        toast.style.padding = '12px 16px';
        toast.style.background = 'var(--secondary-bg)';
        toast.style.borderLeft = `4px solid ${type === 'error' ? 'var(--accent-color)' : type === 'success' ? '#00c853' : type === 'warning' ? '#ffc107' : '#1e90ff'}`;
        toast.style.borderRadius = '4px';
        toast.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
        toast.style.transform = 'translateX(100%)';
        toast.style.opacity = '0';
        toast.style.transition = 'all 0.3s ease';
        
        // 아이콘 추가
        let iconSvg = '';
        switch(type) {
            case 'success':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#00c853" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>`;
                break;
            case 'error':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ff4655" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
                break;
            case 'warning':
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#ffc107" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>`;
                break;
            case 'info':
            default:
                iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#1e90ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`;
                break;
        }
        
        const iconWrapper = document.createElement('div');
        iconWrapper.className = 'toast-icon';
        iconWrapper.style.marginRight = '12px';
        iconWrapper.innerHTML = iconSvg;
        
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'toast-content';
        contentWrapper.innerHTML = message;
        contentWrapper.style.flex = '1';
        contentWrapper.style.fontSize = '14px';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'toast-close';
        closeBtn.innerHTML = '×';
        closeBtn.style.background = 'none';
        closeBtn.style.border = 'none';
        closeBtn.style.color = 'var(--text-muted)';
        closeBtn.style.fontSize = '18px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.marginLeft = '8px';
        closeBtn.style.padding = '0 4px';
        
        toast.appendChild(iconWrapper);
        toast.appendChild(contentWrapper);
        toast.appendChild(closeBtn);
        
        // 닫기 버튼 이벤트
        closeBtn.addEventListener('click', () => {
            toast.style.transform = 'translateX(100%)';
            toast.style.opacity = '0';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        });
        
        toastContainer.appendChild(toast);
        
        // 애니메이션 적용 (추가 후 약간 딜레이)
        setTimeout(() => {
            toast.style.transform = 'translateX(0)';
            toast.style.opacity = '1';
        }, 10);
        
        // 자동 닫힘
        const toastTimeout = setTimeout(() => {
            if (toast.parentNode) {
                toast.style.transform = 'translateX(100%)';
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }, duration);
        
        // 마우스 오버 시 자동 닫힘 일시 중지
        toast.addEventListener('mouseenter', () => {
            clearTimeout(toastTimeout);
        });
        
        // 마우스 아웃 시 자동 닫힘 재개
        toast.addEventListener('mouseleave', () => {
            const newTimeout = setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    toast.style.opacity = '0';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }, duration / 2);
            
            toast.dataset.timeout = newTimeout;
        });
    },
    
    // HTML 이스케이프
    escapeHtml: function(unsafe) {
        if (typeof unsafe !== 'string') {
            return unsafe;
        }
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    },
    
    // 디바운스 함수
    debounce: function(func, wait) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    },
    
    // 날짜 형식화
    formatDate: function(dateString) {
        if (!dateString) return '날짜 없음';
        
        try {
            const date = new Date(dateString);
            return date.toLocaleString('ko-KR', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        } catch (error) {
            console.error('날짜 형식화 오류:', error);
            return dateString;
        }
    },
    
    // 로컬 스토리지 유틸리티
    storage: {
        // 키 생성 헬퍼
        getKey: function(key) {
            return CONFIG.STORAGE_KEYS.PREFIX + key;
        },
        
        // 파일 저장
        saveFile: function(fileName, data) {
            try {
                if (!fileName || !data) {
                    return false;
                }
                
                // 파일 이름 검증
                const sanitizedFileName = utils.sanitizeFileName(fileName);
                if (!sanitizedFileName) {
                    utils.showToast('유효하지 않은 파일 이름입니다', 'error');
                    return false;
                }
                
                // 저장 전 데이터 검증
                if (typeof data !== 'object') {
                    utils.showToast('유효하지 않은 데이터 형식입니다', 'error');
                    return false;
                }
                
                // 데이터 추가 정보
                data.lastModified = new Date().toISOString();
                data.version = CONFIG.APP_VERSION;
                
                localStorage.setItem(this.getKey(sanitizedFileName), JSON.stringify(data));
                return true;
            } catch (error) {
                console.error('파일 저장 오류:', error);
                utils.showToast('파일 저장 중 오류가 발생했습니다', 'error');
                return false;
            }
        },
        
        // 파일 불러오기
        loadFile: function(fileName) {
            try {
                if (!fileName) {
                    return null;
                }
                
                const data = localStorage.getItem(this.getKey(fileName));
                if (!data) {
                    return null;
                }
                
                // JSON 파싱 및 유효성 검사
                try {
                    const parsedData = JSON.parse(data);
                    
                    // 기본 구조 유효성 검사
                    if (!parsedData || typeof parsedData !== 'object') {
                        throw new Error('유효하지 않은 데이터 형식');
                    }
                    
                    return parsedData;
                } catch (parseError) {
                    console.error('파일 파싱 오류:', parseError);
                    utils.showToast('파일 형식이 올바르지 않습니다', 'error');
                    return null;
                }
            } catch (error) {
                console.error('파일 로드 오류:', error);
                utils.showToast('파일 로드 중 오류가 발생했습니다', 'error');
                return null;
            }
        },
        
        // 파일 삭제
        deleteFile: function(fileName) {
            try {
                if (!fileName) {
                    return false;
                }
                
                localStorage.removeItem(this.getKey(fileName));
                return true;
            } catch (error) {
                console.error('파일 삭제 오류:', error);
                utils.showToast('파일 삭제 중 오류가 발생했습니다', 'error');
                return false;
            }
        },
        
        // 파일 목록 가져오기
        getFileList: function() {
            const files = [];
            try {
                const prefix = CONFIG.STORAGE_KEYS.PREFIX;
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(prefix) && key.endsWith('.val')) {
                        files.push(key.substring(prefix.length));
                    }
                }
                
                // 최신 파일 순으로 정렬
                files.sort((a, b) => {
                    const aData = this.loadFile(a);
                    const bData = this.loadFile(b);
                    
                    if (!aData || !aData.lastModified) return 1;
                    if (!bData || !bData.lastModified) return -1;
                    
                    return new Date(bData.lastModified) - new Date(aData.lastModified);
                });
                
                return files;
            } catch (error) {
                console.error('파일 목록 오류:', error);
                return [];
            }
        },
        
        // 설정 저장
        saveSettings: function(settings) {
            try {
                if (!settings || typeof settings !== 'object') {
                    return false;
                }
                
                localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
                return true;
            } catch (error) {
                console.error('설정 저장 오류:', error);
                return false;
            }
        },
        
        // 설정 불러오기
        loadSettings: function() {
            try {
                const data = localStorage.getItem(CONFIG.STORAGE_KEYS.SETTINGS);
                if (!data) {
                    return null;
                }
                
                // JSON 파싱 및 유효성 검사
                try {
                    const parsedSettings = JSON.parse(data);
                    
                    // 설정 유효성 검사
                    if (!parsedSettings || typeof parsedSettings !== 'object') {
                        throw new Error('유효하지 않은 설정 형식');
                    }
                    
                    return parsedSettings;
                } catch (parseError) {
                    console.error('설정 파싱 오류:', parseError);
                    return null;
                }
            } catch (error) {
                console.error('설정 로드 오류:', error);
                return null;
            }
        },
        
        // 모든 데이터 삭제
        clearAll: function() {
            try {
                // valpaint_ 로 시작하는 모든 항목 삭제
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CONFIG.STORAGE_KEYS.PREFIX)) {
                        keysToRemove.push(key);
                    }
                }
                
                keysToRemove.forEach(key => localStorage.removeItem(key));
                return true;
            } catch (error) {
                console.error('데이터 삭제 오류:', error);
                return false;
            }
        },
        
        // 세션 저장
        saveSessionData: function(token, userId, expiry) {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN, token);
                localStorage.setItem(CONFIG.STORAGE_KEYS.USER_ID, userId);
                localStorage.setItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY, expiry.toString());
                return true;
            } catch (error) {
                console.error('세션 저장 오류:', error);
                return false;
            }
        },
        
        // 세션 가져오기
        getSessionData: function() {
            try {
                const token = localStorage.getItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN);
                const userId = localStorage.getItem(CONFIG.STORAGE_KEYS.USER_ID);
                const expiry = parseInt(localStorage.getItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY) || '0');
                
                // 세션 만료 확인
                if (!token || !userId || !expiry || expiry < Date.now()) {
                    return null;
                }
                
                return { token, userId, expiry };
            } catch (error) {
                console.error('세션 가져오기 오류:', error);
                return null;
            }
        },
        
        // 세션 삭제
        clearSession: function() {
            try {
                localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN);
                localStorage.removeItem(CONFIG.STORAGE_KEYS.USER_ID);
                localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY);
                return true;
            } catch (error) {
                console.error('세션 삭제 오류:', error);
                return false;
            }
        }
    },
    
    // 파일 이름 유효성 검사 및 정제
    sanitizeFileName: function(fileName) {
        if (!fileName || typeof fileName !== 'string' || fileName.trim() === '') {
            return '';
        }
        
        // 파일 이름에서 위험한 문자 제거
        const sanitized = fileName.trim()
            .replace(/[^a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ_\-]/g, '')
            .substring(0, 50); // 길이 제한
        
        return sanitized;
    },
    
    // 텍스트 유효성 검사 및 정제
    sanitizeText: function(text, maxLength = 500) {
        if (!text || typeof text !== 'string') {
            return '';
        }
        
        // XSS 방지 처리
        const sanitized = text.trim()
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .substring(0, maxLength);
        
        return sanitized;
    },
    
    // 사용자 이름 유효성 검사
    validateUsername: function(username) {
        if (!username || typeof username !== 'string') {
            return { valid: false, message: '사용자 이름을 입력해주세요.' };
        }
        
        // 길이 및 문자 제한
        if (username.length < 2 || username.length > 20) {
            return { valid: false, message: '사용자 이름은 2-20자 사이여야 합니다.' };
        }
        
        // 허용되는 문자 검사
        const validUsernameRegex = /^[a-zA-Z0-9가-힣ㄱ-ㅎㅏ-ㅣ_\-]+$/;
        if (!validUsernameRegex.test(username)) {
            return { valid: false, message: '사용자 이름에는 문자, 숫자, 한글, 밑줄 및 하이픈만 사용할 수 있습니다.' };
        }
        
        return { valid: true, message: '' };
    },
    
    // 비밀번호 유효성 검사
    validatePassword: function(password) {
        if (!password || typeof password !== 'string') {
            return { valid: false, message: '비밀번호를 입력해주세요.' };
        }
        
        // 길이 제한
        if (password.length < 6) {
            return { valid: false, message: '비밀번호는 최소 6자 이상이어야 합니다.' };
        }
        
        return { valid: true, message: '' };
    },
    
    // 객체의 깊은 복사 수행
    deepClone: function(obj) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        
        // 날짜 객체 처리
        if (obj instanceof Date) {
            return new Date(obj.getTime());
        }
        
        // 배열 처리
        if (Array.isArray(obj)) {
            return obj.map(item => this.deepClone(item));
        }
        
        // 객체 처리
        const clonedObj = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                clonedObj[key] = this.deepClone(obj[key]);
            }
        }
        
        return clonedObj;
    },
    
    // CSRF 토큰 생성
    generateCSRFToken: function() {
        const array = new Uint8Array(16);
        crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    },
    
    // 현재 세션이 유효한지 확인
    isSessionValid: function() {
        const session = this.storage.getSessionData();
        return !!session && session.expiry > Date.now();
    },
    
    // 앱 로그 (개발용)
    log: function(message, type = 'info') {
        const isProduction = window.location.hostname !== 'localhost' && 
                           window.location.hostname !== '127.0.0.1';
        
        // 프로덕션 환경에서는 로그 제한
        if (isProduction && type === 'debug') {
            return;
        }
        
        const timestamp = new Date().toLocaleTimeString();
        const prefix = `[Valpaint ${type.toUpperCase()}] ${timestamp}:`;
        
        switch (type) {
            case 'error':
                console.error(prefix, message);
                break;
            case 'warn':
                console.warn(prefix, message);
                break;
            case 'debug':
                console.debug(prefix, message);
                break;
            default:
                console.log(prefix, message);
        }
    }
};

// 캔버스 렌더러
const canvasRenderer = {
    // 캔버스 초기화
    initCanvas() {
        if (!utils.validateElement(elements.drawingCanvas, 'drawingCanvas')) return;
        
        const canvas = elements.drawingCanvas;
        canvas.innerHTML = '';
        canvas.className = 'drawing-canvas';
        
        // 초기 데이터 생성
        if (!canvasData || !canvasData.length) {
            canvasData = Array(settings.emojiRows)
                .fill()
                .map(() => Array(settings.emojiCols).fill(''));
        }
        
        // 데이터가 설정된 크기와 일치하는지 확인
        if (canvasData.length !== settings.emojiRows || 
            (canvasData[0] && canvasData[0].length !== settings.emojiCols)) {
            
            // 현재 데이터의 크기를 가져옴
            const currentRows = canvasData.length;
            const currentCols = canvasData[0] ? canvasData[0].length : 0;
            
            // 새 데이터 배열 생성
            const newData = Array(settings.emojiRows)
                .fill()
                .map(() => Array(settings.emojiCols).fill(''));
            
            // 기존 데이터 복사
            const minRows = Math.min(currentRows, settings.emojiRows);
            const minCols = Math.min(currentCols, settings.emojiCols);
            
            for (let r = 0; r < minRows; r++) {
                for (let c = 0; c < minCols; c++) {
                    if (canvasData[r] && canvasData[r][c] !== undefined) {
                        newData[r][c] = canvasData[r][c];
                    }
                }
            }
            
            canvasData = newData;
        }
        
        // 캔버스 생성
        this.createEmojiCanvas(settings.emojiRows, settings.emojiCols);
    },
    
    // 이모지 모드 캔버스 생성
    createEmojiCanvas(rows, cols) {
        if (!utils.validateElement(elements.drawingCanvas, 'drawingCanvas')) return;
        
        const container = document.createElement('div');
        container.className = 'emoji-container';
        container.style.display = 'grid';
        container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        container.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        
        try {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'emoji-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // 셀 크기 설정
                    cell.style.width = `${settings.cellSize}px`;
                    cell.style.height = `${settings.cellSize}px`;
                    
                    // 배경 모드 설정
                    if (settings.bgMode === 'transparent') {
                        cell.classList.add('transparent');
                    }
                    
                    // 셀 데이터 설정
                    if (canvasData[r] && canvasData[r][c] === '■') {
                        cell.classList.add('active');
                        cell.textContent = settings.customMode ? settings.filledEmoji : '■';
                    } else {
                        const emptyChar = settings.bgMode === 'transparent' 
                            ? settings.transparentChar 
                            : (settings.customMode ? settings.emptyEmoji : '□');
                        cell.textContent = emptyChar;
                    }
                    
                    // 이벤트 핸들러 등록
                    cell.addEventListener('mousedown', this.handleCellMouseDown.bind(this));
                    cell.addEventListener('mouseover', this.handleCellMouseOver.bind(this));
                    cell.addEventListener('touchstart', this.handleCellTouchStart.bind(this), { passive: false });
                    cell.addEventListener('touchmove', this.handleCellTouchMove.bind(this), { passive: false });
                    
                    container.appendChild(cell);
                }
            }
            
            elements.drawingCanvas.appendChild(container);
        } catch (error) {
            console.error('캔버스 생성 오류:', error);
            utils.showToast('캔버스를 생성하는 중 오류가 발생했습니다', 'error');
        }
    },
    
    // 브러시 크기에 따른 주변 셀 계산 최적화 함수
    getBrushCells(centerRow, centerCol, brushSize) {
        // 유효성 검사
        if (!Number.isInteger(centerRow) || !Number.isInteger(centerCol) || 
            !Number.isInteger(brushSize) || brushSize < 1) {
            return [{row: centerRow, col: centerCol}];
        }
        
        const radius = Math.floor(brushSize / 2);
        const cells = [];
        
        // 브러시 크기가 1인 경우 중앙 셀만 반환
        if (brushSize === 1) {
            return [{row: centerRow, col: centerCol}];
        }
        
        // 브러시 크기가 2 이상인 경우 주변 셀 계산
        for (let r = -radius; r <= radius; r++) {
            for (let c = -radius; c <= radius; c++) {
                const targetRow = centerRow + r;
                const targetCol = centerCol + c;
                
                // 유효한 범위 체크
                if (targetRow >= 0 && targetRow < settings.emojiRows &&
                    targetCol >= 0 && targetCol < settings.emojiCols) {
                    
                    // 거리 기반 처리
                    const distance = Math.sqrt(r * r + c * c);
                    if (distance <= radius) {
                        cells.push({row: targetRow, col: targetCol});
                    }
                }
            }
        }
        
        return cells;
    },
    
    // 셀 마우스 다운 핸들러
    handleCellMouseDown(event) {
        if (!event || !event.target) return;
        
        event.preventDefault();
        appState.isDragging = true;
        
        const cell = event.target;
        
        // 데이터 속성 확인
        if (!cell.dataset.row || !cell.dataset.col) return;
        
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        // 유효성 확인
        if (isNaN(row) || isNaN(col) || row < 0 || col < 0 || 
            row >= settings.emojiRows || col >= settings.emojiCols) {
            return;
        }
        
        // 셀 위치 기억
        appState.lastCellPosition = { row, col };
        
        // 브러시 크기에 따른 셀 처리
        const cells = this.getBrushCells(row, col, settings.brushSize);
        
        // 모든 셀 처리
        cells.forEach(({row, col}) => {
            const targetCell = document.querySelector(`.emoji-cell[data-row="${row}"][data-col="${col}"]`);
            if (targetCell) {
                this.toggleCell(targetCell, row, col);
            }
        });
    },
    
    // 모바일 터치 시작 핸들러
    handleCellTouchStart(event) {
        if (!event || !event.touches || event.touches.length === 0) return;
        
        event.preventDefault(); // 기본 터치 동작 방지
        
        appState.isDragging = true;
        
        const touch = event.touches[0];
        const cell = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (!cell || !cell.classList.contains('emoji-cell')) return;
        
        // 데이터 속성 확인
        if (!cell.dataset.row || !cell.dataset.col) return;
        
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        // 유효성 확인
        if (isNaN(row) || isNaN(col) || row < 0 || col < 0 || 
            row >= settings.emojiRows || col >= settings.emojiCols) {
            return;
        }
        
        // 셀 위치 기억
        appState.lastCellPosition = { row, col };
        
        // 브러시 크기에 따른 셀 처리
        const cells = this.getBrushCells(row, col, settings.brushSize);
        
        // 모든 셀 처리
        cells.forEach(({row, col}) => {
            const targetCell = document.querySelector(`.emoji-cell[data-row="${row}"][data-col="${col}"]`);
            if (targetCell) {
                this.toggleCell(targetCell, row, col);
            }
        });
    },
    
    // 모바일 터치 이동 핸들러
    handleCellTouchMove(event) {
        if (!event || !event.touches || event.touches.length === 0 || !appState.isDragging) return;
        
        event.preventDefault(); // 기본 스크롤 동작 방지
        
        const touch = event.touches[0];
        const cell = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (!cell || !cell.classList.contains('emoji-cell')) return;
        
        // 데이터 속성 확인
        if (!cell.dataset.row || !cell.dataset.col) return;
        
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        // 유효성 확인
        if (isNaN(row) || isNaN(col) || row < 0 || col < 0 || 
            row >= settings.emojiRows || col >= settings.emojiCols) {
            return;
        }
        
        // 이전에 처리한 셀과 같으면 스킵
        if (appState.lastCellPosition && 
            appState.lastCellPosition.row === row && 
            appState.lastCellPosition.col === col) {
            return;
        }
        
        // 셀 위치 기억
        appState.lastCellPosition = { row, col };
        
        // 디바운스 적용 (성능 최적화)
        if (appState.debounceTimer) {
            clearTimeout(appState.debounceTimer);
        }
        
        appState.debounceTimer = setTimeout(() => {
            // 브러시 크기에 따른 셀 처리
            const cells = this.getBrushCells(row, col, settings.brushSize);
            
            // 모든 셀 처리
            cells.forEach(({row, col}) => {
                const targetCell = document.querySelector(`.emoji-cell[data-row="${row}"][data-col="${col}"]`);
                if (targetCell) {
                    this.toggleCell(targetCell, row, col);
                }
            });
        }, CONFIG.DEBOUNCE_DELAY);
    },
    
    // 셀 토글 기능
    toggleCell(cell, row, col) {
        // 유효성 검사
        if (!cell || row < 0 || col < 0 || row >= settings.emojiRows || col >= settings.emojiCols) {
            return;
        }
        
        // 캔버스 데이터가 유효한지 확인
        if (!canvasData || !canvasData[row]) {
            utils.log('캔버스 데이터가 올바르지 않습니다', 'warn');
            return;
        }
        
        if (appState.isEraserMode) {
            // 지우기 모드
            cell.classList.remove('active');
            canvasData[row][col] = '';
            
            const emptyChar = settings.bgMode === 'transparent' 
                ? settings.transparentChar 
                : (settings.customMode ? settings.emptyEmoji : '□');
            cell.textContent = emptyChar;
        } else {
            // 그리기 모드
            cell.classList.add('active');
            canvasData[row][col] = '■';
            cell.textContent = settings.customMode ? settings.filledEmoji : '■';
        }
    },
    
    // 셀 마우스 오버 핸들러 (드래그)
    handleCellMouseOver(event) {
        if (!event || !event.target || !appState.isDragging) return;
        
        const cell = event.target;
        
        // 데이터 속성 확인
        if (!cell.dataset.row || !cell.dataset.col) return;
        
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        
        // 유효성 확인
        if (isNaN(row) || isNaN(col) || row < 0 || col < 0 || 
            row >= settings.emojiRows || col >= settings.emojiCols) {
            return;
        }
        
        // 이전에 처리한 셀과 같으면 스킵
        if (appState.lastCellPosition && 
            appState.lastCellPosition.row === row && 
            appState.lastCellPosition.col === col) {
            return;
        }
        
        // 셀 위치 기억
        appState.lastCellPosition = { row, col };
        
        // 디바운스 적용 (성능 최적화)
        if (appState.debounceTimer) {
            clearTimeout(appState.debounceTimer);
        }
        
        appState.debounceTimer = setTimeout(() => {
            // 브러시 크기에 따른 셀 처리
            const cells = this.getBrushCells(row, col, settings.brushSize);
            
            // 모든 셀 처리
            cells.forEach(({row, col}) => {
                const targetCell = document.querySelector(`.emoji-cell[data-row="${row}"][data-col="${col}"]`);
                if (targetCell) {
                    this.toggleCell(targetCell, row, col);
                }
            });
        }, CONFIG.DEBOUNCE_DELAY);
    },
    
    // 캔버스 전체 지우기
    clearCanvas() {
        try {
            // 이모지 모드 초기화
            canvasData = Array(settings.emojiRows)
                .fill()
                .map(() => Array(settings.emojiCols).fill(''));
            
            // 캔버스 다시 그리기
            this.initCanvas();
            
            utils.showToast('캔버스를 초기화했습니다', 'info');
        } catch (error) {
            console.error('캔버스 초기화 오류:', error);
            utils.showToast('캔버스 초기화 중 오류가 발생했습니다', 'error');
        }
    },
    
    // 캔버스 데이터 내보내기
    exportCanvasData() {
        try {
            // 현재 캔버스 데이터 깊은 복사
            const boardData = JSON.parse(JSON.stringify(canvasData));
            
            // 설정 정보 복사 (민감한 정보 제외)
            const { author, ...settingsCopy } = { ...settings };
            
            const data = {
                settings: settingsCopy,
                board: boardData,
                exportVersion: CONFIG.APP_VERSION,
                exportDate: new Date().toISOString()
            };
            
            return data;
        } catch (error) {
            console.error('캔버스 데이터 내보내기 오류:', error);
            utils.showToast('데이터 내보내기 중 오류가 발생했습니다', 'error');
            return null;
        }
    },
    
    // 캔버스 데이터 가져오기
    importCanvasData(data) {
        if (!data || !data.board) {
            utils.showToast('유효하지 않은 데이터입니다', 'error');
            return false;
        }
        
        try {
            // 설정 복원
            if (data.settings) {
                // 고정 해상도를 유지하기 위해 행과 열은 무시
                const { emojiRows, emojiCols, ...restSettings } = data.settings;
                Object.assign(settings, restSettings);
            }
            
            // 데이터 복원 (행/열 설정 유지)
            const newData = Array(settings.emojiRows)
                .fill()
                .map(() => Array(settings.emojiCols).fill(''));
            
            // 데이터 복사
            const rows = Math.min(data.board.length, settings.emojiRows);
            const cols = data.board[0] ? Math.min(data.board[0].length, settings.emojiCols) : 0;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (data.board[r] && data.board[r][c] !== undefined) {
                        newData[r][c] = data.board[r][c];
                    }
                }
            }
            
            canvasData = newData;
            
            // UI 업데이트
            this.initCanvas();
            
            return true;
        } catch (error) {
            console.error('데이터 가져오기 오류:', error);
            utils.showToast('데이터 가져오기에 실패했습니다', 'error');
            return false;
        }
    },
    
    // 현재 캔버스를 미리보기 이미지로 변환
    generatePreview() {
        try {
            let previewHtml = '<div style="font-family: monospace; line-height: 1; font-size: 14px; white-space: pre;">';
            
            for (let r = 0; r < canvasData.length; r++) {
                let rowText = '';
                for (let c = 0; c < canvasData[r].length; c++) {
                    if (canvasData[r][c] === '■') {
                        rowText += settings.customMode ? settings.filledEmoji : '■';
                    } else {
                        const emptyChar = settings.bgMode === 'transparent' 
                            ? settings.transparentChar 
                            : (settings.customMode ? settings.emptyEmoji : '□');
                        rowText += emptyChar;
                    }
                }
                previewHtml += rowText + '\n';
            }
            
            previewHtml += '</div>';
            return previewHtml;
        } catch (error) {
            console.error('미리보기 생성 오류:', error);
            return '<div>미리보기를 생성할 수 없습니다</div>';
        }
    },
    
    // 캔버스를 텍스트로 변환 (복사용)
    getCanvasAsText() {
        try {
            let result = '';
            
            for (let r = 0; r < canvasData.length; r++) {
                let rowText = '';
                for (let c = 0; c < canvasData[r].length; c++) {
                    if (canvasData[r][c] === '■') {
                        rowText += settings.customMode ? settings.filledEmoji : '■';
                    } else {
                        const emptyChar = settings.bgMode === 'transparent' 
                            ? settings.transparentChar 
                            : (settings.customMode ? settings.emptyEmoji : '□');
                        rowText += emptyChar;
                    }
                }
                result += rowText + '\n';
            }
            
            return result;
        } catch (error) {
            console.error('텍스트 변환 오류:', error);
            return '텍스트 변환 중 오류가 발생했습니다';
        }
    },
    
    updateGridVisibility() {
        try {
            // 격자 설정에 따라 캔버스 스타일 변경
            const container = elements.drawingCanvas.querySelector('.emoji-container');
            if (container) {
                container.style.gridTemplateColumns = `repeat(${settings.emojiCols}, 1fr)`;
                container.style.gridTemplateRows = `repeat(${settings.emojiRows}, 1fr)`;
            }
        } catch (error) {
            console.error('그리드 업데이트 오류:', error);
        }
    }
};

// 브러시 크기 변경 기능
function decreaseBrushSize() {
    if (settings.brushSize > CONFIG.MIN_BRUSH_SIZE) {
        updateBrushSize(settings.brushSize - 1);
    }
}

function increaseBrushSize() {
    if (settings.brushSize < CONFIG.MAX_BRUSH_SIZE) {
        updateBrushSize(settings.brushSize + 1);
    }
}

// 그리기/지우기 모드 토글
function toggleEraserMode() {
    appState.isEraserMode = !appState.isEraserMode;
    
    if (!utils.validateElement(elements.drawEraseBtn, 'drawEraseBtn')) return;
    
    if (appState.isEraserMode) {
        elements.drawEraseBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 5H9l-7 7 7 7h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2z"></path>
                <line x1="18" y1="9" x2="12" y2="15"></line>
                <line x1="12" y1="9" x2="18" y2="15"></line>
            </svg>
            <span class="valorant-text">지우기</span>
            <span class="tooltip-text">단축키: Q</span>
        `;
        utils.showToast('지우기 모드로 전환했습니다', 'info');
    } else {
        elements.drawEraseBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                <path d="M2 2l7.586 7.586"></path>
                <circle cx="11" cy="11" r="2"></circle>
            </svg>
            <span class="valorant-text">그리기</span>
            <span class="tooltip-text">단축키: Q</span>
        `;
        utils.showToast('그리기 모드로 전환했습니다', 'info');
    }
    
    // 브러시 커서 업데이트
    if (appState.lastMousePosition) {
        const event = {
            pageX: appState.lastMousePosition.x,
            pageY: appState.lastMousePosition.y
        };
        updateBrushCursor(event);
    }
}

// 설정 UI 업데이트
function updateSettingsUI() {
    if (!utils.validateElement(elements.cellSizeRange, 'cellSizeRange') ||
        !utils.validateElement(elements.cellSizeValue, 'cellSizeValue') ||
        !utils.validateElement(elements.brushSizeRange, 'brushSizeRange') ||
        !utils.validateElement(elements.brushSizeValue, 'brushSizeValue') ||
        !utils.validateElement(elements.brushSizeDisplay, 'brushSizeDisplay') ||
        !utils.validateElement(elements.bgModeSwitch, 'bgModeSwitch') ||
        !utils.validateElement(elements.customModeSwitch, 'customModeSwitch') ||
        !utils.validateElement(elements.customEmojiSettings, 'customEmojiSettings')) {
        return;
    }
    
    elements.cellSizeRange.value = settings.cellSize;
    elements.cellSizeValue.textContent = `${settings.cellSize}px`;
    
    elements.brushSizeRange.value = settings.brushSize;
    elements.brushSizeValue.textContent = settings.brushSize;
    elements.brushSizeDisplay.textContent = settings.brushSize;
    
    elements.bgModeSwitch.checked = settings.bgMode === 'transparent';
    elements.customModeSwitch.checked = settings.customMode;
    
    // 커스텀 이모지 설정 UI 업데이트
    elements.customEmojiSettings.style.display = settings.customMode ? 'block' : 'none';
    
    if (utils.validateElement(elements.filledEmojiInput, 'filledEmojiInput') &&
        utils.validateElement(elements.emptyEmojiInput, 'emptyEmojiInput')) {
        
        if (settings.customMode) {
            elements.filledEmojiInput.value = settings.filledEmoji;
            elements.emptyEmojiInput.value = settings.emptyEmoji;
            
            // 커스텀 모드가 켜져 있으면 배경 투명 모드 비활성화
            elements.bgModeSwitch.checked = false;
            elements.bgModeSwitch.disabled = true;
            settings.bgMode = 'rectangle';
        } else {
            elements.bgModeSwitch.disabled = false;
        }
    }
}

// 파일 저장 다이얼로그
function openSaveDialog() {
    if (!utils.validateElement(elements.fileModal, 'fileModal') ||
        !utils.validateElement(elements.fileModalTitle, 'fileModalTitle') ||
        !utils.validateElement(elements.fileActionBtn, 'fileActionBtn') ||
        !utils.validateElement(elements.saveFormGroup, 'saveFormGroup') ||
        !utils.validateElement(elements.fileListGroup, 'fileListGroup') ||
        !utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') ||
        !utils.validateElement(elements.fileExportBtn, 'fileExportBtn') ||
        !utils.validateElement(elements.fileNameInput, 'fileNameInput')) {
        utils.showToast('파일 저장 다이얼로그를 열 수 없습니다', 'error');
        return;
    }
    
    elements.fileModalTitle.textContent = '파일 저장';
    elements.fileActionBtn.textContent = '저장';
    elements.saveFormGroup.style.display = 'block';
    elements.fileListGroup.style.display = 'none';
    elements.fileDeleteBtn.style.display = 'none';
    elements.fileExportBtn.style.display = 'none';
    
    elements.fileNameInput.value = '';
    
    // 파일 목록 로드
    loadFileList(false);
    
    utils.showModal(elements.fileModal);
}

// 파일 불러오기 다이얼로그
function openLoadDialog() {
    if (!utils.validateElement(elements.fileModal, 'fileModal') ||
        !utils.validateElement(elements.fileModalTitle, 'fileModalTitle') ||
        !utils.validateElement(elements.fileActionBtn, 'fileActionBtn') ||
        !utils.validateElement(elements.saveFormGroup, 'saveFormGroup') ||
        !utils.validateElement(elements.fileListGroup, 'fileListGroup') ||
        !utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') ||
        !utils.validateElement(elements.fileExportBtn, 'fileExportBtn')) {
        utils.showToast('파일 불러오기 다이얼로그를 열 수 없습니다', 'error');
        return;
    }
    
    elements.fileModalTitle.textContent = '파일 불러오기';
    elements.fileActionBtn.textContent = '불러오기';
    elements.saveFormGroup.style.display = 'none';
    elements.fileListGroup.style.display = 'block';
    elements.fileDeleteBtn.style.display = 'inline-block';
    elements.fileExportBtn.style.display = 'inline-block';
    
    // 파일 목록 로드
    loadFileList(true);
    
    utils.showModal(elements.fileModal);
}

// 내보내기/가져오기 다이얼로그
function openExportImportDialog() {
    if (!utils.validateElement(elements.exportImportModal, 'exportImportModal') ||
        !utils.validateElement(elements.exportImportTitle, 'exportImportTitle') ||
        !utils.validateElement(elements.importFileInput, 'importFileInput') ||
        !utils.validateElement(elements.exportFileNameGroup, 'exportFileNameGroup') ||
        !utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn') ||
        !utils.validateElement(elements.importConfirm, 'importConfirm') ||
        !utils.validateElement(elements.filePreviewContainer, 'filePreviewContainer') ||
        !utils.validateElement(elements.importConfirmCheck, 'importConfirmCheck') ||
        !utils.validateElement(elements.fileAuthorText, 'fileAuthorText') ||
        !utils.validateElement(elements.fileVersionText, 'fileVersionText')) {
        utils.showToast('내보내기/가져오기 다이얼로그를 열 수 없습니다', 'error');
        return;
    }
    
    // UI 초기화
    elements.exportImportTitle.textContent = '파일 내보내기/가져오기';
    elements.importFileInput.style.display = 'none';
    elements.exportFileNameGroup.style.display = 'none';
    elements.executeExportImportBtn.style.display = 'none';
    elements.importConfirm.style.display = 'none';
    elements.filePreviewContainer.style.display = 'none';
    elements.importConfirmCheck.checked = false;
    
    // 파일 작성자 정보 표시
    elements.fileAuthorText.textContent = settings.author || api.getUsername() || '비회원';
    elements.fileVersionText.textContent = CONFIG.APP_VERSION;
    
    utils.showModal(elements.exportImportModal);
}

// 파일 목록 로드
function loadFileList(showPreview) {
    if (!utils.validateElement(elements.fileList, 'fileList')) {
        utils.showToast('파일 목록을 로드할 수 없습니다', 'error');
        return;
    }
    
    const fileList = elements.fileList;
    fileList.innerHTML = '';
    
    const files = utils.storage.getFileList();
    
    if (files.length === 0) {
        const emptyElement = document.createElement('div');
        emptyElement.className = 'file-item';
        emptyElement.textContent = '저장된 파일이 없습니다';
        fileList.appendChild(emptyElement);
        
        // 불러오기 버튼 비활성화
        if (showPreview && utils.validateElement(elements.fileActionBtn, 'fileActionBtn') &&
            utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') &&
            utils.validateElement(elements.fileExportBtn, 'fileExportBtn')) {
            elements.fileActionBtn.disabled = true;
            elements.fileDeleteBtn.disabled = true;
            elements.fileExportBtn.disabled = true;
        }
        
        // 미리보기 초기화
        if (utils.validateElement(elements.filePreview, 'filePreview')) {
            elements.filePreview.innerHTML = '';
        }
        
        return;
    }
    
    // 불러오기 버튼 활성화
    if (showPreview && utils.validateElement(elements.fileActionBtn, 'fileActionBtn') &&
        utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') &&
        utils.validateElement(elements.fileExportBtn, 'fileExportBtn')) {
        elements.fileActionBtn.disabled = false;
        elements.fileDeleteBtn.disabled = true;  // 파일 선택 전에는 비활성화
        elements.fileExportBtn.disabled = true;  // 파일 선택 전에는 비활성화
    }
    
    // 파일 목록 생성
    files.forEach(fileName => {
        // VAL 파일만 표시
        if (fileName.endsWith('.val')) {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.dataset.fileName = fileName;
            
            // 파일명 표시 (확장자 제외)
            const fileNameSpan = document.createElement('span');
            fileNameSpan.textContent = fileName.replace(/\.val$/, '');
            fileItem.appendChild(fileNameSpan);
            
            // XSS 방지
            fileNameSpan.textContent = utils.escapeHtml(fileNameSpan.textContent);
            
            fileItem.addEventListener('click', function() {
                // 선택 스타일 적용
                const items = fileList.querySelectorAll('.file-item');
                items.forEach(item => item.classList.remove('selected'));
                fileItem.classList.add('selected');
                
                // 미리보기 표시 (불러오기 모드일 때만)
                if (showPreview && utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') &&
                    utils.validateElement(elements.fileExportBtn, 'fileExportBtn') &&
                    utils.validateElement(elements.fileActionBtn, 'fileActionBtn')) {
                    const fileData = utils.storage.loadFile(fileName);
                    if (fileData) {
                        showFilePreview(fileData);
                        elements.fileDeleteBtn.disabled = false;  // 파일 선택 시 삭제 버튼 활성화
                        elements.fileExportBtn.disabled = false;  // 파일 선택 시 내보내기 버튼 활성화
                        elements.fileActionBtn.disabled = false;  // 파일 선택 시 불러오기 버튼 활성화
                    }
                }
            });
            
            fileList.appendChild(fileItem);
        }
    });
    
    // 표시할 파일이 없는 경우
    if (fileList.children.length === 0) {
        const emptyElement = document.createElement('div');
        emptyElement.className = 'file-item';
        emptyElement.textContent = '저장된 파일이 없습니다';
        fileList.appendChild(emptyElement);
        
        // 불러오기 버튼 비활성화
        if (showPreview && utils.validateElement(elements.fileActionBtn, 'fileActionBtn') &&
            utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn') &&
            utils.validateElement(elements.fileExportBtn, 'fileExportBtn')) {
            elements.fileActionBtn.disabled = true;
            elements.fileDeleteBtn.disabled = true;
            elements.fileExportBtn.disabled = true;
        }
    }
}

// 파일 미리보기 표시
function showFilePreview(data) {
    if (!utils.validateElement(elements.filePreview, 'filePreview')) {
        return;
    }
    
    const preview = elements.filePreview;
    preview.innerHTML = '';
    
    // 이모지 미리보기
    const previewDiv = document.createElement('div');
    previewDiv.style.fontFamily = 'monospace';
    previewDiv.style.lineHeight = '1';
    previewDiv.style.whiteSpace = 'pre';
    
    try {
        let previewContent = '';
        if (data.board && Array.isArray(data.board)) {
            for (let r = 0; r < data.board.length; r++) {
                let rowText = '';
                for (let c = 0; c < data.board[r].length; c++) {
                    if (data.board[r][c] === '■') {
                        rowText += data.settings && data.settings.customMode ? 
                            data.settings.filledEmoji : '■';
                    } else {
                        const emptyChar = data.settings && data.settings.bgMode === 'transparent' ? 
                            settings.transparentChar : 
                            (data.settings && data.settings.customMode ? data.settings.emptyEmoji : '□');
                        rowText += emptyChar;
                    }
                }
                previewContent += rowText + '\n';
            }
            
            previewDiv.textContent = previewContent;
            preview.appendChild(previewDiv);
        } else {
            preview.textContent = '미리보기를 표시할 수 없습니다';
        }
    } catch (error) {
        console.error('미리보기 생성 오류:', error);
        preview.textContent = '미리보기 생성 중 오류가 발생했습니다';
    }
}

// 파일 저장 실행
function saveFile(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.fileNameInput, 'fileNameInput')) {
        utils.showToast('파일 이름 입력 필드를 찾을 수 없습니다', 'error');
        return;
    }
    
    const fileName = utils.sanitizeFileName(elements.fileNameInput.value);
    
    if (!fileName) {
        utils.showToast('파일 이름을 입력해주세요', 'error');
        return;
    }
    
    // 파일 데이터 준비
    const data = canvasRenderer.exportCanvasData();
    if (!data) {
        utils.showToast('캔버스 데이터를 가져올 수 없습니다', 'error');
        return;
    }
    
    // 작성자 정보 추가
    data.author = settings.author || api.getUsername() || '비회원';
    data.version = CONFIG.APP_VERSION;
    data.timestamp = new Date().toISOString();
    
    // 파일 확장자 추가
    const fullFileName = `${fileName}.val`;
    
    // 저장
    if (utils.storage.saveFile(fullFileName, data)) {
        utils.showToast(`${fileName}.val 파일이 저장되었습니다`, 'success');
        utils.hideModal(elements.fileModal);
    }
}

// 파일 불러오기 실행
function loadFile() {
    if (!utils.validateElement(elements.fileList, 'fileList')) {
        utils.showToast('파일 목록을 찾을 수 없습니다', 'error');
        return;
    }
    
    // 선택된 파일 확인
    const selectedItem = elements.fileList.querySelector('.file-item.selected');
    if (!selectedItem) {
        utils.showToast('불러올 파일을 선택해주세요', 'error');
        return;
    }
    
    const fileName = selectedItem.dataset.fileName;
    const data = utils.storage.loadFile(fileName);
    
    if (data) {
        if (canvasRenderer.importCanvasData(data)) {
            utils.showToast(`${fileName} 파일을 불러왔습니다`, 'success');
            utils.hideModal(elements.fileModal);
        }
    }
}

// 파일 삭제 실행
function deleteFile() {
    if (!utils.validateElement(elements.fileList, 'fileList')) {
        utils.showToast('파일 목록을 찾을 수 없습니다', 'error');
        return;
    }
    
    // 선택된 파일 확인
    const selectedItem = elements.fileList.querySelector('.file-item.selected');
    if (!selectedItem) {
        utils.showToast('삭제할 파일을 선택해주세요', 'error');
        return;
    }
    
    const fileName = selectedItem.dataset.fileName;
    
    // 확인 메시지
    if (confirm(`'${fileName}' 파일을 삭제하시겠습니까?`)) {
        if (utils.storage.deleteFile(fileName)) {
            // 파일 목록 다시 로드
            loadFileList(true);
            utils.showToast(`${fileName} 파일이 삭제되었습니다`, 'success');
        }
    }
}

// 선택된 파일 내보내기
function exportSelectedFile() {
    if (!utils.validateElement(elements.fileList, 'fileList')) {
        utils.showToast('파일 목록을 찾을 수 없습니다', 'error');
        return;
    }
    
    // 선택된 파일 확인
    const selectedItem = elements.fileList.querySelector('.file-item.selected');
    if (!selectedItem) {
        utils.showToast('내보낼 파일을 선택해주세요', 'error');
        return;
    }
    
    const fileName = selectedItem.dataset.fileName;
    const data = utils.storage.loadFile(fileName);
    
    if (data) {
        try {
            // 작성자 정보 확인
            if (!data.author) {
                data.author = settings.author || api.getUsername() || '비회원';
            }
            if (!data.version) {
                data.version = CONFIG.APP_VERSION;
            }
            if (!data.timestamp) {
                data.timestamp = new Date().toISOString();
            }
            
            // 보안 검증
            const sanitizedData = JSON.stringify(data, null, 2);
            const safeData = sanitizedData.replace(/<\/?script/gi, '&lt;script');
            
            // JSON 데이터를 Blob으로 변환
            const blob = new Blob([safeData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // 다운로드 링크 생성 및 클릭
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            
            // 정리
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            utils.showToast(`${fileName} 파일이 다운로드되었습니다`, 'success');
        } catch (error) {
            console.error('파일 내보내기 오류:', error);
            utils.showToast('파일 내보내기 중 오류가 발생했습니다', 'error');
        }
    }
}

// 파일 가져오기 UI 표시
function showImportUI() {
    if (!utils.validateElement(elements.importFileInput, 'importFileInput') ||
        !utils.validateElement(elements.exportFileNameGroup, 'exportFileNameGroup') ||
        !utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn') ||
        !utils.validateElement(elements.importConfirm, 'importConfirm') ||
        !utils.validateElement(elements.filePreviewContainer, 'filePreviewContainer') ||
        !utils.validateElement(elements.fileInput, 'fileInput')) {
        utils.showToast('가져오기 UI를 표시할 수 없습니다', 'error');
        return;
    }
    
    elements.importFileInput.style.display = 'block';
    elements.exportFileNameGroup.style.display = 'none';
    elements.executeExportImportBtn.style.display = 'inline-block';
    elements.executeExportImportBtn.textContent = '가져오기';
    elements.executeExportImportBtn.disabled = true; // 파일 선택 전까지 비활성화
    elements.importConfirm.style.display = 'none';
    elements.filePreviewContainer.style.display = 'none';
    
    // 파일 선택 이벤트 리스너 초기화
    const fileInput = elements.fileInput;
    fileInput.value = ''; // 입력 초기화
    
    fileInput.onchange = function() {
        const file = fileInput.files[0];
        if (file) {
            if (!file.name.toLowerCase().endsWith('.val')) {
                utils.showToast('VAL 형식의 파일만 가져올 수 있습니다', 'error');
                fileInput.value = '';
                elements.executeExportImportBtn.disabled = true;
                return;
            }
            
            // 파일 크기 제한 검사
            if (file.size > 1024 * 1024) { // 1MB 제한
                utils.showToast('파일 크기가 너무 큽니다. 1MB 이하의 파일만 가져올 수 있습니다.', 'error');
                fileInput.value = '';
                elements.executeExportImportBtn.disabled = true;
                return;
            }
            
            // 파일 읽기
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // 주의: JSON 파싱 전에 XSS 취약점 대비
                    const content = e.target.result;
                    if (/<\/?script/i.test(content)) {
                        throw new Error('보안상의 이유로 스크립트가 포함된 파일은 허용되지 않습니다.');
                    }
                    
                    const data = JSON.parse(content);
                    
                    // 유효한 VAL 파일인지 확인
                    if (!data.board || !data.settings) {
                        utils.showToast('유효하지 않은 VAL 파일입니다', 'error');
                        fileInput.value = '';
                        elements.executeExportImportBtn.disabled = true;
                        return;
                    }
                    
                    // 미리보기 표시
                    if (utils.validateElement(elements.filePreviewContainer, 'filePreviewContainer') &&
                        utils.validateElement(elements.importPreview, 'importPreview') &&
                        utils.validateElement(elements.importConfirm, 'importConfirm') &&
                        utils.validateElement(elements.importConfirmCheck, 'importConfirmCheck') &&
                        utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn') &&
                        utils.validateElement(elements.fileAuthorText, 'fileAuthorText') &&
                        utils.validateElement(elements.fileVersionText, 'fileVersionText')) {
                        
                        elements.filePreviewContainer.style.display = 'block';
                        showImportPreview(data);
                        
                        // 확인 메시지 표시
                        elements.importConfirm.style.display = 'block';
                        elements.importConfirmCheck.checked = false;
                        elements.executeExportImportBtn.disabled = true;
                        
                        // 확인 체크박스 이벤트
                        elements.importConfirmCheck.onchange = function() {
                            elements.executeExportImportBtn.disabled = !this.checked;
                        };
                        
                        // 제작자 정보 표시
                        elements.fileAuthorText.textContent = data.author || '알 수 없음';
                        elements.fileVersionText.textContent = data.version || '알 수 없음';
                    }
                } catch (error) {
                    console.error('파일 읽기 오류:', error);
                    utils.showToast('파일을 읽는 중 오류가 발생했습니다. 유효한 VAL 파일인지 확인하세요.', 'error');
                    fileInput.value = '';
                    elements.executeExportImportBtn.disabled = true;
                }
            };
            
            reader.onerror = function() {
                utils.showToast('파일을 읽는 중 오류가 발생했습니다', 'error');
                fileInput.value = '';
                elements.executeExportImportBtn.disabled = true;
            };
            
            reader.readAsText(file);
        } else {
            if (utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn') &&
                utils.validateElement(elements.importConfirm, 'importConfirm') &&
                utils.validateElement(elements.filePreviewContainer, 'filePreviewContainer')) {
                elements.executeExportImportBtn.disabled = true;
                elements.importConfirm.style.display = 'none';
                elements.filePreviewContainer.style.display = 'none';
            }
        }
    };
}

// 내보내기 UI 표시
function showExportUI() {
    if (!utils.validateElement(elements.exportFileNameGroup, 'exportFileNameGroup') ||
        !utils.validateElement(elements.importFileInput, 'importFileInput') ||
        !utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn') ||
        !utils.validateElement(elements.importConfirm, 'importConfirm') ||
        !utils.validateElement(elements.filePreviewContainer, 'filePreviewContainer') ||
        !utils.validateElement(elements.exportFileName, 'exportFileName')) {
        utils.showToast('내보내기 UI를 표시할 수 없습니다', 'error');
        return;
    }
    
    elements.exportFileNameGroup.style.display = 'block';
    elements.importFileInput.style.display = 'none';
    elements.executeExportImportBtn.style.display = 'inline-block';
    elements.executeExportImportBtn.textContent = '내보내기';
    elements.executeExportImportBtn.disabled = false;
    elements.importConfirm.style.display = 'none';
    elements.filePreviewContainer.style.display = 'none';
    
    // 파일명 입력 필드 초기화
    elements.exportFileName.value = '';
}

// 가져오기 미리보기 표시
function showImportPreview(data) {
    if (!utils.validateElement(elements.importPreview, 'importPreview')) {
        return;
    }
    
    const preview = elements.importPreview;
    preview.innerHTML = '';
    
    // 이모지 미리보기
    const previewDiv = document.createElement('div');
    previewDiv.style.fontFamily = 'monospace';
    previewDiv.style.lineHeight = '1';
    previewDiv.style.whiteSpace = 'pre';
    
    try {
        let previewContent = '';
        if (data.board && Array.isArray(data.board)) {
            // 미리보기 제한 (첫 10줄만 표시)
            const maxRows = Math.min(data.board.length, 10);
            
            for (let r = 0; r < maxRows; r++) {
                let rowText = '';
                // 한 줄당 최대 30개 문자만 표시
                const maxCols = Math.min(data.board[r].length, 30);
                
                for (let c = 0; c < maxCols; c++) {
                    if (data.board[r][c] === '■') {
                        rowText += data.settings && data.settings.customMode ? 
                            data.settings.filledEmoji : '■';
                    } else {
                        const emptyChar = data.settings && data.settings.bgMode === 'transparent' ? 
                            settings.transparentChar : 
                            (data.settings && data.settings.customMode ? data.settings.emptyEmoji : '□');
                        rowText += emptyChar;
                    }
                }
                
                // 길이가 30을 초과하면 ...추가
                if (data.board[r].length > 30) {
                    rowText += '...';
                }
                
                previewContent += rowText + '\n';
            }
            
            // 행이 10개를 초과하면 ...추가
            if (data.board.length > 10) {
                previewContent += '...\n';
            }
            
            previewDiv.textContent = previewContent;
            preview.appendChild(previewDiv);
        } else {
            preview.textContent = '미리보기를 표시할 수 없습니다';
        }
    } catch (error) {
        console.error('미리보기 생성 오류:', error);
        preview.textContent = '미리보기 생성 중 오류가 발생했습니다';
    }
}

// 파일 내보내기 실행
function exportFile(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.exportFileName, 'exportFileName')) {
        utils.showToast('파일 이름 입력 필드를 찾을 수 없습니다', 'error');
        return;
    }
    
    const filename = elements.exportFileName.value.trim();
    
    if (!filename) {
        utils.showToast('내보낼 파일 이름을 입력해주세요', 'error');
        return;
    }
    
    // 파일 이름 검증
    const sanitizedFilename = utils.sanitizeFileName(filename);
    if (sanitizedFilename !== filename) {
        utils.showToast('파일 이름에 유효하지 않은 문자가 포함되어 있습니다', 'warning');
    }
    
    try {
        // 현재 캔버스 데이터 가져오기
        const data = canvasRenderer.exportCanvasData();
        if (!data) {
            utils.showToast('캔버스 데이터를 가져올 수 없습니다', 'error');
            return;
        }
        
        // 작성자 정보 추가
        data.author = settings.author || api.getUsername() || '비회원';
        data.version = CONFIG.APP_VERSION;
        data.timestamp = new Date().toISOString();
        
        // JSON 데이터를 Blob으로 변환
        const jsonData = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        // 다운로드 링크 생성 및 클릭
        const a = document.createElement('a');
        a.href = url;
        a.download = `${sanitizedFilename}.val`;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        
        // 정리
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        utils.showToast(`${sanitizedFilename}.val 파일이 다운로드되었습니다`, 'success');
        
        if (utils.validateElement(elements.exportImportModal, 'exportImportModal')) {
            utils.hideModal(elements.exportImportModal);
        }
    } catch (error) {
        console.error('파일 내보내기 오류:', error);
        utils.showToast('파일 내보내기 중 오류가 발생했습니다', 'error');
    }
}

// 파일 가져오기 실행
function importFile(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.fileInput, 'fileInput') ||
        !utils.validateElement(elements.importConfirmCheck, 'importConfirmCheck') ||
        !utils.validateElement(elements.exportImportModal, 'exportImportModal')) {
        utils.showToast('파일 입력 필드를 찾을 수 없습니다', 'error');
        return;
    }
    
    const fileInput = elements.fileInput;
    const file = fileInput.files[0];
    
    if (!file) {
        utils.showToast('가져올 파일을 선택해주세요', 'error');
        return;
    }
    
    // 확인 체크박스 확인
    if (!elements.importConfirmCheck.checked) {
        utils.showToast('가져오기 확인에 동의해주세요', 'warning');
        return;
    }
    
    // .val 확장자 체크
    if (!file.name.toLowerCase().endsWith('.val')) {
        utils.showToast('VAL 형식의 파일만 가져올 수 있습니다', 'error');
        return;
    }
    
    // 파일 크기 제한 검사
    if (file.size > 1024 * 1024) { // 1MB 제한
        utils.showToast('파일 크기가 너무 큽니다. 1MB 이하의 파일만 가져올 수 있습니다.', 'error');
        return;
    }
    
    const reader = new FileReader();
    
    reader.onload = function(e) {
        try {
            // 주의: JSON 파싱 전에 XSS 취약점 대비
            const content = e.target.result;
            if (/<\/?script/i.test(content)) {
                throw new Error('보안상의 이유로 스크립트가 포함된 파일은 허용되지 않습니다.');
            }
            
            const data = JSON.parse(content);
            
            // 유효한 VAL 파일인지 확인
            if (!data.board || !data.settings) {
                utils.showToast('유효하지 않은 VAL 파일입니다', 'error');
                return;
            }
            
            // 캔버스에 불러오기
            if (canvasRenderer.importCanvasData(data)) {
                utils.showToast(`${file.name} 파일을 불러왔습니다`, 'success');
                utils.hideModal(elements.exportImportModal);
                
                // 파일 이름으로 저장 (확장자 제외)
                if (utils.validateElement(elements.fileNameInput, 'fileNameInput')) {
                    const baseName = file.name.replace(/\.val$/i, '');
                    elements.fileNameInput.value = baseName;
                }
            } else {
                utils.showToast('파일을 불러오는 데 실패했습니다', 'error');
            }
        } catch (error) {
            console.error('파일 가져오기 오류:', error);
            utils.showToast('파일 가져오기 중 오류가 발생했습니다. 파일이 손상되었거나 유효하지 않은 형식입니다.', 'error');
        }
    };
    
    reader.onerror = function() {
        utils.showToast('파일을 읽는 중 오류가 발생했습니다', 'error');
    };
    
    reader.readAsText(file);
}

// 복사 기능 (이모지 텍스트만 복사)
function copyCanvas() {
    try {
        // 캔버스를 이모지 텍스트로 변환
        const canvasText = canvasRenderer.getCanvasAsText();
        
        // 클립보드 API 사용 가능 여부 확인
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(canvasText)
                .then(() => {
                    utils.showToast('캔버스가 클립보드에 복사되었습니다', 'success');
                })
                .catch(error => {
                    console.error('클립보드 API 오류:', error);
                    fallbackCopy(canvasText);
                });
        } else {
            console.log('클립보드 API 사용 불가: navigator.clipboard를 지원하지 않습니다');
            fallbackCopy(canvasText);
        }
    } catch (error) {
        console.error('복사 오류:', error);
        utils.showToast('복사 중 오류가 발생했습니다', 'error');
    }
}

// 대체 복사 방법
function fallbackCopy(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    
    // 임시 텍스트 영역 스타일 설정
    textArea.style.position = 'fixed';
    textArea.style.top = '-9999px';
    textArea.style.left = '-9999px';
    
    document.body.appendChild(textArea);
    textArea.select();
    
    let success = false;
    try {
        success = document.execCommand('copy');
        if (success) {
            utils.showToast('캔버스가 클립보드에 복사되었습니다', 'success');
        } else {
            utils.showToast('클립보드에 복사할 수 없습니다. 브라우저 설정을 확인하세요', 'error');
        }
    } catch (error) {
        console.error('execCommand 복사 실패:', error);
        utils.showToast('클립보드 복사가 지원되지 않습니다', 'error');
    } finally {
        document.body.removeChild(textArea);
    }
}

// 설정 변경 적용
function applySettings(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.cellSizeRange, 'cellSizeRange') ||
        !utils.validateElement(elements.brushSizeRange, 'brushSizeRange') ||
        !utils.validateElement(elements.bgModeSwitch, 'bgModeSwitch') ||
        !utils.validateElement(elements.customModeSwitch, 'customModeSwitch') ||
        !utils.validateElement(elements.settingsModal, 'settingsModal') ||
        !utils.validateElement(elements.brushSizeDisplay, 'brushSizeDisplay')) {
        utils.showToast('설정 요소를 찾을 수 없습니다', 'error');
        return;
    }
    
    // 이전 설정 백업
    const oldSettings = { ...settings };
    
    // 새 설정 가져오기
    settings.cellSize = parseInt(elements.cellSizeRange.value) || CONFIG.DEFAULT_CELL_SIZE;
    settings.brushSize = parseInt(elements.brushSizeRange.value) || 1;
    settings.bgMode = elements.bgModeSwitch.checked ? 'transparent' : 'rectangle';
    settings.customMode = elements.customModeSwitch.checked;
    
    if (settings.customMode && 
        utils.validateElement(elements.filledEmojiInput, 'filledEmojiInput') &&
        utils.validateElement(elements.emptyEmojiInput, 'emptyEmojiInput')) {
        
        const filledEmoji = elements.filledEmojiInput.value;
        const emptyEmoji = elements.emptyEmojiInput.value;
        
        if (filledEmoji && emptyEmoji) {
            // 이모지 유효성 검사 (한 글자만 허용)
            settings.filledEmoji = filledEmoji.charAt(0);
            settings.emptyEmoji = emptyEmoji.charAt(0);
            
            if (filledEmoji.length > 1 || emptyEmoji.length > 1) {
                utils.showToast('이모지는 한 글자만 사용할 수 있습니다. 첫 글자만 적용됩니다.', 'warning');
            }
        }
        
        // 커스텀 모드일 때는 배경 투명 모드 끄기
        settings.bgMode = 'rectangle';
    } else {
        settings.filledEmoji = '■';
        settings.emptyEmoji = '□';
    }
    
    // 설정이 변경되었으면 캔버스 다시 그리기
    if (
        oldSettings.cellSize !== settings.cellSize ||
        oldSettings.bgMode !== settings.bgMode ||
        oldSettings.customMode !== settings.customMode ||
        oldSettings.filledEmoji !== settings.filledEmoji ||
        oldSettings.emptyEmoji !== settings.emptyEmoji
    ) {
        canvasRenderer.initCanvas();
    } else if (oldSettings.brushSize !== settings.brushSize) {
        // 브러시 크기만 변경됐을 경우 DOM 요소 업데이트
        elements.brushSizeDisplay.textContent = settings.brushSize;
        
        // 브러시 커서 업데이트
        if (appState.lastMousePosition) {
            const event = {
                pageX: appState.lastMousePosition.x,
                pageY: appState.lastMousePosition.y
            };
            updateBrushCursor(event);
        }
    }
    
    // UI 요소 업데이트
    elements.brushSizeDisplay.textContent = settings.brushSize;
    
    // 설정 저장
    utils.storage.saveSettings(settings);
    
    utils.hideModal(elements.settingsModal);
    utils.showToast('설정이 저장되었습니다', 'success');
}

// 브러시 커서 업데이트
function updateBrushCursor(event) {
    if (!appState.showBrushCursor || !utils.validateElement(elements.brushCursor, 'brushCursor')) return;
    
    const cursor = elements.brushCursor;
    const size = Math.max(10, settings.brushSize * 10);
    
    cursor.style.width = `${size}px`;
    cursor.style.height = `${size}px`;
    cursor.style.left = `${event.pageX}px`;
    cursor.style.top = `${event.pageY}px`;
    
    // 지우기 모드면 스타일 변경
    if (appState.isEraserMode) {
        cursor.style.border = '2px dashed var(--accent-color)';
        cursor.style.backgroundColor = 'rgba(255, 70, 85, 0.1)';
    } else {
        cursor.style.border = '2px solid var(--accent-color)';
        cursor.style.backgroundColor = 'rgba(255, 70, 85, 0.2)';
    }
    
    // 마우스 위치 저장
    appState.lastMousePosition = { x: event.pageX, y: event.pageY };
}

// API 서비스
const api = {
    // 토큰 관리
    authToken: null,
    
    // 초기화
    async init() {
        try {
            // 세션 데이터 복원
            const session = utils.storage.getSessionData();
            if (session && session.token && session.userId && session.expiry > Date.now()) {
                appState.authToken = session.token;
                appState.userId = session.userId;
                appState.isAuthenticated = true;
                
                // 사용자 정보 로드
                await this.loadUserInfo();
                
                // 즐겨찾기 로드
                await this.loadFavorites();
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('API 초기화 오류:', error);
            return false;
        }
    },
    
    // 사용자 정보 로드
    async loadUserInfo() {
        try {
            if (!appState.userId || !appState.isAuthenticated) {
                return false;
            }
            
            // Supabase에서 사용자 정보 조회
            const { data, error } = await supabase
                .from('users')
                .select('username')
                .eq('id', appState.userId)
                .single();
            
            if (error) throw error;
            
            if (data && data.username) {
                appState.userName = data.username;
                
                // 로컬 스토리지 업데이트
                localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, data.username);
                
                // 설정에 작가명 저장
                settings.author = data.username;
                utils.storage.saveSettings(settings);
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('사용자 정보 로드 오류:', error);
            return false;
        }
    },
    
    // 인증 상태 확인
    isAuthenticated() {
        return appState.isAuthenticated && 
               appState.userId && 
               utils.isSessionValid();
    },
    
    // 사용자명 가져오기
    getUsername() {
        return appState.userName || localStorage.getItem(CONFIG.STORAGE_KEYS.USERNAME) || '';
    },
    
    // 사용자 ID 가져오기
    getUserId() {
        return appState.userId || localStorage.getItem(CONFIG.STORAGE_KEYS.USER_ID) || '';
    },
    
    // 비밀번호 해시 생성 (더 강력한 보안)
    async hashPassword(password) {
        if (!password) return '';
        
        // 보안 솔트 추가
        const secretSalt = CONFIG.SECURITY.HASH_SALT_PREFIX;
        const encoder = new TextEncoder();
        const data = encoder.encode(password + secretSalt);
        
        try {
            // Web Crypto API 사용해 SHA-256 해시 생성
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            
            // ArrayBuffer를 16진수 문자열로 변환
            return Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        } catch (error) {
            console.error('보안 해시 생성 오류:', error);
            
            // 폴백 해시 방식 (절대 최종 제품에서 사용하지 마세요)
            let hash = '';
            for (let i = 0; i < 10; i++) { // 간단한 반복 해싱
                const tempData = password + secretSalt + i;
                for (let j = 0; j < tempData.length; j++) {
                    hash += tempData.charCodeAt(j).toString(16);
                }
            }
            return hash.substring(0, 64); // 64자로 자르기
        }
    },
    
    // 사용자 등록
    async registerUser(username, password) {
        try {
            // 입력 유효성 검사
            const usernameValidation = utils.validateUsername(username);
            if (!usernameValidation.valid) {
                return { success: false, message: usernameValidation.message };
            }
            
            const passwordValidation = utils.validatePassword(password);
            if (!passwordValidation.valid) {
                return { success: false, message: passwordValidation.message };
            }
            
            // CSRF 토큰 생성
            const csrfToken = utils.generateCSRFToken();
            
            // 비밀번호 해시 생성
            const passwordHash = await this.hashPassword(password);
            
            // Supabase를 통해, 중복 사용자명 확인
            const { data: existingUser, error: checkError } = await supabase
                .from('users')
                .select('id')
                .eq('username', username)
                .maybeSingle();
            
            if (checkError) throw checkError;
            
            if (existingUser) {
                return { success: false, message: '이미 사용 중인 사용자명입니다' };
            }
            
            // 사용자 생성
            const { data, error } = await supabase
                .from('users')
                .insert([{
                    username,
                    password_hash: passwordHash,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString()
                }])
                .select();
            
            if (error) {
                console.error('사용자 등록 DB 오류:', error);
                throw error;
            }
            
            if (!data || data.length === 0) {
                return { success: false, message: '사용자 등록에 실패했습니다' };
            }
            
            const userId = data[0].id;
            
            // 로그인 세션 생성
            const expiryTime = Date.now() + CONFIG.SECURITY.SESSION_DURATION;
            
            // 세션 저장
            appState.userId = userId;
            appState.userName = username;
            appState.isAuthenticated = true;
            
            // 로컬 스토리지에 저장
            utils.storage.saveSessionData(csrfToken, userId, expiryTime);
            localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, username);
            
            // 설정에 작가명 저장
            settings.author = username;
            utils.storage.saveSettings(settings);
            
            return { success: true, userId };
        } catch (error) {
            console.error('사용자 등록 오류:', error);
            return { 
                success: false,
                message: error.message || '사용자 등록 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 사용자 로그인
    async loginUser(username, password) {
        try {
            // 입력 유효성 검사
            if (!username || !password) {
                return { success: false, message: '사용자명과 비밀번호가 필요합니다' };
            }
            
            // 비밀번호 해시 생성
            const passwordHash = await this.hashPassword(password);
            
            // CSRF 토큰 생성
            const csrfToken = utils.generateCSRFToken();
            
            // Supabase에서 사용자 조회
            const { data, error } = await supabase
                .from('users')
                .select('id, username')
                .eq('username', username)
                .eq('password_hash', passwordHash)
                .maybeSingle();
            
            if (error) throw error;
            
            if (!data) {
                // 실패한 로그인 시도 기록 (선택사항)
                console.warn('로그인 실패:', username);
                return { success: false, message: '사용자명 또는 비밀번호가 올바르지 않습니다' };
            }
            
            const userId = data.id;
            
            // 로그인 세션 생성
            const expiryTime = Date.now() + CONFIG.SECURITY.SESSION_DURATION;
            
            // 세션 저장
            appState.userId = userId;
            appState.userName = username;
            appState.isAuthenticated = true;
            
            // 로컬 스토리지에 저장
            utils.storage.saveSessionData(csrfToken, userId, expiryTime);
            localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, username);
            
            // 설정에 작가명 저장
            settings.author = username;
            utils.storage.saveSettings(settings);
            
            // 즐겨찾기 로드
            await this.loadFavorites();
            
            return { success: true, userId };
        } catch (error) {
            console.error('로그인 오류:', error);
            return { 
                success: false, 
                message: error.message || '로그인 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 로그아웃
    async logout() {
        try {
            // 세션 삭제
            appState.isAuthenticated = false;
            appState.userId = '';
            appState.userName = '';
            appState.authToken = null;
            appState.favorites = [];
            
            // 로컬 스토리지에서 세션 데이터 삭제
            utils.storage.clearSession();
            
            return { success: true };
        } catch (error) {
            console.error('로그아웃 오류:', error);
            return { 
                success: false,
                message: error.message || '로그아웃 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 비밀번호 검증
    async verifyPassword(password) {
        try {
            if (!this.isAuthenticated() || !appState.userId) {
                return false;
            }
            
            if (!password) {
                return false;
            }
            
            // 비밀번호 해시 생성
            const passwordHash = await this.hashPassword(password);
            
            // DB에서 비밀번호 확인
            const { data, error } = await supabase
                .from('users')
                .select('id')
                .eq('id', appState.userId)
                .eq('password_hash', passwordHash)
                .maybeSingle();
            
            if (error) throw error;
            
            return !!data;
        } catch (error) {
            console.error('비밀번호 검증 오류:', error);
            return false;
        }
    },
    
    // 계정 설정 업데이트
    async updateAccount(username, newPassword) {
        try {
            // 사용자 ID 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // 사용자명 유효성 검사
            if (username) {
                const validation = utils.validateUsername(username);
                if (!validation.valid) {
                    return { success: false, message: validation.message };
                }
                
                // 중복 사용자명 확인 (현재 사용자는 제외)
                const { data: existingUser, error: checkError } = await supabase
                    .from('users')
                    .select('id')
                    .eq('username', username)
                    .neq('id', userId)
                    .maybeSingle();
                
                if (checkError) throw checkError;
                
                if (existingUser) {
                    return { success: false, message: '이미 사용 중인 사용자명입니다' };
                }
            }
            
            // 비밀번호 유효성 검사
            let passwordHash = null;
            if (newPassword) {
                const validation = utils.validatePassword(newPassword);
                if (!validation.valid) {
                    return { success: false, message: validation.message };
                }
                
                // 비밀번호 해시 생성
                passwordHash = await this.hashPassword(newPassword);
            }
            
            // 업데이트할 필드 준비
            const updateFields = { 
                updated_at: new Date().toISOString() 
            };
            
            if (username) {
                updateFields.username = username;
            }
            
            if (passwordHash) {
                updateFields.password_hash = passwordHash;
            }
            
            // Supabase에서 사용자 정보 업데이트
            const { error } = await supabase
                .from('users')
                .update(updateFields)
                .eq('id', userId);
            
            if (error) throw error;
            
            // 로컬 상태 업데이트
            if (username) {
                appState.userName = username;
                localStorage.setItem(CONFIG.STORAGE_KEYS.USERNAME, username);
                
                // 설정에 작가명 업데이트
                settings.author = username;
                utils.storage.saveSettings(settings);
            }
            
            return { success: true };
        } catch (error) {
            console.error('계정 업데이트 오류:', error);
            return { 
                success: false, 
                message: error.message || '계정 업데이트 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 계정 삭제
    async deleteAccount() {
        try {
            // 사용자 ID 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // 트랜잭션 처리를 위해 순차적으로 삭제
            
            // 1. 사용자의 작품 삭제
            const { error: artworkError } = await supabase
                .from('artworks')
                .delete()
                .eq('creator_id', userId);
            
            if (artworkError) throw artworkError;
            
            // 2. 사용자의 즐겨찾기 삭제
            const { error: favoriteError } = await supabase
                .from('favorites')
                .delete()
                .eq('user_id', userId);
            
            if (favoriteError) throw favoriteError;
            
            // 3. 사용자 삭제
            const { error: userError } = await supabase
                .from('users')
                .delete()
                .eq('id', userId);
            
            if (userError) throw userError;
            
            // 세션 종료
            await this.logout();
            
            // 로컬 데이터 정리 (설정, 즐겨찾기 등 유지)
            localStorage.removeItem(CONFIG.STORAGE_KEYS.USERNAME);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.USER_ID);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_TOKEN);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.AUTH_EXPIRY);
            localStorage.removeItem(CONFIG.STORAGE_KEYS.FAVORITES);
            
            return { success: true };
        } catch (error) {
            console.error('계정 삭제 오류:', error);
            return { 
                success: false, 
                message: error.message || '계정 삭제 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 즐겨찾기 불러오기
    async loadFavorites() {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                appState.favorites = [];
                return [];
            }
            
            // Supabase에서 즐겨찾기 조회
            const { data, error } = await supabase
                .from('favorites')
                .select('artwork_id')
                .eq('user_id', userId);
            
            if (error) throw error;
            
            // 작품 ID 배열로 변환
            const favorites = data ? data.map(fav => fav.artwork_id) : [];
            
            // 상태 업데이트
            appState.favorites = favorites;
            
            // 로컬 스토리지 업데이트 (캐시)
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(favorites));
            
            return favorites;
        } catch (error) {
            console.error('즐겨찾기 로드 오류:', error);
            
            // 로컬 스토리지에서 가져오기 시도
            try {
                const localFavorites = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.FAVORITES) || '[]');
                appState.favorites = localFavorites;
                return localFavorites;
            } catch (e) {
                appState.favorites = [];
                return [];
            }
        }
    },
    
    // 즐겨찾기 추가
    async addFavorite(artworkId) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return Promise.reject(new Error('로그인이 필요합니다'));
            }
            
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // 이미 즐겨찾기에 있는지 확인
            if (appState.favorites.includes(artworkId)) {
                return Promise.resolve(appState.favorites);
            }
            
            // 작품 존재 여부 확인
            const { data: artwork, error: artworkError } = await supabase
                .from('artworks')
                .select('id')
                .eq('id', artworkId)
                .maybeSingle();
            
            if (artworkError) throw artworkError;
            
            if (!artwork) {
                return Promise.reject(new Error('존재하지 않는 작품입니다'));
            }
            
            // 중복 확인
            const { data: existingFavorite, error: existingError } = await supabase
                .from('favorites')
                .select('id')
                .eq('user_id', userId)
                .eq('artwork_id', artworkId)
                .maybeSingle();
            
            if (existingError) throw existingError;
            
            if (existingFavorite) {
                // 이미 즐겨찾기에 있음 - 상태 업데이트만
                if (!appState.favorites.includes(artworkId)) {
                    appState.favorites.push(artworkId);
                    localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
                }
                return Promise.resolve(appState.favorites);
            }
            
            // Supabase에 즐겨찾기 추가
            const { error } = await supabase
                .from('favorites')
                .insert([{
                    user_id: userId,
                    artwork_id: artworkId,
                    created_at: new Date().toISOString()
                }]);
            
            if (error) throw error;
            
            // 상태 업데이트
            appState.favorites.push(artworkId);
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
            
            return Promise.resolve(appState.favorites);
        } catch (error) {
            console.error('즐겨찾기 추가 오류:', error);
            return Promise.reject(error);
        }
    },
    
    // 즐겨찾기 제거
    async removeFavorite(artworkId) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return Promise.reject(new Error('로그인이 필요합니다'));
            }
            
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // 즐겨찾기에 없으면 무시
            if (!appState.favorites.includes(artworkId)) {
                return Promise.resolve(appState.favorites);
            }
            
            // Supabase에서 즐겨찾기 제거
            const { error } = await supabase
                .from('favorites')
                .delete()
                .eq('user_id', userId)
                .eq('artwork_id', artworkId);
            
            if (error) throw error;
            
            // 상태 업데이트
            appState.favorites = appState.favorites.filter(id => id !== artworkId);
            localStorage.setItem(CONFIG.STORAGE_KEYS.FAVORITES, JSON.stringify(appState.favorites));
            
            return Promise.resolve(appState.favorites);
        } catch (error) {
            console.error('즐겨찾기 제거 오류:', error);
            return Promise.reject(error);
        }
    },
    
    // CAPTCHA 검증 (서버 측에서 처리해야 하지만, 현재는 클라이언트에서 간단히 검증)
    verifyCaptcha(captchaResponse) {
        return !!captchaResponse; // 실제로는 서버 API를 통해 검증해야 함
    },
    
    // 작품 온라인 공유
    async shareArtwork(artworkData, captchaResponse) {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId || !this.isAuthenticated()) {
                return { success: false, message: '로그인이 필요합니다' };
            }
            
            // CAPTCHA 검증
            if (!this.verifyCaptcha(captchaResponse)) {
                return { success: false, message: '보안 인증을 완료해주세요' };
            }
            
            // 현재 작품 수 확인
            const count = await this.getUserArtworksCount();
            if (count >= CONFIG.MAX_ARTWORK_PER_USER) {
                return { success: false, message: `최대 ${CONFIG.MAX_ARTWORK_PER_USER}개까지 작품을 공유할 수 있습니다. 기존 작품을 삭제하고 시도해주세요.` };
            }
            
            // 입력 데이터 검증
            if (!artworkData.title) {
                return { success: false, message: '작품 제목이 필요합니다' };
            }
            
            if (!artworkData.data || !artworkData.data.board) {
                return { success: false, message: '작품 데이터가 유효하지 않습니다' };
            }
            
            // XSS 방지
            const sanitizedTitle = utils.sanitizeText(artworkData.title, 100);
            const sanitizedDesc = utils.sanitizeText(artworkData.description || '', 500);
            
            // 태그 정제
            const sanitizedTags = artworkData.tags 
                ? artworkData.tags.map(tag => utils.sanitizeText(tag, 30)).filter(tag => tag.length > 0)
                : [];
            
            // 작품 데이터 준비
            const artwork = {
                title: sanitizedTitle,
                description: sanitizedDesc,
                tags: sanitizedTags,
                data: artworkData.data,
                creator: this.getUsername(),
                creator_id: userId,
                created_at: new Date().toISOString(),
                views: 0
            };
            
            // Supabase에 작품 저장
            const { data, error } = await supabase
                .from('artworks')
                .insert([artwork])
                .select();
            
            if (error) throw error;
            
            if (data && data.length > 0) {
                return { success: true, artworkId: data[0].id };
            } else {
                return { success: false, message: '작품 저장에 실패했습니다' };
            }
        } catch (error) {
            console.error('작품 공유 오류:', error);
            return { 
                success: false, 
                message: error.message || '작품 저장 중 오류가 발생했습니다' 
            };
        }
    },
    
    // 단일 작품 가져오기
    async getArtwork(artworkId) {
        try {
            // 캐시에서 작품 확인
            if (appState.artworkCache[artworkId]) {
                // 캐시된 작품 반환
                return appState.artworkCache[artworkId];
            }
            
            // Supabase에서 작품 조회
            const { data, error } = await supabase
                .from('artworks')
                .select('*')
                .eq('id', artworkId)
                .single();
            
            if (error) throw error;
            
            if (data) {
                // 캐시에 저장
                appState.artworkCache[artworkId] = data;
                return data;
            }
            
            return null;
        } catch (error) {
            console.error('작품 가져오기 오류:', error);
            throw error;
        }
    },
    
    // 사용자 작품 가져오기
    async getUserArtworks(page = 1, pageSize = 12, sort = 'latest') {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return { data: [], count: 0 };
            }
            
            // 정렬 방식 설정
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' })
                .eq('creator_id', userId);
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            return { data: data || [], count: count || 0 };
        } catch (error) {
            console.error('사용자 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 사용자 작품 수 가져오기
    async getUserArtworksCount() {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return 0;
            }
            
            // Supabase에서 사용자 작품 수 조회
            const { count, error } = await supabase
                .from('artworks')
                .select('*', { count: 'exact', head: true })
                .eq('creator_id', userId);
            
            if (error) throw error;
            
            return count || 0;
        } catch (error) {
            console.error('사용자 작품 수 가져오기 오류:', error);
            return 0;
        }
    },
    
    // 공용 갤러리 작품 가져오기
    async getPublicArtworks(page = 1, pageSize = 12, sort = 'latest') {
        try {
            // 정렬 방식 설정
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' });
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            return { data: data || [], count: count || 0 };
        } catch (error) {
            console.error('공용 갤러리 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 즐겨찾기 작품 가져오기
    async getFavoriteArtworks(page = 1, pageSize = 12, sort = 'latest') {
        try {
            // 사용자 인증 확인
            const userId = this.getUserId();
            if (!userId) {
                return { data: [], count: 0 };
            }
            
            // 즐겨찾기 작품 ID 목록 가져오기
            await this.loadFavorites();
            
            // 즐겨찾기가 없으면 빈 배열 반환
            if (!appState.favorites || appState.favorites.length === 0) {
                return { data: [], count: 0 };
            }
            
            // Supabase에서 즐겨찾기 작품 조회
            let query = supabase
                .from('artworks')
                .select('*', { count: 'exact' })
                .in('id', appState.favorites);
            
            // 정렬 적용
            if (sort === 'oldest') {
                query = query.order('created_at', { ascending: true });
            } else if (sort === 'popular') {
                query = query.order('views', { ascending: false });
            } else {
                // 기본: 최신순
                query = query.order('created_at', { ascending: false });
            }
            
            // 페이지네이션 적용
            const from = (page - 1) * pageSize;
            const to = from + pageSize - 1;
            query = query.range(from, to);
            
            // 쿼리 실행
            const { data, error, count } = await query;
            
            if (error) throw error;
            
            return { data: data || [], count: count || 0 };
        } catch (error) {
            console.error('즐겨찾기 작품 가져오기 오류:', error);
            return { data: [], count: 0 };
        }
    },
    
    // 조회수 증가
    async incrementViews(artworkId) {
        try {
            // 유효성 검사
            if (!artworkId) {
                return Promise.reject(new Error('작품 ID가 필요합니다'));
            }
            
            // 캐시된 작품 가져오기
            const artwork = appState.artworkCache[artworkId];
            
            if (!artwork) {
                // 작품 정보 조회
                const { data, error } = await supabase
                    .from('artworks')
                    .select('*')
                    .eq('id', artworkId)
                    .single();
                
                if (error) throw error;
                if (!data) throw new Error('작품을 찾을 수 없습니다');
                
                // 조회수 증가
                const { error: updateError } = await supabase
                    .from('artworks')
                    .update({ views: (data.views || 0) + 1 })
                    .eq('id', artworkId);
                
                if (updateError) throw updateError;
                
                // 캐시 업데이트
                data.views = (data.views || 0) + 1;
                appState.artworkCache[artworkId] = data;
            } else {
                // 캐시된 작품 정보가 있으면 바로 업데이트
                const { error } = await supabase
                    .from('artworks')
                    .update({ views: (artwork.views || 0) + 1 })
                    .eq('id', artworkId);
                
                if (error) throw error;
                
                // 캐시된 작품 조회수 증가
                artwork.views = (artwork.views || 0) + 1;
            }
            
            return Promise.resolve();
        } catch (error) {
            console.error('조회수 증가 오류:', error);
            return Promise.reject(error);
        }
    }
};

// 온라인 공유 모달
function openShareModal() {
    if (!utils.validateElement(elements.shareModal, 'shareModal')) {
        utils.showToast('공유 모달을 열 수 없습니다', 'error');
        return;
    }
    
    // 비회원 모드 확인
    if (appState.isGuestMode) {
        utils.showToast('온라인 공유는 로그인 후 이용 가능합니다', 'error');
        return;
    }
    
    // 사용자 인증 확인
    if (!api.isAuthenticated()) {
        utils.showToast('온라인 공유를 위해 로그인이 필요합니다', 'error');
        showAuthModal();
        return;
    }
    
    // 현재 작품 수 확인
    api.getUserArtworksCount()
        .then(count => {
            if (count >= CONFIG.MAX_ARTWORK_PER_USER) {
                utils.showToast(`최대 ${CONFIG.MAX_ARTWORK_PER_USER}개까지 작품을 공유할 수 있습니다. 기존 작품을 삭제하고 시도해주세요.`, 'error');
                return;
            }
            
            // 현재 캔버스 데이터 가져오기
            const canvasData = canvasRenderer.exportCanvasData();
            if (!canvasData) {
                utils.showToast('캔버스 데이터를 가져올 수 없습니다', 'error');
                return;
            }
            
            // 필드 초기화
            if (utils.validateElement(elements.shareTitleInput, 'shareTitleInput') &&
                utils.validateElement(elements.shareTagsInput, 'shareTagsInput') &&
                utils.validateElement(elements.shareDescInput, 'shareDescInput') &&
                utils.validateElement(elements.sharePreview, 'sharePreview')) {
                
                elements.shareTitleInput.value = '';
                elements.shareTagsInput.value = '';
                elements.shareDescInput.value = '';
                
                // 미리보기 생성 - 여기서 안전하게 처리
                try {
                    elements.sharePreview.innerHTML = '';
                    
                    const previewContainer = document.createElement('div');
                    previewContainer.style.fontFamily = 'monospace';
                    previewContainer.style.lineHeight = '1';
                    previewContainer.style.fontSize = '10px';
                    previewContainer.style.whiteSpace = 'pre';
                    
                    const board = canvasData.board;
                    if (!board || !Array.isArray(board)) {
                        throw new Error('유효하지 않은 캔버스 데이터');
                    }
                    
                    // 미리보기 제한
                    const maxRows = Math.min(board.length, 15);
                    const maxCols = Math.min(board[0]?.length || 0, 30);
                    
                    let content = '';
                    for (let r = 0; r < maxRows; r++) {
                        let rowText = '';
                        
                        for (let c = 0; c < maxCols; c++) {
                            if (board[r][c] === '■') {
                                rowText += '■';
                            } else {
                                rowText += '□';
                            }
                        }
                        content += rowText + '\n';
                    }
                    
                    previewContainer.textContent = content;
                    elements.sharePreview.appendChild(previewContainer);
                } catch (error) {
                    console.error('미리보기 생성 오류:', error);
                    elements.sharePreview.textContent = '미리보기를 표시할 수 없습니다';
                }
            }
            
            // reCAPTCHA 초기화
            if (window.grecaptcha) {
                try {
                    window.grecaptcha.reset();
                } catch (e) {
                    console.warn('reCAPTCHA 초기화 오류:', e);
                }
            }
            
            utils.showModal(elements.shareModal);
        })
        .catch(error => {
            console.error('작품 수 확인 오류:', error);
            utils.showToast('작품 수 확인 중 오류가 발생했습니다', 'error');
        });
}

// 작품 공유 실행
async function shareArtwork(event) {
    if (event) event.preventDefault();
    
    // 필드 유효성 검사
    if (!utils.validateElement(elements.shareTitleInput, 'shareTitleInput') ||
        !utils.validateElement(elements.shareTagsInput, 'shareTagsInput') ||
        !utils.validateElement(elements.shareDescInput, 'shareDescInput') ||
        !utils.validateElement(elements.shareActionBtn, 'shareActionBtn') ||
        !utils.validateElement(elements.shareModal, 'shareModal')) {
        utils.showToast('공유 양식을 찾을 수 없습니다', 'error');
        return;
    }
    
    // 비회원 모드 확인
    if (appState.isGuestMode) {
        utils.showToast('온라인 공유는 로그인 후 이용 가능합니다', 'error');
        utils.hideModal(elements.shareModal);
        return;
    }
    
    // 필수 항목 체크
    const title = elements.shareTitleInput.value.trim();
    const tags = elements.shareTagsInput.value.trim();
    
    if (!title) {
        utils.showToast('작품 제목을 입력해주세요', 'error');
        return;
    }
    
    // 제목 길이 제한
    if (title.length > 100) {
        utils.showToast('제목은 100자를 초과할 수 없습니다', 'error');
        return;
    }
    
    // CAPTCHA 확인
    let captchaResponse = '';
    if (window.grecaptcha) {
        captchaResponse = window.grecaptcha.getResponse();
        if (!captchaResponse) {
            utils.showToast('보안 인증을 완료해주세요', 'error');
            return;
        }
    } else {
        utils.showToast('CAPTCHA 로딩에 실패했습니다. 페이지를 새로고침 후 다시 시도해주세요', 'error');
        return;
    }
    
    // 로딩 상태 표시
    elements.shareActionBtn.disabled = true;
    elements.shareActionBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px; margin-right: 8px;"></div> 공유 중...';
    
    try {
        // 캔버스 데이터 가져오기
        const canvasData = canvasRenderer.exportCanvasData();
        if (!canvasData) {
            throw new Error('캔버스 데이터를 가져올 수 없습니다');
        }
        
        // 태그 처리
        const tagList = tags 
            ? tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0)
            : [];
        
        // 유효한 태그 개수 제한
        const validTags = tagList.slice(0, 10);
        if (tagList.length > 10) {
            utils.showToast('태그는 최대 10개까지만 사용할 수 있습니다. 초과된 태그는 무시됩니다.', 'warning');
        }
        
        // 작품 데이터 준비
        const artworkData = {
            title: title,
            tags: validTags,
            description: elements.shareDescInput.value.trim(),
            creator: api.getUsername(),
            timestamp: new Date().toISOString(),
            data: canvasData,
            views: 0
        };
        
        // Supabase를 통해 작품 저장
        const result = await api.shareArtwork(artworkData, captchaResponse);
        
        if (result.success) {
            utils.showToast('작품이 성공적으로 공유되었습니다', 'success');
            utils.hideModal(elements.shareModal);
            
            // 갤러리 페이지에 있으면 새로고침
            if (appState.currentPage === 'gallery') {
                loadGalleryItems(appState.currentTab);
            }
        } else {
            throw new Error(result.message || '작품 공유에 실패했습니다');
        }
    } catch (error) {
        console.error('작품 공유 오류:', error);
        utils.showToast(error.message || '작품 공유 중 오류가 발생했습니다', 'error');
    } finally {
        // 버튼 상태 복원
        elements.shareActionBtn.disabled = false;
        elements.shareActionBtn.innerHTML = '공유하기';
        
        // CAPTCHA 리셋
        if (window.grecaptcha) {
            try {
                window.grecaptcha.reset();
            } catch (e) {
                console.warn('reCAPTCHA 초기화 오류:', e);
            }
        }
    }
}

// 갤러리 페이지 열기
function openGalleryPage() {
    // 비회원 모드 확인
    if (appState.isGuestMode) {
        utils.showToast('갤러리는 로그인 후 이용 가능합니다', 'error');
        return;
    }
    
    // 사용자 인증 확인
    if (!api.isAuthenticated()) {
        utils.showToast('갤러리를 이용하려면 로그인이 필요합니다', 'error');
        showAuthModal();
        return;
    }
    
    if (!utils.validateElement(elements.galleryPage, 'galleryPage') ||
        !utils.validateElement(elements.galleryContent, 'galleryContent')) {
        utils.showToast('갤러리 페이지를 열 수 없습니다', 'error');
        return;
    }
    
    // 갤러리 컨텐츠 초기화
    elements.galleryContent.innerHTML = `
        <div class="text-center" style="grid-column: 1 / -1;">
            <div class="spinner"></div>
            <p>작품을 불러오는 중...</p>
        </div>
    `;
    
    // 페이지 상태 업데이트
    appState.currentPage = 'gallery';
    
    // 페이지 표시
    showPage(elements.galleryPage);
    
    // 즐겨찾기 목록 새로고침
    api.loadFavorites()
        .then(() => {
            // 작품 불러오기
            loadGalleryItems(appState.currentTab);
        })
        .catch(error => {
            console.error('즐겨찾기 로드 오류:', error);
            // 오류가 발생해도 갤러리는 로드
            loadGalleryItems(appState.currentTab);
        });
}

// 페이지 표시
function showPage(pageElement) {
    if (!pageElement) {
        console.error('표시할 페이지 요소가 없습니다');
        return;
    }
    
    // 모든 페이지 숨기기
    document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
    });
    
    // 요청한 페이지 표시
    pageElement.classList.add('active');
    
    // 페이지 상단으로 스크롤
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// 갤러리 작품 불러오기
function loadGalleryItems(tab) {
    if (!utils.validateElement(elements.galleryContent, 'galleryContent')) {
        utils.showToast('갤러리 컨텐츠 요소를 찾을 수 없습니다', 'error');
        return;
    }
    
    // 탭 스타일 업데이트
    if (utils.validateElement(elements.galleryTabs, 'galleryTabs')) {
        elements.galleryTabs.forEach(tabEl => {
            if (tabEl.dataset.tab === tab) {
                tabEl.classList.add('active');
            } else {
                tabEl.classList.remove('active');
            }
        });
    }
    
    // 현재 탭 저장
    appState.currentTab = tab;
    
    // 스피너 표시
    elements.galleryContent.innerHTML = `
        <div class="text-center" style="grid-column: 1 / -1;">
            <div class="spinner"></div>
            <p>작품을 불러오는 중...</p>
        </div>
    `;
    
    // 검색어 가져오기
    const searchQuery = utils.validateElement(elements.searchInput, 'searchInput') 
        ? elements.searchInput.value.trim().toLowerCase() 
        : '';
    
    // 페이지 정보
    const { page, pageSize } = appState.pageParams;
    
    // API 호출
    let apiPromise;
    
    switch (tab) {
        case 'favorites':
            apiPromise = api.getFavoriteArtworks(page, pageSize, appState.currentFilter);
            break;
        case 'public':
            apiPromise = api.getPublicArtworks(page, pageSize, appState.currentFilter);
            break;
        case 'my':
        default:
            apiPromise = api.getUserArtworks(page, pageSize, appState.currentFilter);
            break;
    }
    
    apiPromise.then(result => {
        // 전체 페이지 수 업데이트
        appState.pageParams.totalPages = Math.ceil(result.count / pageSize) || 1;
        
        // 작품 목록
        let artworks = result.data || [];
        
        // 검색어가 있으면 클라이언트 측에서 필터링
        if (searchQuery) {
            artworks = artworks.filter(artwork => 
                (artwork.title && artwork.title.toLowerCase().includes(searchQuery)) || 
                (artwork.creator && artwork.creator.toLowerCase().includes(searchQuery)) ||
                (artwork.tags && artwork.tags.some(tag => tag.toLowerCase().includes(searchQuery))) ||
                (artwork.description && artwork.description.toLowerCase().includes(searchQuery))
            );
        }
        
        renderGalleryItems(artworks, tab);
        renderPagination();
    }).catch(error => {
        console.error('갤러리 불러오기 오류:', error);
        
        if (utils.validateElement(elements.galleryContent, 'galleryContent')) {
            elements.galleryContent.innerHTML = `
                <div class="empty-state" style="grid-column: 1 / -1;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <h3 class="empty-state-title valorant-text">오류가 발생했습니다</h3>
                    <p class="empty-state-text">작품을 불러오는 중 문제가 발생했습니다. 다시 시도해주세요.</p>
                </div>
            `;
        }
    });
}

// 페이지네이션 렌더링
function renderPagination() {
    if (!utils.validateElement(elements.galleryPagination, 'galleryPagination')) {
        return;
    }
    
    const { page, totalPages } = appState.pageParams;
    const pagination = elements.galleryPagination;
    
    pagination.innerHTML = '';
    
    // 페이지 수가 1이면 페이지네이션 표시 안함
    if (totalPages <= 1) return;
    
    // 이전 페이지 버튼
    if (page > 1) {
        const prevButton = document.createElement('div');
        prevButton.className = 'pagination-item';
        prevButton.setAttribute('aria-label', '이전 페이지');
        prevButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
        prevButton.addEventListener('click', () => changePage(page - 1));
        pagination.appendChild(prevButton);
    }
    
    // 페이지 버튼 생성
    const maxVisible = 5;
    let startPage = Math.max(1, page - Math.floor(maxVisible / 2));
    let endPage = Math.min(totalPages, startPage + maxVisible - 1);
    
    if (endPage - startPage + 1 < maxVisible) {
        startPage = Math.max(1, endPage - maxVisible + 1);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageButton = document.createElement('div');
        pageButton.className = `pagination-item${i === page ? ' active' : ''}`;
        pageButton.textContent = i;
        pageButton.setAttribute('aria-label', `페이지 ${i}`);
        
        if (i === page) {
            pageButton.setAttribute('aria-current', 'page');
        }
        
        pageButton.addEventListener('click', () => changePage(i));
        pagination.appendChild(pageButton);
    }
    
    // 다음 페이지 버튼
    if (page < totalPages) {
        const nextButton = document.createElement('div');
        nextButton.className = 'pagination-item';
        nextButton.setAttribute('aria-label', '다음 페이지');
        nextButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
        nextButton.addEventListener('click', () => changePage(page + 1));
        pagination.appendChild(nextButton);
    }
}

// 페이지 변경
function changePage(newPage) {
    appState.pageParams.page = newPage;
    loadGalleryItems(appState.currentTab);
    
    // 페이지 상단으로 스크롤
    if (utils.validateElement(elements.galleryPage, 'galleryPage')) {
        elements.galleryPage.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

// 갤러리 작품 렌더링
function renderGalleryItems(artworks, tab) {
    if (!utils.validateElement(elements.galleryContent, 'galleryContent')) {
        return;
    }
    
    if (!artworks || artworks.length === 0) {
        let message = '';
        if (tab === 'my') {
            message = '아직 공유한 작품이 없습니다. "온라인 공유" 버튼을 눌러 작품을 공유해보세요!';
        } else if (tab === 'favorites') {
            message = '즐겨찾기한 작품이 없습니다. 작품을 보고 즐겨찾기 해보세요!';
        } else {
            message = '공개된 작품이 없습니다. 첫 번째로 작품을 공유해보세요!';
        }
        
        elements.galleryContent.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                </svg>
                <h3 class="empty-state-title valorant-text">작품이 없습니다</h3>
                <p class="empty-state-text">${message}</p>
            </div>
        `;
        return;
    }
    
    elements.galleryContent.innerHTML = '';
    
    try {
        artworks.forEach(artwork => {
            // XSS 방지
            const safeTitle = utils.escapeHtml(artwork.title || '제목 없음');
            const safeCreator = utils.escapeHtml(artwork.creator || '작가 미상');
            
            const galleryItem = document.createElement('div');
            galleryItem.className = 'gallery-item';
            galleryItem.dataset.id = artwork.id;
            
            // 미리보기 생성
            const preview = document.createElement('div');
            preview.className = 'gallery-preview';
            
            // 이모지 미리보기
            const previewContent = document.createElement('div');
            previewContent.style.fontFamily = 'monospace';
            previewContent.style.lineHeight = '1';
            previewContent.style.fontSize = '10px';
            previewContent.style.whiteSpace = 'pre';
            
            let content = '';
            try {
                if (artwork.data && artwork.data.board) {
                    const board = artwork.data.board;
                    const maxRows = Math.min(board.length, 15); // 미리보기 제한
                    
                    for (let r = 0; r < maxRows; r++) {
                        let rowText = '';
                        const maxCols = Math.min(board[r].length, 30); // 미리보기 제한
                        
                        for (let c = 0; c < maxCols; c++) {
                            if (board[r][c] === '■') {
                                rowText += '■';
                            } else {
                                rowText += '□';
                            }
                        }
                        content += rowText + '\n';
                    }
                } else {
                    content = '미리보기를 표시할 수 없습니다';
                }
            } catch (error) {
                console.error('미리보기 생성 오류:', error);
                content = '미리보기 생성 중 오류가 발생했습니다';
            }
            
            previewContent.textContent = content;
            preview.appendChild(previewContent);
            
            // 정보 섹션 생성
            const info = document.createElement('div');
            info.className = 'gallery-info';
            
            const title = document.createElement('div');
            title.className = 'gallery-title';
            title.textContent = safeTitle;
            
            const creator = document.createElement('div');
            creator.className = 'gallery-creator';
            creator.textContent = `by ${safeCreator}`;
            
            // 태그 생성
            const tags = document.createElement('div');
            tags.className = 'gallery-tags';
            
            if (artwork.tags && artwork.tags.length > 0) {
                const maxTags = 3;
                artwork.tags.slice(0, maxTags).forEach(tag => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'gallery-tag';
                    tagEl.textContent = utils.escapeHtml(tag);
                    tags.appendChild(tagEl);
                });
                
                if (artwork.tags.length > maxTags) {
                    const moreTagsEl = document.createElement('span');
                    moreTagsEl.className = 'gallery-tag';
                    moreTagsEl.textContent = `+${artwork.tags.length - maxTags}`;
                    tags.appendChild(moreTagsEl);
                }
            }
            
            const stats = document.createElement('div');
            stats.className = 'gallery-stats';
            
            const views = document.createElement('span');
            views.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> ${artwork.views || 0}`;
            
            const favorite = document.createElement('span');
            const isFavorited = appState.favorites.includes(artwork.id);
            favorite.className = 'gallery-favorite' + (isFavorited ? ' active' : '');
            favorite.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="${isFavorited ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
            
            // 즐겨찾기 토글 이벤트
            favorite.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFavorite(artwork.id, favorite);
            });
            
            stats.appendChild(views);
            stats.appendChild(favorite);
            
            info.appendChild(title);
            info.appendChild(creator);
            info.appendChild(tags);
            info.appendChild(stats);
            
            galleryItem.appendChild(preview);
            galleryItem.appendChild(info);
            
            // 클릭 이벤트
            galleryItem.addEventListener('click', () => {
                openArtworkPage(artwork.id);
            });
            
            elements.galleryContent.appendChild(galleryItem);
        });
    } catch (error) {
        console.error('갤러리 아이템 렌더링 오류:', error);
        elements.galleryContent.innerHTML = `
            <div class="empty-state" style="grid-column: 1 / -1;">
                <h3 class="empty-state-title valorant-text">렌더링 오류</h3>
                <p class="empty-state-text">작품을 표시하는 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.</p>
            </div>
        `;
    }
}

// 즐겨찾기 토글
function toggleFavorite(artworkId, element) {
    if (!artworkId || !element) {
        utils.showToast('작품 정보를 찾을 수 없습니다', 'error');
        return;
    }
    
    const isFavorite = appState.favorites.includes(artworkId);
    
    if (isFavorite) {
        // 즐겨찾기 해제
        api.removeFavorite(artworkId).then(() => {
            // 상태 업데이트
            appState.favorites = appState.favorites.filter(id => id !== artworkId);
            
            // UI 업데이트
            element.classList.remove('active');
            element.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
            
            utils.showToast('즐겨찾기에서 제거되었습니다', 'info');
            
            // 즐겨찾기 탭에서 항목 제거
            if (appState.currentTab === 'favorites') {
                const galleryItem = document.querySelector(`.gallery-item[data-id="${artworkId}"]`);
                if (galleryItem && utils.validateElement(elements.galleryContent, 'galleryContent')) {
                    galleryItem.remove();
                    
                    // 즐겨찾기가 모두 제거되었으면 빈 상태 표시
                    if (!elements.galleryContent.querySelector('.gallery-item')) {
                        renderGalleryItems([], 'favorites');
                    }
                }
            }
            
            // 작품 상세 페이지에서도 업데이트
            if (appState.currentPage === 'artwork' && appState.currentArtwork && appState.currentArtwork.id === artworkId) {
                updateFavoriteButton(false);
            }
        }).catch(error => {
            console.error('즐겨찾기 해제 오류:', error);
            utils.showToast('즐겨찾기 해제 중 오류가 발생했습니다', 'error');
        });
    } else {
        // 즐겨찾기 추가
        api.addFavorite(artworkId).then(() => {
            // 상태 업데이트
            if (!appState.favorites.includes(artworkId)) {
                appState.favorites.push(artworkId);
            }
            
            // UI 업데이트
            element.classList.add('active');
            element.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
            
            utils.showToast('즐겨찾기에 추가되었습니다', 'success');
            
            // 작품 상세 페이지에서도 업데이트
            if (appState.currentPage === 'artwork' && appState.currentArtwork && appState.currentArtwork.id === artworkId) {
                updateFavoriteButton(true);
            }
        }).catch(error => {
            console.error('즐겨찾기 추가 오류:', error);
            utils.showToast('즐겨찾기 추가 중 오류가 발생했습니다', 'error');
        });
    }
}

// 작품 상세 페이지 열기
async function openArtworkPage(artworkId) {
    if (!artworkId || 
        !utils.validateElement(elements.artworkPage, 'artworkPage') || 
        !utils.validateElement(elements.artworkPreview, 'artworkPreview')) {
        utils.showToast('작품 상세 페이지를 열 수 없습니다', 'error');
        return;
    }
    
    try {
        // 로딩 표시
        elements.artworkPreview.innerHTML = `
            <div class="spinner" style="width: 40px; height: 40px;"></div>
            <p>작품을 불러오는 중...</p>
        `;
        
        // 페이지 표시
        appState.currentPage = 'artwork';
        showPage(elements.artworkPage);
        
        // 작품 정보 가져오기
        const artwork = await api.getArtwork(artworkId);
        
        if (!artwork) {
            throw new Error('작품을 찾을 수 없습니다');
        }
        
        // 상태 저장
        appState.currentArtwork = artwork;
        
        // URL 업데이트
        updateURLWithArtworkId(artworkId);
        
        // 조회수 증가
        api.incrementViews(artworkId).catch(error => {
            console.error('조회수 증가 오류:', error);
        });
        
        // 작품 정보 표시
        renderArtworkDetails(artwork);
        
    } catch (error) {
        console.error('작품 상세 페이지 오류:', error);
        utils.showToast('작품을 불러오는 중 오류가 발생했습니다', 'error');
        
        // 갤러리로 되돌아가기
        goBackToGallery();
    }
}

// URL에 작품 ID 추가
function updateURLWithArtworkId(artworkId) {
    if (!artworkId) return;
    
    if (history.pushState) {
        const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}#${artworkId}`;
        window.history.pushState({ artworkId }, '', newUrl);
    }
}

// URL에서 작품 ID 제거
function removeArtworkIdFromURL() {
    if (history.pushState) {
        const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
        window.history.pushState({}, '', newUrl);
    }
}

// 작품 상세 정보 렌더링
function renderArtworkDetails(artwork) {
    if (!artwork || 
        !utils.validateElement(elements.artworkPageTitle, 'artworkPageTitle') ||
        !utils.validateElement(elements.artworkTitle, 'artworkTitle') ||
        !utils.validateElement(elements.artworkCreator, 'artworkCreator') ||
        !utils.validateElement(elements.artworkTags, 'artworkTags') ||
        !utils.validateElement(elements.artworkDate, 'artworkDate') ||
        !utils.validateElement(elements.artworkViews, 'artworkViews') ||
        !utils.validateElement(elements.artworkDesc, 'artworkDesc')) {
        utils.showToast('작품 상세 정보를 표시할 수 없습니다', 'error');
        return;
    }
    
    // XSS 방지
    const safeTitle = utils.escapeHtml(artwork.title || '제목 없음');
    const safeCreator = utils.escapeHtml(artwork.creator || '작가 미상');
    const safeDesc = utils.escapeHtml(artwork.description || '작품 설명이 없습니다.');
    
    // 제목 설정
    elements.artworkPageTitle.textContent = safeTitle;
    elements.artworkTitle.textContent = safeTitle;
    
    // 작가 정보
    elements.artworkCreator.textContent = `작가: ${safeCreator}`;
    
    // 태그 표시
    const tagsContainer = elements.artworkTags;
    tagsContainer.innerHTML = '';
    
    if (artwork.tags && artwork.tags.length > 0) {
        artwork.tags.forEach(tag => {
            const tagEl = document.createElement('span');
            tagEl.className = 'gallery-tag';
            tagEl.textContent = utils.escapeHtml(tag);
            tagsContainer.appendChild(tagEl);
        });
    } else {
        const noTagsEl = document.createElement('span');
        noTagsEl.className = 'gallery-tag';
        noTagsEl.textContent = '태그 없음';
        tagsContainer.appendChild(noTagsEl);
    }
    
    // 날짜 형식화
    const timestamp = artwork.timestamp ? new Date(artwork.timestamp) : new Date();
    elements.artworkDate.textContent = utils.formatDate(timestamp);
    
    // 조회수
    elements.artworkViews.textContent = artwork.views || 0;
    
    // 설명
    elements.artworkDesc.textContent = safeDesc;
    
    // 미리보기 생성
    generateArtworkPreview(artwork);
    
    // 즐겨찾기 버튼 상태 설정
    const isFavorite = appState.favorites.includes(artwork.id);
    updateFavoriteButton(isFavorite);
    
    // 버튼 이벤트 설정
    if (utils.validateElement(elements.downloadArtworkBtn, 'downloadArtworkBtn') &&
        utils.validateElement(elements.loadArtworkBtn, 'loadArtworkBtn')) {
        
        // 다운로드 버튼 클릭 이벤트
        elements.downloadArtworkBtn.onclick = () => downloadArtwork(artwork);
        
        // 불러오기 버튼 클릭 이벤트
        elements.loadArtworkBtn.onclick = () => loadArtworkToCanvas(artwork);
    }
}

// 즐겨찾기 버튼 업데이트
function updateFavoriteButton(isFavorite) {
    if (!utils.validateElement(elements.favoriteArtworkBtn, 'favoriteArtworkBtn') || 
        !appState.currentArtwork) {
        return;
    }
    
    elements.favoriteArtworkBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="${isFavorite ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
        </svg>
        ${isFavorite ? '즐겨찾기 해제' : '즐겨찾기'}
    `;
    
    elements.favoriteArtworkBtn.onclick = () => {
        const artworkId = appState.currentArtwork.id;
        toggleFavorite(artworkId, document.querySelector(`.gallery-item[data-id="${artworkId}"] .gallery-favorite`));
    };
}

// 작품 미리보기 생성
function generateArtworkPreview(artwork) {
    if (!artwork || !utils.validateElement(elements.artworkPreview, 'artworkPreview')) {
        return;
    }
    
    const preview = elements.artworkPreview;
    preview.innerHTML = '';
    
    try {
        // 이모지 미리보기
        const previewContent = document.createElement('div');
        previewContent.style.fontFamily = 'monospace';
        previewContent.style.lineHeight = '1';
        previewContent.style.fontSize = '14px';
        previewContent.style.whiteSpace = 'pre';
        
        if (artwork.data && artwork.data.board) {
            let content = '';
            const board = artwork.data.board;
            
            for (let r = 0; r < board.length; r++) {
                let rowText = '';
                for (let c = 0; c < board[r].length; c++) {
                    if (board[r][c] === '■') {
                        rowText += '■';
                    } else {
                        rowText += '□';
                    }
                }
                content += rowText + '\n';
            }
            
            previewContent.textContent = content;
            preview.appendChild(previewContent);
        } else {
            throw new Error('유효하지 않은 작품 데이터');
        }
    } catch (error) {
        console.error('미리보기 생성 오류:', error);
        preview.innerHTML = '<p>미리보기를 표시할 수 없습니다</p>';
    }
}

// 갤러리로 돌아가기
function goBackToGallery() {
    // URL에서 작품 ID 제거
    removeArtworkIdFromURL();
    
    // 현재 상태가 갤러리가 아닌 경우, 갤러리 페이지로 전환
    if (appState.currentPage !== 'gallery' && utils.validateElement(elements.galleryPage, 'galleryPage')) {
        appState.currentPage = 'gallery';
        showPage(elements.galleryPage);
    }
}

// 메인 페이지로 돌아가기
function goBackToHome() {
    // URL에서 작품 ID 제거
    removeArtworkIdFromURL();
    
    // 모든 페이지 숨기기
    document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
    });
    
    // 페이지 상태 업데이트
    appState.currentPage = 'home';
}

// 작품 다운로드
function downloadArtwork(artwork) {
    if (!artwork || !artwork.data) {
        utils.showToast('작품 데이터를 찾을 수 없습니다', 'error');
        return;
    }
    
    try {
        // XSS 방지 및 민감 정보 제거
        const safeData = {
            ...artwork.data,
            exportVersion: CONFIG.APP_VERSION,
            exportDate: new Date().toISOString(),
            title: artwork.title,
            creator: artwork.creator,
            description: artwork.description,
            timestamp: artwork.timestamp
        };
        
        // 안전한 파일명 생성
        const safeFilename = utils.sanitizeFileName(artwork.title || 'artwork');
        
        const jsonData = JSON.stringify(safeData, null, 2);
        const blob = new Blob([jsonData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${safeFilename}.val`;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        
        // 정리
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        utils.showToast(`${safeFilename}.val 파일이 다운로드되었습니다`, 'success');
    } catch (error) {
        console.error('다운로드 오류:', error);
        utils.showToast('다운로드 중 오류가 발생했습니다', 'error');
    }
}

// 작품을 캔버스로 불러오기
function loadArtworkToCanvas(artwork) {
    if (!artwork || !artwork.data) {
        utils.showToast('작품 데이터를 찾을 수 없습니다', 'error');
        return;
    }
    
    try {
        if (canvasRenderer.importCanvasData(artwork.data)) {
            utils.showToast('작품을 캔버스에 불러왔습니다', 'success');
            goBackToHome();
        } else {
            utils.showToast('작품을 불러오는 데 실패했습니다', 'error');
        }
    } catch (error) {
        console.error('작품 불러오기 오류:', error);
        utils.showToast('작품을 불러오는 데 실패했습니다', 'error');
    }
}

// 인증 모달 표시
function showAuthModal() {
    if (!utils.validateElement(elements.authModal, 'authModal') ||
        !utils.validateElement(elements.loginForm, 'loginForm') ||
        !utils.validateElement(elements.registerForm, 'registerForm') ||
        !utils.validateElement(elements.loginUsername, 'loginUsername') ||
        !utils.validateElement(elements.loginPassword, 'loginPassword') ||
        !utils.validateElement(elements.registerUsername, 'registerUsername') ||
        !utils.validateElement(elements.registerPassword, 'registerPassword') ||
        !utils.validateElement(elements.registerPasswordConfirm, 'registerPasswordConfirm') ||
        !utils.validateElement(elements.acceptTerms, 'acceptTerms')) {
        utils.showToast('인증 모달을 표시할 수 없습니다', 'error');
        return;
    }
    
    // 현재 탭 초기화 (로그인 탭으로)
    document.querySelectorAll('#auth-modal .auth-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === 'login');
    });
    
    // 폼 초기화
    elements.loginForm.style.display = 'block';
    elements.registerForm.style.display = 'none';
    
    // 필드 초기화
    elements.loginUsername.value = '';
    elements.loginPassword.value = '';
    elements.registerUsername.value = '';
    elements.registerPassword.value = '';
    elements.registerPasswordConfirm.value = '';
    elements.acceptTerms.checked = false;
    
    // 모달 표시
    utils.showModal(elements.authModal);
}

// 로그인 처리
async function handleLogin(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.loginUsername, 'loginUsername') ||
        !utils.validateElement(elements.loginPassword, 'loginPassword') ||
        !utils.validateElement(elements.loginForm, 'loginForm') ||
        !utils.validateElement(elements.authModal, 'authModal') ||
        !utils.validateElement(elements.guestModeBanner, 'guestModeBanner') ||
        !utils.validateElement(elements.userDisplayName, 'userDisplayName')) {
        utils.showToast('로그인 폼을 찾을 수 없습니다', 'error');
        return;
    }
    
    const username = elements.loginUsername.value.trim();
    const password = elements.loginPassword.value;
    
    if (!username || !password) {
        utils.showToast('사용자명과 비밀번호를 입력해주세요', 'error');
        return;
    }
    
    try {
        // 로딩 표시
        const submitBtn = elements.loginForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
            utils.showToast('로그인 버튼을 찾을 수 없습니다', 'error');
            return;
        }
        
        const originalBtnText = submitBtn.innerHTML;
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px;"></div> 로그인 중...';
        
        // 로그인 시도
        const result = await api.loginUser(username, password);
        
        if (!result.success) {
            throw new Error(result.message || '로그인에 실패했습니다');
        }
        
        // 로그인 성공
        utils.showToast(`${username}님, 환영합니다!`, 'success');
        utils.hideModal(elements.authModal);
        
        // 비회원 모드 배너 숨기기
        elements.guestModeBanner.style.display = 'none';
        
        // 사용자 이름 표시 업데이트
        elements.userDisplayName.textContent = username;
        
        // UI 업데이트
        updateUIAfterAuth();
        
        // 현재 페이지 새로고침
        if (appState.currentPage === 'gallery') {
            loadGalleryItems(appState.currentTab);
        }
    } catch (error) {
        console.error('로그인 오류:', error);
        utils.showToast(error.message || '로그인 중 오류가 발생했습니다', 'error');
    } finally {
        // 버튼 상태 복원
        const submitBtn = elements.loginForm.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnText;
        }
    }
}

// 회원가입 처리
async function handleRegister(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.registerUsername, 'registerUsername') ||
        !utils.validateElement(elements.registerPassword, 'registerPassword') ||
        !utils.validateElement(elements.registerPasswordConfirm, 'registerPasswordConfirm') ||
        !utils.validateElement(elements.acceptTerms, 'acceptTerms') ||
        !utils.validateElement(elements.registerForm, 'registerForm') ||
        !utils.validateElement(elements.authModal, 'authModal') ||
        !utils.validateElement(elements.guestModeBanner, 'guestModeBanner') ||
        !utils.validateElement(elements.userDisplayName, 'userDisplayName')) {
        utils.showToast('회원가입 폼을 찾을 수 없습니다', 'error');
        return;
    }
    
    const username = elements.registerUsername.value.trim();
    const password = elements.registerPassword.value;
    const passwordConfirm = elements.registerPasswordConfirm.value;
    const termsAccepted = elements.acceptTerms.checked;
    
    // 유효성 검사
    if (!username || !password) {
        utils.showToast('사용자명과 비밀번호를 입력해주세요', 'error');
        return;
    }
    
    // 사용자명 검증
    const usernameValidation = utils.validateUsername(username);
    if (!usernameValidation.valid) {
        utils.showToast(usernameValidation.message, 'error');
        return;
    }
    
    // 비밀번호 검증
    const passwordValidation = utils.validatePassword(password);
    if (!passwordValidation.valid) {
        utils.showToast(passwordValidation.message, 'error');
        return;
    }
    
    if (password !== passwordConfirm) {
        utils.showToast('비밀번호가 일치하지 않습니다', 'error');
        return;
    }
    
    if (!termsAccepted) {
        utils.showToast('이용약관에 동의해주세요', 'error');
        return;
    }
    
    try {
        // 로딩 표시
        const submitBtn = elements.registerForm.querySelector('button[type="submit"]');
        if (!submitBtn) {
            utils.showToast('회원가입 버튼을 찾을 수 없습니다', 'error');
            return;
        }
        
        const originalBtnText = submitBtn.innerHTML;
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px;"></div> 가입 중...';
        
        // 회원가입 시도
        const result = await api.registerUser(username, password);
        
        if (!result.success) {
            throw new Error(result.message || '회원가입에 실패했습니다');
        }
        
        // 회원가입 성공
        utils.showToast(`${username}님, 가입을 환영합니다!`, 'success');
        utils.hideModal(elements.authModal);
        
        // 비회원 모드 배너 숨기기
        elements.guestModeBanner.style.display = 'none';
        
        // 사용자 이름 표시 업데이트
        elements.userDisplayName.textContent = username;
        
        // UI 업데이트
        updateUIAfterAuth();
    } catch (error) {
        console.error('회원가입 오류:', error);
        utils.showToast(error.message || '회원가입 중 오류가 발생했습니다', 'error');
    } finally {
        // 버튼 상태 복원
        const submitBtn = elements.registerForm.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnText;
        }
    }
}

// 비회원 모드 활성화
function enableGuestMode() {
    if (!utils.validateElement(elements.guestModeBanner, 'guestModeBanner') ||
        !utils.validateElement(elements.userDisplayName, 'userDisplayName') ||
        !utils.validateElement(elements.authModal, 'authModal')) {
        utils.showToast('비회원 모드를 활성화할 수 없습니다', 'error');
        return;
    }
    
    appState.isGuestMode = true;
    appState.isAuthenticated = false;
    
    // 비회원 모드 배너 표시
    elements.guestModeBanner.style.display = 'flex';
    
    // 사용자 이름 업데이트
    elements.userDisplayName.textContent = '비회원';
    
    // 모달 닫기
    utils.hideModal(elements.authModal);
    
    // 토스트 메시지 표시
    utils.showToast('비회원 모드로 시작합니다. 온라인 기능이 제한됩니다.', 'info');
    
    // 설정에 작가명 저장
    settings.author = '비회원';
    utils.storage.saveSettings(settings);
}

// 인증 후 UI 업데이트
function updateUIAfterAuth() {
    // 비회원 모드 해제
    appState.isGuestMode = false;
    appState.isAuthenticated = true;
    
    // 설정에 작가명 저장
    settings.author = api.getUsername();
    utils.storage.saveSettings(settings);
}

// 계정 설정 모달 열기
function openAccountSettings() {
    if (!utils.validateElement(elements.userSettingsModal, 'userSettingsModal') ||
        !utils.validateElement(elements.accountUsername, 'accountUsername') ||
        !utils.validateElement(elements.accountCurrentPassword, 'accountCurrentPassword') ||
        !utils.validateElement(elements.accountNewPassword, 'accountNewPassword')) {
        utils.showToast('계정 설정 모달을 열 수 없습니다', 'error');
        return;
    }
    
    if (!api.isAuthenticated()) {
        utils.showToast('로그인이 필요합니다', 'error');
        showAuthModal();
        return;
    }
    
    // 필드 초기화
    elements.accountUsername.value = api.getUsername();
    elements.accountCurrentPassword.value = '';
    elements.accountNewPassword.value = '';
    
    utils.showModal(elements.userSettingsModal);
}

// 계정 설정 저장
async function saveAccountSettings(event) {
    if (event) event.preventDefault();
    
    if (!utils.validateElement(elements.accountUsername, 'accountUsername') ||
        !utils.validateElement(elements.accountCurrentPassword, 'accountCurrentPassword') ||
        !utils.validateElement(elements.accountNewPassword, 'accountNewPassword') ||
        !utils.validateElement(elements.accountSaveBtn, 'accountSaveBtn') ||
        !utils.validateElement(elements.userSettingsModal, 'userSettingsModal') ||
        !utils.validateElement(elements.userDisplayName, 'userDisplayName')) {
        utils.showToast('계정 설정 폼을 찾을 수 없습니다', 'error');
        return;
    }
    
    const username = elements.accountUsername.value.trim();
    const currentPassword = elements.accountCurrentPassword.value;
    const newPassword = elements.accountNewPassword.value;
    
    // 사용자명 검증
    if (!username) {
        utils.showToast('작가명을 입력해주세요', 'error');
        return;
    }
    
    // 사용자명 유효성 검사
    const usernameValidation = utils.validateUsername(username);
    if (!usernameValidation.valid) {
        utils.showToast(usernameValidation.message, 'error');
        return;
    }
    
    // 현재 비밀번호 검증
    if (!currentPassword) {
        utils.showToast('현재 비밀번호를 입력해주세요', 'error');
        return;
    }
    
    // 새 비밀번호 유효성 검사 (입력된 경우에만)
    if (newPassword) {
        const passwordValidation = utils.validatePassword(newPassword);
        if (!passwordValidation.valid) {
            utils.showToast(passwordValidation.message, 'error');
            return;
        }
    }
    
    try {
        // 로딩 표시
        elements.accountSaveBtn.disabled = true;
        elements.accountSaveBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px;"></div> 저장 중...';
        
        // 비밀번호 확인
        const passwordCorrect = await api.verifyPassword(currentPassword);
        
        if (!passwordCorrect) {
            utils.showToast('현재 비밀번호가 일치하지 않습니다', 'error');
            elements.accountSaveBtn.disabled = false;
            elements.accountSaveBtn.textContent = '저장';
            return;
        }
        
        // 계정 정보 업데이트
        const updateResult = await api.updateAccount(username, newPassword || '');
        
        if (updateResult.success) {
            utils.showToast('계정 정보가 업데이트되었습니다', 'success');
            utils.hideModal(elements.userSettingsModal);
            
            // 사용자명 업데이트
            elements.userDisplayName.textContent = username;
            
            // 설정에 작가명 업데이트
            settings.author = username;
            utils.storage.saveSettings(settings);
        } else {
            throw new Error(updateResult.message || '계정 업데이트에 실패했습니다');
        }
    } catch (error) {
        console.error('계정 설정 저장 오류:', error);
        utils.showToast(error.message || '계정 정보 업데이트 중 오류가 발생했습니다', 'error');
    } finally {
        // 버튼 상태 복원
        elements.accountSaveBtn.disabled = false;
        elements.accountSaveBtn.textContent = '저장';
    }
}

// 계정 삭제 모달 열기
function openDeleteAccount() {
    if (!utils.validateElement(elements.deleteAccountModal, 'deleteAccountModal') ||
        !utils.validateElement(elements.deleteConfirmPassword, 'deleteConfirmPassword') ||
        !utils.validateElement(elements.deleteConfirmCheck, 'deleteConfirmCheck') ||
        !utils.validateElement(elements.deleteConfirmBtn, 'deleteConfirmBtn')) {
        utils.showToast('계정 삭제 모달을 열 수 없습니다', 'error');
        return;
    }
    
    if (!api.isAuthenticated()) {
        utils.showToast('로그인이 필요합니다', 'error');
        showAuthModal();
        return;
    }
    
    // 필드 초기화
    elements.deleteConfirmPassword.value = '';
    elements.deleteConfirmCheck.checked = false;
    elements.deleteConfirmBtn.disabled = true;
    elements.deleteConfirmBtn.style.opacity = '0.5';
    
    utils.showModal(elements.deleteAccountModal);
}

// 계정 삭제 확인 버튼 활성화/비활성화
function toggleDeleteConfirmButton() {
    if (!utils.validateElement(elements.deleteConfirmCheck, 'deleteConfirmCheck') ||
        !utils.validateElement(elements.deleteConfirmPassword, 'deleteConfirmPassword') ||
        !utils.validateElement(elements.deleteConfirmBtn, 'deleteConfirmBtn')) {
        return;
    }
    
    if (elements.deleteConfirmCheck.checked && elements.deleteConfirmPassword.value.trim() !== '') {
        elements.deleteConfirmBtn.disabled = false;
        elements.deleteConfirmBtn.style.opacity = '1';
    } else {
        elements.deleteConfirmBtn.disabled = true;
        elements.deleteConfirmBtn.style.opacity = '0.5';
    }
}

// 계정 삭제 실행
async function confirmDeleteAccount() {
    if (!utils.validateElement(elements.deleteConfirmPassword, 'deleteConfirmPassword') ||
        !utils.validateElement(elements.deleteConfirmCheck, 'deleteConfirmCheck') ||
        !utils.validateElement(elements.deleteConfirmBtn, 'deleteConfirmBtn') ||
        !utils.validateElement(elements.deleteAccountModal, 'deleteAccountModal')) {
        utils.showToast('계정 삭제 폼을 찾을 수 없습니다', 'error');
        return;
    }
    
    const password = elements.deleteConfirmPassword.value;
    
    if (!password) {
        utils.showToast('비밀번호를 입력해주세요', 'error');
        return;
    }
    
    if (!elements.deleteConfirmCheck.checked) {
        utils.showToast('삭제 동의를 확인해주세요', 'error');
        return;
    }
    
    elements.deleteConfirmBtn.disabled = true;
    elements.deleteConfirmBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px; margin-right: 8px;"></div> 삭제 중...';
    
    try {
        // 비밀번호 확인
        const passwordCorrect = await api.verifyPassword(password);
        
        if (!passwordCorrect) {
            utils.showToast('비밀번호가 일치하지 않습니다', 'error');
            elements.deleteConfirmBtn.disabled = false;
            elements.deleteConfirmBtn.innerHTML = '계정 삭제';
            return;
        }
        
        // 계정 삭제
        const result = await api.deleteAccount();
        
        if (result.success) {
            // 로컬 데이터 모두 삭제
            utils.storage.clearAll();
            
            // 상태 초기화
            appState.isAuthenticated = false;
            appState.userName = '';
            appState.userId = '';
            appState.favorites = [];
            
            utils.showToast('계정이 성공적으로 삭제되었습니다', 'success');
            utils.hideModal(elements.deleteAccountModal);
            
            // 비회원 모드로 전환
            enableGuestMode();
            
            // 홈으로 이동
            if (appState.currentPage !== 'home') {
                goBackToHome();
            }
        } else {
            throw new Error(result.message || '계정 삭제에 실패했습니다');
        }
    } catch (error) {
        console.error('계정 삭제 오류:', error);
        utils.showToast(error.message || '계정 삭제 중 오류가 발생했습니다', 'error');
        
        elements.deleteConfirmBtn.disabled = false;
        elements.deleteConfirmBtn.innerHTML = '계정 삭제';
    }
}

// 키보드 단축키 핸들러
function handleKeyboardShortcuts(e) {
    // 입력 요소에 포커스가 있으면 단축키 비활성화
    if (document.activeElement.tagName === 'INPUT' || 
        document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    // 모달이 열려있으면 단축키 비활성화 (Esc 키 제외)
    const modalOpen = document.querySelector('.modal.show');
    if (modalOpen && e.key !== 'Escape') {
        return;
    }
    
    // 단축키 처리
    if (e.ctrlKey) {
        switch (e.key.toLowerCase()) {
            case 's': // Ctrl+S: 저장
                e.preventDefault();
                openSaveDialog();
                break;
            case 'o': // Ctrl+O: 불러오기
                e.preventDefault();
                openLoadDialog();
                break;
            case 'c': // Ctrl+C: 복사
                // 텍스트 선택 중이 아닐 때만 처리
                if (window.getSelection().toString() === '') {
                    e.preventDefault();
                    copyCanvas();
                }
                break;
            case 'e': // Ctrl+E: 내보내기/가져오기
                e.preventDefault();
                openExportImportDialog();
                break;
        }
    } else {
        switch (e.key) {
            case 'q': // Q: 그리기/지우기 모드 전환
                e.preventDefault();
                toggleEraserMode();
                break;
            case '+': 
            case '=': // +: 브러시 크기 증가
                e.preventDefault();
                increaseBrushSize();
                break;
            case '-': // -: 브러시 크기 감소
                e.preventDefault();
                decreaseBrushSize();
                break;
            case 'Delete': // Delete: 전체 지우기
                e.preventDefault();
                if (confirm('모든 내용을 지우시겠습니까?')) {
                    canvasRenderer.clearCanvas();
                }
                break;
            case 'F1': // F1: 도움말
                e.preventDefault();
                if (utils.validateElement(elements.helpModal, 'helpModal')) {
                    utils.showModal(elements.helpModal);
                }
                break;
            case 'F2': // F2: 설정
                e.preventDefault();
                if (utils.validateElement(elements.settingsModal, 'settingsModal')) {
                    updateSettingsUI();
                    utils.showModal(elements.settingsModal);
                }
                break;
            case 'Escape': // Esc: 모달 닫기 또는 페이지 뒤로가기
                if (modalOpen) {
                    e.preventDefault();
                    utils.hideModal(modalOpen);
                } else if (appState.currentPage !== 'home') {
                    e.preventDefault();
                    if (appState.currentPage === 'artwork') {
                        goBackToGallery();
                    } else {
                        goBackToHome();
                    }
                }
                break;
        }
    }
}

// 브러시 크기 변경 함수
function updateBrushSize(newSize) {
    if (!utils.validateElement(elements.brushSizeDisplay, 'brushSizeDisplay') ||
        !utils.validateElement(elements.brushSizeValue, 'brushSizeValue') ||
        !utils.validateElement(elements.brushSizeRange, 'brushSizeRange')) {
        return;
    }
    
    if (newSize >= CONFIG.MIN_BRUSH_SIZE && newSize <= CONFIG.MAX_BRUSH_SIZE) {
        settings.brushSize = newSize;
        elements.brushSizeDisplay.textContent = newSize;
        elements.brushSizeValue.textContent = newSize;
        elements.brushSizeRange.value = newSize;
        
        // 브러시 커서 업데이트
        if (appState.lastMousePosition) {
            const event = {
                pageX: appState.lastMousePosition.x,
                pageY: appState.lastMousePosition.y
            };
            updateBrushCursor(event);
        }
        
        utils.showToast(`브러시 크기: ${newSize}`, 'info');
    }
}

// 사용자 프로필 드롭다운 토글
function toggleUserDropdown() {
    if (!utils.validateElement(elements.userDropdownMenu, 'userDropdownMenu') ||
        !utils.validateElement(elements.userProfileBtn, 'userProfileBtn')) {
        return;
    }
    
    elements.userDropdownMenu.classList.toggle('active');
    
    // 드롭다운 외부 클릭 감지
    function closeDropdown(e) {
        if (!elements.userProfileBtn.contains(e.target) && !elements.userDropdownMenu.contains(e.target)) {
            elements.userDropdownMenu.classList.remove('active');
            document.removeEventListener('click', closeDropdown);
        }
    }
    
    if (elements.userDropdownMenu.classList.contains('active')) {
        setTimeout(() => {
            document.addEventListener('click', closeDropdown);
        }, 0);
    } else {
        document.removeEventListener('click', closeDropdown);
    }
}

// 도메인 검증 함수
function validateDomain() {
    const allowedDomains = ["valpaint.kro.kr", "localhost", "127.0.0.1"];
    const currentHost = window.location.hostname;
    
    // 로컬 개발 환경이나 허용된 도메인만 접근 가능
    if (!allowedDomains.includes(currentHost)) {
        document.body.innerHTML = `
            <div style="text-align: center; padding: 50px; font-family: Arial, sans-serif; background-color: var(--main-bg); color: var(--text-color); height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                <h1 style="color: var(--accent-color); font-family: var(--valorant-font);">접근 제한됨</h1>
                <p>이 애플리케이션은 공식 도메인에서만 실행할 수 있습니다.</p>
                <a href="http://valpaint.kro.kr" style="color: var(--accent-color); margin-top: 20px; padding: 10px 20px; border: 1px solid var(--accent-color); text-decoration: none; font-family: var(--valorant-font);">공식 사이트로 이동</a>
            </div>
        `;
        return false;
    }
    return true;
}

// 이벤트 리스너 설정
function setupEventListeners() {
    // DOM이 완전히 로드되었는지 확인
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupEventListeners);
        return;
    }
    
    // 사용자 프로필 클릭 이벤트
    if (utils.validateElement(elements.userProfileBtn, 'userProfileBtn')) {
        elements.userProfileBtn.addEventListener('click', toggleUserDropdown);
    }
    
    // 계정 설정 버튼 이벤트
    if (utils.validateElement(elements.userSettingsBtn, 'userSettingsBtn') &&
        utils.validateElement(elements.userDropdownMenu, 'userDropdownMenu')) {
        elements.userSettingsBtn.addEventListener('click', () => {
            elements.userDropdownMenu.classList.remove('active');
            openAccountSettings();
        });
    }
    
    // 계정 삭제 버튼 이벤트
    if (utils.validateElement(elements.deleteAccountBtn, 'deleteAccountBtn') &&
        utils.validateElement(elements.userDropdownMenu, 'userDropdownMenu')) {
        elements.deleteAccountBtn.addEventListener('click', () => {
            elements.userDropdownMenu.classList.remove('active');
            openDeleteAccount();
        });
    }
    
    // 계정 설정 모달 이벤트
    if (utils.validateElement(elements.userSettingsModal, 'userSettingsModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.userSettingsModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.userSettingsModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.accountCancelBtn, 'accountCancelBtn')) {
            elements.accountCancelBtn.addEventListener('click', () => utils.hideModal(elements.userSettingsModal));
        }
        
        // 저장 버튼
        if (utils.validateElement(elements.accountSaveBtn, 'accountSaveBtn')) {
            elements.accountSaveBtn.addEventListener('click', saveAccountSettings);
        }
        
        // 폼 제출 이벤트
        if (utils.validateElement(elements.accountSettingsForm, 'accountSettingsForm')) {
            elements.accountSettingsForm.addEventListener('submit', saveAccountSettings);
        }
    }
    
    // 계정 삭제 모달 이벤트
    if (utils.validateElement(elements.deleteAccountModal, 'deleteAccountModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.deleteAccountModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.deleteAccountModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.deleteCancelBtn, 'deleteCancelBtn')) {
            elements.deleteCancelBtn.addEventListener('click', () => utils.hideModal(elements.deleteAccountModal));
        }
        
        // 삭제 확인 체크박스 이벤트
        if (utils.validateElement(elements.deleteConfirmCheck, 'deleteConfirmCheck') && 
            utils.validateElement(elements.deleteConfirmPassword, 'deleteConfirmPassword')) {
            elements.deleteConfirmCheck.addEventListener('change', toggleDeleteConfirmButton);
            elements.deleteConfirmPassword.addEventListener('input', toggleDeleteConfirmButton);
        }
        
        // 삭제 확인 버튼
        if (utils.validateElement(elements.deleteConfirmBtn, 'deleteConfirmBtn')) {
            elements.deleteConfirmBtn.addEventListener('click', confirmDeleteAccount);
        }
        
        // 폼 제출 이벤트
        if (utils.validateElement(elements.deleteAccountForm, 'deleteAccountForm')) {
            elements.deleteAccountForm.addEventListener('submit', (event) => {
                event.preventDefault();
                confirmDeleteAccount();
            });
        }
    }
    
    // 설정 모달 이벤트
    if (utils.validateElement(elements.settingsModal, 'settingsModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.settingsModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.settingsModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.settingsCancelBtn, 'settingsCancelBtn')) {
            elements.settingsCancelBtn.addEventListener('click', () => utils.hideModal(elements.settingsModal));
        }
        
        // 저장 버튼
        if (utils.validateElement(elements.settingsSaveBtn, 'settingsSaveBtn')) {
            elements.settingsSaveBtn.addEventListener('click', applySettings);
        }
        
        // 폼 제출 이벤트
        if (utils.validateElement(elements.appSettingsForm, 'appSettingsForm')) {
            elements.appSettingsForm.addEventListener('submit', applySettings);
        }
        
        // 커스텀 모드 토글
        if (utils.validateElement(elements.customModeSwitch, 'customModeSwitch') &&
            utils.validateElement(elements.customEmojiSettings, 'customEmojiSettings') &&
            utils.validateElement(elements.bgModeSwitch, 'bgModeSwitch')) {
            elements.customModeSwitch.addEventListener('change', function() {
                elements.customEmojiSettings.style.display = this.checked ? 'block' : 'none';
                
                if (this.checked) {
                    // 커스텀 모드가 켜지면 배경 투명 모드 비활성화
                    elements.bgModeSwitch.checked = false;
                    elements.bgModeSwitch.disabled = true;
                } else {
                    elements.bgModeSwitch.disabled = false;
                }
            });
        }
    }
    
    // 파일 모달 이벤트
    if (utils.validateElement(elements.fileModal, 'fileModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.fileModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.fileModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.fileModalCancelBtn, 'fileModalCancelBtn')) {
            elements.fileModalCancelBtn.addEventListener('click', () => utils.hideModal(elements.fileModal));
        }
        
        // 저장/불러오기 버튼
        if (utils.validateElement(elements.fileActionBtn, 'fileActionBtn')) {
            elements.fileActionBtn.addEventListener('click', function() {
                if (this.textContent === '저장') {
                    saveFile();
                } else if (this.textContent === '불러오기') {
                    loadFile();
                }
            });
        }
        
        // 폼 제출 이벤트
        if (utils.validateElement(elements.fileForm, 'fileForm')) {
            elements.fileForm.addEventListener('submit', saveFile);
        }
        
        // 삭제 버튼
        if (utils.validateElement(elements.fileDeleteBtn, 'fileDeleteBtn')) {
            elements.fileDeleteBtn.addEventListener('click', deleteFile);
        }
        
        // 내보내기 버튼
        if (utils.validateElement(elements.fileExportBtn, 'fileExportBtn')) {
            elements.fileExportBtn.addEventListener('click', exportSelectedFile);
        }
    }
    
    // 내보내기/가져오기 모달 이벤트
    if (utils.validateElement(elements.exportImportModal, 'exportImportModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.exportImportModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.exportImportModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.exportImportCancelBtn, 'exportImportCancelBtn')) {
            elements.exportImportCancelBtn.addEventListener('click', () => utils.hideModal(elements.exportImportModal));
        }
        
        // 내보내기 버튼
        if (utils.validateElement(elements.exportBtn, 'exportBtn')) {
            elements.exportBtn.addEventListener('click', showExportUI);
        }
        
        // 가져오기 버튼
        if (utils.validateElement(elements.importBtn, 'importBtn')) {
            elements.importBtn.addEventListener('click', showImportUI);
        }
        
        // 실행 버튼 이벤트 
        if (utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn')) {
            elements.executeExportImportBtn.addEventListener('click', function() {
                if (this.textContent === '내보내기') {
                    exportFile();
                } else if (this.textContent === '가져오기') {
                    importFile();
                }
            });
        }
        
        // 가져오기 확인 체크박스 이벤트
        if (utils.validateElement(elements.importConfirmCheck, 'importConfirmCheck') &&
            utils.validateElement(elements.executeExportImportBtn, 'executeExportImportBtn')) {
            elements.importConfirmCheck.addEventListener('change', function() {
                elements.executeExportImportBtn.disabled = !this.checked;
            });
        }
    }
    
    // 공유 모달 이벤트
    if (utils.validateElement(elements.shareModal, 'shareModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.shareModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.shareModal));
        }
        
        // 취소 버튼
        if (utils.validateElement(elements.shareModalCancelBtn, 'shareModalCancelBtn')) {
            elements.shareModalCancelBtn.addEventListener('click', () => utils.hideModal(elements.shareModal));
        }
        
        // 공유 버튼
        if (utils.validateElement(elements.shareActionBtn, 'shareActionBtn')) {
            elements.shareActionBtn.addEventListener('click', shareArtwork);
        }
        
        // 폼 제출 이벤트
        if (utils.validateElement(elements.shareForm, 'shareForm')) {
            elements.shareForm.addEventListener('submit', shareArtwork);
        }
    }
    
    // 도움말 모달 이벤트
    if (utils.validateElement(elements.helpModal, 'helpModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.helpModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.helpModal));
        }
        
        // 확인 버튼
        if (utils.validateElement(elements.helpCloseBtn, 'helpCloseBtn')) {
            elements.helpCloseBtn.addEventListener('click', () => utils.hideModal(elements.helpModal));
        }
        
        // 단축키 버튼
        if (utils.validateElement(elements.shortcutsBtn, 'shortcutsBtn') &&
            utils.validateElement(elements.shortcutsModal, 'shortcutsModal')) {
            elements.shortcutsBtn.addEventListener('click', () => {
                utils.hideModal(elements.helpModal);
                utils.showModal(elements.shortcutsModal);
            });
        }
    }
    
    // 단축키 모달 이벤트
    if (utils.validateElement(elements.shortcutsModal, 'shortcutsModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.shortcutsModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.shortcutsModal));
        }
        
        // 확인 버튼
        if (utils.validateElement(elements.shortcutsCloseBtn, 'shortcutsCloseBtn')) {
            elements.shortcutsCloseBtn.addEventListener('click', () => utils.hideModal(elements.shortcutsModal));
        }
    }
    
    // 인증 모달 이벤트
    if (utils.validateElement(elements.authModal, 'authModal')) {
        // 모달 닫기 버튼
        const closeBtn = elements.authModal.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => utils.hideModal(elements.authModal));
        }
        
        // 탭 전환
        document.querySelectorAll('#auth-modal .auth-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                // 탭 스타일 업데이트
                document.querySelectorAll('#auth-modal .auth-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tab === tabName);
                });
                
                // 폼 표시 전환
                if (tabName === 'login' && 
                    utils.validateElement(elements.loginForm, 'loginForm') && 
                    utils.validateElement(elements.registerForm, 'registerForm')) {
                    elements.loginForm.style.display = 'block';
                    elements.registerForm.style.display = 'none';
                } else if (tabName === 'register' && 
                           utils.validateElement(elements.loginForm, 'loginForm') && 
                           utils.validateElement(elements.registerForm, 'registerForm')) {
                    elements.loginForm.style.display = 'none';
                    elements.registerForm.style.display = 'block';
                }
            });
        });
        
        // 로그인 폼 제출
        if (utils.validateElement(elements.loginForm, 'loginForm')) {
            elements.loginForm.addEventListener('submit', handleLogin);
        }
        
        // 회원가입 폼 제출
        if (utils.validateElement(elements.registerForm, 'registerForm')) {
            elements.registerForm.addEventListener('submit', handleRegister);
        }
        
        // 비회원 모드 버튼
        if (utils.validateElement(elements.guestModeBtn, 'guestModeBtn')) {
            elements.guestModeBtn.addEventListener('click', enableGuestMode);
        }
        
        // 비회원 모드에서 로그인 버튼
        if (utils.validateElement(elements.guestLoginBtn, 'guestLoginBtn')) {
            elements.guestLoginBtn.addEventListener('click', showAuthModal);
        }
    }
    
    // 갤러리 페이지 이벤트
    if (utils.validateElement(elements.galleryPage, 'galleryPage')) {
        // 돌아가기 버튼
        if (utils.validateElement(elements.galleryBackBtn, 'galleryBackBtn')) {
            elements.galleryBackBtn.addEventListener('click', goBackToHome);
        }
        
        // 탭 전환
        if (utils.validateElement(elements.galleryTabs, 'galleryTabs')) {
            elements.galleryTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // 페이지 리셋
                    appState.pageParams.page = 1;
                    loadGalleryItems(this.dataset.tab);
                });
            });
        }
        
        // 검색 이벤트
        if (utils.validateElement(elements.searchInput, 'searchInput')) {
            elements.searchInput.addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    // 페이지 리셋
                    appState.pageParams.page = 1;
                    loadGalleryItems(appState.currentTab);
                }
            });
        }
        
        // 필터 버튼 클릭
        if (utils.validateElement(elements.filterBtn, 'filterBtn') && 
            utils.validateElement(elements.filterMenu, 'filterMenu')) {
            elements.filterBtn.addEventListener('click', function() {
                elements.filterMenu.classList.toggle('active');
                
                // 외부 클릭 감지
                function closeFilterMenu(e) {
                    if (!elements.filterBtn.contains(e.target) && !elements.filterMenu.contains(e.target)) {
                        elements.filterMenu.classList.remove('active');
                        document.removeEventListener('click', closeFilterMenu);
                    }
                }
                
                if (elements.filterMenu.classList.contains('active')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeFilterMenu);
                    }, 0);
                } else {
                    document.removeEventListener('click', closeFilterMenu);
                }
            });
            
            // 필터 항목 클릭
            if (utils.validateElement(elements.filterItems, 'filterItems')) {
                elements.filterItems.forEach(item => {
                    item.addEventListener('click', function() {
                        // 스타일 업데이트
                        elements.filterItems.forEach(i => i.classList.remove('active'));
                        this.classList.add('active');
                        
                        // 필터 적용
                        appState.currentFilter = this.dataset.filter;
                        
                        // 메뉴 닫기
                        elements.filterMenu.classList.remove('active');
                        
                        // 페이지 리셋
                        appState.pageParams.page = 1;
                        
                        // 갤러리 새로고침
                        loadGalleryItems(appState.currentTab);
                    });
                });
            }
        }
        
        // 새로고침 버튼
        if (utils.validateElement(elements.refreshGalleryBtn, 'refreshGalleryBtn')) {
            elements.refreshGalleryBtn.addEventListener('click', function() {
                loadGalleryItems(appState.currentTab);
            });
        }
    }
    
    // 작품 상세 페이지 이벤트
    if (utils.validateElement(elements.artworkPage, 'artworkPage') && 
        utils.validateElement(elements.artworkBackBtn, 'artworkBackBtn')) {
        // 돌아가기 버튼
        elements.artworkBackBtn.addEventListener('click', goBackToGallery);
    }
    
    // 도구 버튼 이벤트
    if (utils.validateElement(elements.drawEraseBtn, 'drawEraseBtn')) {
        elements.drawEraseBtn.addEventListener('click', toggleEraserMode);
    }
    
    if (utils.validateElement(elements.clearBtn, 'clearBtn')) {
        elements.clearBtn.addEventListener('click', () => {
            if (confirm('모든 내용을 지우시겠습니까?')) {
                canvasRenderer.clearCanvas();
            }
        });
    }
    
    // 브러시 크기 버튼 이벤트
    if (utils.validateElement(elements.brushSizeDownBtn, 'brushSizeDownBtn') && 
        utils.validateElement(elements.brushSizeUpBtn, 'brushSizeUpBtn')) {
        elements.brushSizeDownBtn.addEventListener('click', decreaseBrushSize);
        elements.brushSizeUpBtn.addEventListener('click', increaseBrushSize);
    }
    
    // 파일 관리 버튼 이벤트
    if (utils.validateElement(elements.saveBtn, 'saveBtn')) {
        elements.saveBtn.addEventListener('click', openSaveDialog);
    }
    
    if (utils.validateElement(elements.loadBtn, 'loadBtn')) {
        elements.loadBtn.addEventListener('click', openLoadDialog);
    }
    
    if (utils.validateElement(elements.exportImportBtn, 'exportImportBtn')) {
        elements.exportImportBtn.addEventListener('click', openExportImportDialog);
    }
    
    // 복사 버튼 이벤트
    if (utils.validateElement(elements.copyBtn, 'copyBtn')) {
        elements.copyBtn.addEventListener('click', copyCanvas);
    }
    
    // 공유 버튼 이벤트
    if (utils.validateElement(elements.shareBtn, 'shareBtn')) {
        elements.shareBtn.addEventListener('click', openShareModal);
    }
    
    // 갤러리 버튼 이벤트
    if (utils.validateElement(elements.galleryBtn, 'galleryBtn')) {
        elements.galleryBtn.addEventListener('click', openGalleryPage);
    }
    
    // 설정 및 도움말 버튼 이벤트
    if (utils.validateElement(elements.settingsBtn, 'settingsBtn') && 
        utils.validateElement(elements.settingsModal, 'settingsModal')) {
        elements.settingsBtn.addEventListener('click', () => {
            updateSettingsUI();
            utils.showModal(elements.settingsModal);
        });
    }
    
    if (utils.validateElement(elements.helpBtn, 'helpBtn') && 
        utils.validateElement(elements.helpModal, 'helpModal')) {
        elements.helpBtn.addEventListener('click', () => {
            utils.showModal(elements.helpModal);
        });
    }
    
    // 로고 클릭 이벤트
    const logo = document.querySelector('.logo');
    if (logo) {
        logo.addEventListener('click', goBackToHome);
    }
    
    // 키보드 단축키
    document.addEventListener('keydown', handleKeyboardShortcuts);
    
    // 드래그 종료 이벤트
    document.addEventListener('mouseup', () => {
        appState.isDragging = false;
        appState.lastCellPosition = null;
    });
    
    document.addEventListener('touchend', () => {
        appState.isDragging = false;
        appState.lastCellPosition = null;
    });
    
    // 브러시 커서 이벤트
    document.addEventListener('mousemove', function(e) {
        if (!utils.validateElement(elements.drawingCanvas, 'drawingCanvas') || 
            !utils.validateElement(elements.brushCursor, 'brushCursor')) {
            return;
        }
        
        // 캔버스 영역 내부인지 확인
        const canvasRect = elements.drawingCanvas.getBoundingClientRect();
        if (
            e.clientX >= canvasRect.left && 
            e.clientX <= canvasRect.right && 
            e.clientY >= canvasRect.top && 
            e.clientY <= canvasRect.bottom
        ) {
            // 캔버스 영역 내부면 커서 보이기
            elements.brushCursor.style.display = 'block';
            updateBrushCursor(e);
        } else {
            // 캔버스 영역 외부면 커서 숨기기
            elements.brushCursor.style.display = 'none';
        }
    });
    
    // 브러시 커서 숨기기 (캔버스 영역 벗어날 때)
    if (utils.validateElement(elements.drawingCanvas, 'drawingCanvas') && 
        utils.validateElement(elements.brushCursor, 'brushCursor')) {
        elements.drawingCanvas.addEventListener('mouseleave', function() {
            elements.brushCursor.style.display = 'none';
        });
    }
    
    // 모바일 터치 이벤트 중 페이지 스크롤 방지
    if (utils.validateElement(elements.drawingCanvas, 'drawingCanvas')) {
        elements.drawingCanvas.addEventListener('touchmove', function(e) {
            if (appState.isDragging) {
                e.preventDefault();
            }
        }, { passive: false });
    }
    
    // URL 해시 변경 이벤트
    window.addEventListener('hashchange', handleHashChange);
    
    // 창 크기 변경 이벤트
    window.addEventListener('resize', function() {
        // 브러시 커서 위치 조정
        if (appState.lastMousePosition && utils.validateElement(elements.brushCursor, 'brushCursor')) {
            updateBrushCursor({
                pageX: appState.lastMousePosition.x,
                pageY: appState.lastMousePosition.y
            });
        }
    });
}

// URL 해시 변경 처리
function handleHashChange() {
    const hash = window.location.hash.substring(1);
    
    if (hash) {
        // 작품 ID가 있으면 작품 상세 페이지 열기
        openArtworkPage(hash);
    } else {
        // 해시가 없으면 홈으로
        goBackToHome();
    }
}

// VALORANT 폰트 적용 함수
function applyValorantFont() {
    // 모든 모달 제목에 폰트 적용
    const modalTitles = document.querySelectorAll('.modal-title, .page-title, .section-title');
    modalTitles.forEach(el => {
        if (!el.classList.contains('valorant-text')) {
            el.classList.add('valorant-text');
        }
    });
    
    // 버튼 내부 텍스트에 폰트 적용
    const buttons = document.querySelectorAll('.btn-accent');
    buttons.forEach(button => {
        // 이미 처리된 버튼이면 건너뛰기
        if (button.dataset.fontApplied) return;
        
        // 버튼 내의 텍스트 노드 찾기
        let textNodes = [];
        for (let i = 0; i < button.childNodes.length; i++) {
            const node = button.childNodes[i];
            if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                textNodes.push(node);
            }
        }
        
        // 텍스트 노드 처리
        textNodes.forEach(node => {
            const text = node.textContent.trim();
            if (text) {
                const span = document.createElement('span');
                span.className = 'valorant-text';
                span.textContent = text;
                button.insertBefore(span, node);
                button.removeChild(node);
            }
        });
        
        // 처리 표시
        button.dataset.fontApplied = 'true';
    });
}

// 초기화 및 이벤트 핸들러 설정
async function initialize() {
    // 도메인 검증
    if (!validateDomain()) {
        // 도메인 검증 실패 시 더 이상 진행하지 않음
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        return;
    }
    
    // 로딩 화면 표시
    if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
        elements.loadingScreen.style.display = 'flex';
    }
    
    try {
        // API 초기화
        await api.init();
        
        // 작가명이 설정되어 있는지 확인
        const username = api.getUsername();
        const isLoggedIn = api.isAuthenticated();
        
        if (username && isLoggedIn) {
            // 로그인 상태이면 바로 시작
            await startApp();
        } else {
            // 로그인 상태가 아니면 로그인 모달 표시
            setTimeout(() => {
                if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
                    elements.loadingScreen.style.display = 'none';
                }
                
                // 인증 모달 표시
                showAuthModal();
            }, 1000);
        }
    } catch (error) {
        console.error('초기화 오류:', error);
        
        // 로딩 화면 숨기기
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        
        utils.showToast('초기화 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.', 'error');
    }
}

// 에러 핸들링 개선
window.onerror = function(message, source, lineno, colno, error) {
    console.error('Global error:', message, error);
    utils.showToast(`오류가 발생했습니다: ${message}`, 'error');
    return false;
};

// 앱 시작 함수
async function startApp() {
    try {
        // 로딩 화면 숨기기
        if (utils.validateElement(elements.loadingScreen, 'loadingScreen')) {
            elements.loadingScreen.style.display = 'none';
        }
        
        // 사용자 이름 표시 업데이트
        if (utils.validateElement(elements.userDisplayName, 'userDisplayName')) {
            elements.userDisplayName.textContent = api.getUsername() || '비회원';
        }
        
        // 비회원 모드 배너 표시/숨기기
        if (utils.validateElement(elements.guestModeBanner, 'guestModeBanner')) {
            elements.guestModeBanner.style.display = appState.isGuestMode ? 'flex' : 'none';
        }
        
        // 캔버스 초기화
        canvasRenderer.initCanvas();
        
        // 이벤트 리스너 설정
        setupEventListeners();
        
        // URL 해시 확인
        const hash = window.location.hash.substring(1);
        if (hash) {
            // 작품 ID가 있으면 작품 상세 페이지 열기
            openArtworkPage(hash);
        }
        
        // 개선된 토스트 메시지
        utils.showToast('VALPAINT가 준비되었습니다!', 'success');
        
        // VALORANT 폰트 적용
        applyValorantFont();
        
    } catch (error) {
        console.error('앱 시작 오류:', error);
        utils.showToast('앱 시작 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.', 'error');
    }
}

// 애플리케이션 시작
document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
